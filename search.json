[{"title":"EventBus 3.0 最佳实践和原理浅析","url":"http://xiazdong.github.io/2017/08/02/eventbus3/","content":"<h2 id=\"基本介绍\"><a href=\"#基本介绍\" class=\"headerlink\" title=\"基本介绍\"></a>基本介绍</h2><p>EventBus，中文名叫事件总线，他的定义如下：</p>\n<blockquote>\n<p>Android optimized event bus that simplifies communication between Activities, Fragments, Threads, Services, etc.</p>\n</blockquote>\n<p>可以看出，EventBus能够简化同一个进程的组件（比如Activity, Fragment, 线程, Service）之间的通信。</p>\n<blockquote>\n<p>EventBus只支持同一个进程内的通信，如果要跨进程通信，请使用<a href=\"https://github.com/elemers/HermesEventBus\" target=\"_blank\" rel=\"external\">HermesEventBus</a>。</p>\n</blockquote>\n<p>2016年2月份发布了EventBus 3.0，相比原来有两大优化点：</p>\n<ul>\n<li>EventBus 2.x中，订阅方法的方法名一定要以onEvent开头，比如onEventMainThread表示订阅方法执行在主线程；而EventBus 3.0中，订阅方法的方法名随意，只需要在前面加上注解：@Subscribe。</li>\n<li>通过注解方式声明订阅方法，速度相比2.x会变慢，通过引入注解处理器（annotation processor），在编译期间建立订阅方法的索引，性能有明显提升。</li>\n</ul>\n<blockquote>\n<p>根据官方说明，注解的引入让EventBus 3.0相比2.x性能变差3-5倍，但是引入索引，3.0相比2.x性能提高至少3倍。</p>\n</blockquote>\n<p>如果不引入索引，只需要在build.gradle加入：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">compile <span class=\"string\">'org.greenrobot:eventbus:3.0.0'</span></div></pre></td></tr></table></figure>\n<p>在proguard添加：</p>\n<figure class=\"highlight\"><table><tr><td class=\"code\"><pre><div class=\"line\">-keepattributes *Annotation*</div><div class=\"line\">-keepclassmembers class ** &#123;</div><div class=\"line\">    @org.greenrobot.eventbus.Subscribe &lt;methods&gt;;</div><div class=\"line\">&#125;</div><div class=\"line\">-keep enum org.greenrobot.eventbus.ThreadMode &#123; *; &#125;</div><div class=\"line\"></div><div class=\"line\"># Only required if you use AsyncExecutor</div><div class=\"line\">-keepclassmembers class * extends org.greenrobot.eventbus.util.ThrowableFailureEvent &#123;</div><div class=\"line\">    &lt;init&gt;(java.lang.Throwable);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>但是引入索引能够大幅提高性能，因此一般建议加入，在build.gradle加入：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">android &#123;</div><div class=\"line\">    ...</div><div class=\"line\">    javaCompileOptions &#123;</div><div class=\"line\">        annotationProcessorOptions &#123;</div><div class=\"line\">            arguments = [eventBusIndex: <span class=\"string\">\"com.xiazdong.eventbusdemo.EventBusIndex\"</span>]   <span class=\"comment\">//生成的索引文件名</span></div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\">dependencies &#123;</div><div class=\"line\">    compile <span class=\"string\">'org.greenrobot:eventbus:3.0.0'</span></div><div class=\"line\">    annotationProcessor  <span class=\"string\">'org.greenrobot:eventbus-annotation-processor:3.0.1'</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>然后在Application的onCreate()中加入：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">EventBus.builder().addIndex(<span class=\"keyword\">new</span> EventBusIndex()).installDefaultEventBus();</div></pre></td></tr></table></figure>\n<p>编译之后，索引文件在<code>build/generated/source/apt/debug/com/xiazdong/eventbusdemo/EventBusIndex.java</code>。</p>\n<h2 id=\"基本使用\"><a href=\"#基本使用\" class=\"headerlink\" title=\"基本使用\"></a>基本使用</h2><p>EventBus的使用一共3个步骤：</p>\n<ul>\n<li>定义事件（Event），事件就是EventBus中相互传递的对象（类似于Intent中的Bundle）。</li>\n<li>发送事件（Publisher）。</li>\n<li>订阅事件，实现订阅方法（Subscriber）。</li>\n</ul>\n<p>首先是定义事件：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MessageEvent</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">public</span> String name;</div><div class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">int</span> age;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">MessageEvent</span><span class=\"params\">(String name, <span class=\"keyword\">int</span> age)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.name = name;</div><div class=\"line\">        <span class=\"keyword\">this</span>.age = age;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这样事件传递的对象就是MessageEvent，里面包含name和age。</p>\n<p>接着，发送事件：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">EventBus.getDefault().post(<span class=\"keyword\">new</span> MessageEvent(<span class=\"string\">\"xiazdong\"</span>, <span class=\"number\">25</span>));</div></pre></td></tr></table></figure>\n<p>这个post()方法可以在任意线程调用。</p>\n<p>EventBus还支持粘性事件，一般来说，在post()之前订阅该事件才会收到事件，但是粘性事件为：发送事件（postSticky()）之后再订阅事件也能收到该事件。</p>\n<p>最后订阅事件：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">XActivity</span> <span class=\"keyword\">extends</span> <span class=\"title\">AppCompatActivity</span> </span>&#123;</div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreate</span><span class=\"params\">(Bundle savedInstanceState)</span> </span>&#123;</div><div class=\"line\">        ...</div><div class=\"line\">        EventBus.getDefault().register(<span class=\"keyword\">this</span>);  <span class=\"comment\">//注册了才能接收订阅</span></div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@Subscribe</span>(threadMode = ThreadMode.MAIN, priority = <span class=\"number\">5</span>, sticky = <span class=\"keyword\">false</span>)</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onMessageReceived</span><span class=\"params\">(MessageEvent event)</span> </span>&#123;</div><div class=\"line\">        Log.i(TAG, event.name + <span class=\"string\">\",\"</span> + event.age);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onDestroy</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        EventBus.getDefault().unregister(<span class=\"keyword\">this</span>); <span class=\"comment\">//取消注册</span></div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>onMessageReceived()就是订阅方法，threadMode有四种取值：</p>\n<ul>\n<li>ThreadMode.POSTING：默认值，post()在哪个线程调用，订阅方法就执行在哪个线程，不能执行耗时操作。</li>\n<li>ThreadMode.MAIN：订阅方法执行在主线程，用于更新UI。</li>\n<li>ThreadMode.BACKGROUND：如果post()在主线程调用，则订阅方法执行在某个固定后台线程（标记为BACKGROUND的订阅方法都执行在该线程）；如果post()在子线程调用，则订阅方法在该线程调用。不能执行耗时操作。</li>\n<li>ThreadMode.ASYNC：新建线程执行订阅方法，可以执行耗时操作。</li>\n</ul>\n<p>priority是优先级，值越大优先级越高，默认值为0。</p>\n<p>如果是粘性事件，需要加：sticky = true。</p>\n<p>EventBus这种通信方式的好处是：传递的内容可以是任意的，不像Intent中的Bundle只支持基本类型和实现了Parcelable的类型。</p>\n<p>LocalBroadcastManager（本地广播）是Android Support包提供的类，用于同一进程内的通信，是阉割版的EventBus，性能和加入编译时索引的EventBus差不多，相比EventBus有几个缺点：</p>\n<ul>\n<li>通过Intent的Bundle传递数据，数据类型只能是基本类型或实现Parcelable接口。EventBus能传递任何对象。</li>\n<li>onReceive()只能在主线程运行。EventBus的订阅方法能通过配置运行在主线程或子线程。</li>\n<li>使用麻烦。</li>\n</ul>\n<p>因此建议使用EventBus。</p>\n<h2 id=\"基本原理\"><a href=\"#基本原理\" class=\"headerlink\" title=\"基本原理\"></a>基本原理</h2><p>我们先从编译时生成的索引类（这里类名为EventBusIndex）开始讲起，该类是的作用是：收集所有订阅方法的信息，并保存到SUBSCRIBER_INDEX变量中，该变量是Map，key为类名，value为SubscriberInfo对象（实际为实现SubscriberInfo接口的SimpleSubscriberInfo对象）。需要注意：</p>\n<ul>\n<li>SimpleSubscriberInfo对象包含了：类名、该类中所有的订阅方法（SubscriberMethodInfo对象）、该类的父类的SubscriberInfo对象。</li>\n<li>一个SubscriberMethodInfo对象包含了一个订阅方法的信息，包含了方法名、threadMode值、事件类型（即订阅方法的参数类型）、priority值、sticky值。</li>\n<li>EventBusIndex的getSubscriberInfo()能通过订阅者类返回SubscriberInfo对象。</li>\n</ul>\n<p>我们先分析Application中的语句：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">EventBus.builder().addIndex(<span class=\"keyword\">new</span> EventBusIndex()).installDefaultEventBus();</div></pre></td></tr></table></figure>\n<p>EventBus类是核心类，整个原理的分析全部围绕他，EventBusBuilder类是构造EventBus对象的类。通过为EventBusBuilder设置一些配置（比如是否需要忽略索引类，即ignoreGeneratedIndex变量，默认为false），然后调用build()就构造出了一个EventBus对象。</p>\n<p>EventBus.builder()创建了EventBusBuilder对象，addIndex(new EventBusIndex())将索引类对象设置到EventBusBuilder对象的subscriberInfoIndexes变量中，installDefaultEventBus()为根据EventBusBuilder的配置构建一个EventBus对象，并设置到EventBus类的defaultInstance变量中。</p>\n<p>未来的EventBus.getDefault()都会获得Application中配置的新的EventBus对象。</p>\n<p>EventBus整个注册、发送、接收过程，最关键的变量为：</p>\n<ul>\n<li><code>Map&lt;Class&lt;?&gt;, CopyOnWriteArrayList&lt;Subscription&gt;&gt; subscriptionsByEventType</code>：key为事件类型，value为<code>List&lt;Subscription&gt;</code>，即该事件类型对应的所有订阅方法（顺序按优先级排序），Subscription类包含了订阅者类和一个SubscriberMethod对象（包含了订阅方法的信息，和SubscriberMethodInfo差不多）。</li>\n<li><code>Map&lt;Object, List&lt;Class&lt;?&gt;&gt;&gt; typesBySubscriber</code>：key为订阅者类名，value为该订阅者类中所有的事件类型。</li>\n<li><code>Map&lt;Class&lt;?&gt;, List&lt;SubscriberMethod&gt;&gt; METHOD_CACHE</code>：key为订阅者类名，value为该类中所有的订阅方法信息。这是缓存类，用于缓存通过索引或反射查找到的结果。</li>\n<li><code>SubscriberMethodFinder subscriberMethodFinder</code>：其中的findSubscriberMethods()根据订阅者类获得该类中所有的订阅方法信息。</li>\n</ul>\n<p>注册：即调用EventBus的register()，即注册订阅者的所有订阅事件，代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">register</span><span class=\"params\">(Object subscriber)</span> </span>&#123;</div><div class=\"line\">    Class&lt;?&gt; subscriberClass = subscriber.getClass();</div><div class=\"line\">    List&lt;SubscriberMethod&gt; subscriberMethods = subscriberMethodFinder.findSubscriberMethods(subscriberClass);</div><div class=\"line\">    <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">for</span> (SubscriberMethod subscriberMethod : subscriberMethods) &#123;</div><div class=\"line\">            subscribe(subscriber, subscriberMethod);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>该方法先通过subscriberMethodFinder的findSubscriberMethods()根据订阅者类名查找到该类的所有订阅方法信息（<code>List&lt;SubscriberMethod&gt;</code>），然后调用subscribe()把这些信息填充到subscriptionsByEventType和typesBySubscriber中。</p>\n<p>SubscriberMethodFinder类中的findSubscriberMethods()代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\">List&lt;SubscriberMethod&gt; <span class=\"title\">findSubscriberMethods</span><span class=\"params\">(Class&lt;?&gt; subscriberClass)</span> </span>&#123;</div><div class=\"line\">    <span class=\"comment\">//从METHOD_CACHE中查找结果</span></div><div class=\"line\">    List&lt;SubscriberMethod&gt; subscriberMethods = METHOD_CACHE.get(subscriberClass);</div><div class=\"line\">    <span class=\"keyword\">if</span> (subscriberMethods != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> subscriberMethods;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">if</span> (ignoreGeneratedIndex) &#123;</div><div class=\"line\">        subscriberMethods = findUsingReflection(subscriberClass); <span class=\"comment\">//通过注解反射查找结果</span></div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">        subscriberMethods = findUsingInfo(subscriberClass); <span class=\"comment\">//从索引类中查找结果</span></div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">if</span> (subscriberMethods.isEmpty()) &#123;</div><div class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> EventBusException(<span class=\"string\">\"Subscriber \"</span> + subscriberClass</div><div class=\"line\">                + <span class=\"string\">\" and its super classes have no public methods with the @Subscribe annotation\"</span>);</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">        METHOD_CACHE.put(subscriberClass, subscriberMethods);  <span class=\"comment\">//把结果放入METHOD_CACHE中，避免下次再一次查找</span></div><div class=\"line\">        <span class=\"keyword\">return</span> subscriberMethods;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>该方法先后通过几种方法查找订阅方法信息：</p>\n<ul>\n<li>METHOD_CACHE：存放以前查找过的结果，避免下次重复查找。</li>\n<li>判断ignoreGeneratedIndex：是否忽略生成的索引类，该值默认为false，也建议为false，因此我们只考虑else分支。</li>\n<li><code>findUsingInfo()</code>：先从索引类中查找结果，如果找不到，再通过反射（<code>findUsingReflectionInSingleClass()</code>）查找结果。</li>\n<li>如果查找到结果，就放入METHOD_CACHE缓存，避免下次重复查找。</li>\n</ul>\n<p>因此索引类的引入主要减少了register()的耗时，即用编译时生成索引的方式代替了方法反射，前面说的EventBus 3.0相比EventBus 2.x速度提升至少3倍说的就是register()方法速度的提升。</p>\n<p>接着看unregister()，该方法就是将该订阅者相关的订阅事件信息和订阅方法信息等从subscriptionsByEventType和typesBySubscriber中删除。</p>\n<p>最后是post()，该方法用来发送订阅事件，并调用相关订阅者的订阅方法，具体怎么查找订阅者，是通过subscriptionsByEventType查找订阅者的订阅方法。具体在哪个线程调用订阅方法，通过订阅方法的threadMode声明确定。post()方法实现如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">post</span><span class=\"params\">(Object event)</span> </span>&#123;</div><div class=\"line\">    PostingThreadState postingState = currentPostingThreadState.get();</div><div class=\"line\">    List&lt;Object&gt; eventQueue = postingState.eventQueue;</div><div class=\"line\">    eventQueue.add(event);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">if</span> (!postingState.isPosting) &#123;</div><div class=\"line\">        postingState.isMainThread = Looper.getMainLooper() == Looper.myLooper();</div><div class=\"line\">        postingState.isPosting = <span class=\"keyword\">true</span>;</div><div class=\"line\">        <span class=\"keyword\">if</span> (postingState.canceled) &#123;</div><div class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> EventBusException(<span class=\"string\">\"Internal error. Abort state was not reset\"</span>);</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">            <span class=\"keyword\">while</span> (!eventQueue.isEmpty()) &#123;   <span class=\"comment\">//依次发送队列中的事件</span></div><div class=\"line\">                postSingleEvent(eventQueue.remove(<span class=\"number\">0</span>), postingState);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</div><div class=\"line\">            postingState.isPosting = <span class=\"keyword\">false</span>;</div><div class=\"line\">            postingState.isMainThread = <span class=\"keyword\">false</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>currentPostingThreadState变量是<code>ThreadLocal&lt;PostingThreadState&gt;</code>类型的，即每个线程都有一个PostingThreadState对象，该类结构为：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">final</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PostingThreadState</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">final</span> List&lt;Object&gt; eventQueue = <span class=\"keyword\">new</span> ArrayList&lt;Object&gt;();  <span class=\"comment\">//事件队列</span></div><div class=\"line\">    <span class=\"keyword\">boolean</span> isPosting;      <span class=\"comment\">//是否正在发送事件</span></div><div class=\"line\">    <span class=\"keyword\">boolean</span> isMainThread;  <span class=\"comment\">//当前线程是否是主线程</span></div><div class=\"line\">    …</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>post()共分为3步：</p>\n<ul>\n<li>把订阅事件信息放入eventQueue中，等待被执行。</li>\n<li>判断isPosting变量是否为true（即当前线程是否正在发送事件），如果为false，则置为true并循环遍历eventQueue，并调用postSingleEvent()发送订阅事件；否则直接返回，让当前正在遍历队列的对象执行订阅方法。</li>\n<li>最后把isPosting和isMainThread置为false。</li>\n</ul>\n<p>postSingleEvent()首先会寻找该订阅事件的所有父类，并依次发送这些事件和该订阅事件，即对每个订阅事件调用postSingleEventForEventType()，在postSingleEventForEventType()中通过subscriptionsByEventType查找到订阅事件对应的所有订阅方法，并对每个订阅方法调用postToSubscription()，该方法是EventBus调配订阅方法在哪个线程执行的核心方法，如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">postToSubscription</span><span class=\"params\">(Subscription subscription, Object event, <span class=\"keyword\">boolean</span> isMainThread)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">switch</span> (subscription.subscriberMethod.threadMode) &#123;</div><div class=\"line\">        <span class=\"keyword\">case</span> POSTING:</div><div class=\"line\">            invokeSubscriber(subscription, event);</div><div class=\"line\">            <span class=\"keyword\">break</span>;</div><div class=\"line\">        <span class=\"keyword\">case</span> MAIN:</div><div class=\"line\">            <span class=\"keyword\">if</span> (isMainThread) &#123;</div><div class=\"line\">                invokeSubscriber(subscription, event);</div><div class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">                mainThreadPoster.enqueue(subscription, event);</div><div class=\"line\">            &#125;</div><div class=\"line\">            <span class=\"keyword\">break</span>;</div><div class=\"line\">        <span class=\"keyword\">case</span> BACKGROUND:</div><div class=\"line\">            <span class=\"keyword\">if</span> (isMainThread) &#123;</div><div class=\"line\">                backgroundPoster.enqueue(subscription, event);</div><div class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">                invokeSubscriber(subscription, event);</div><div class=\"line\">            &#125;</div><div class=\"line\">            <span class=\"keyword\">break</span>;</div><div class=\"line\">        <span class=\"keyword\">case</span> ASYNC:</div><div class=\"line\">            asyncPoster.enqueue(subscription, event);</div><div class=\"line\">            <span class=\"keyword\">break</span>;</div><div class=\"line\">        <span class=\"keyword\">default</span>:</div><div class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(<span class=\"string\">\"Unknown thread mode: \"</span> + subscription.subscriberMethod.threadMode);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这里有三种Poster，他们的共同点：内部都有PostPendingQueue和PendingPost，PostPendingQueue是存放PendingPost的队列，PendingPost存放了订阅事件和Subscription对象，即待调用的订阅方法。</p>\n<p>他们的不同点：</p>\n<ul>\n<li>mainThreadPoster是主线程的Handler，即在handleMessage中调用订阅方法；backgroundPoster和asyncPoster是Runnable，他们的run()会遍历PostPendingQueue队列，并调用订阅方法。</li>\n<li>backgroundPoster：和asyncPoster一起使用EventBus的executorService线程池。内部有executorRunning变量判断run()方法是否正在执行，如果正在执行，就只是把PendingPost放入队列，让当前的run()方法去调用该订阅方法。</li>\n<li>asyncPoster：使用EventBus的executorService线程池，每次都创建线程并调用订阅方法。</li>\n</ul>\n<p>对于threadMode的值分了四种情况：</p>\n<ul>\n<li>POSTING：invokeSubscriber()就是直接用反射调用订阅方法。</li>\n<li>MAIN：如果调用post()时就是主线程，那就直接反射调用订阅方法；否则就加入mainThreadPoster的队列。</li>\n<li>BACKGROUND：如果当前线程是主线程，那么加入backgroundPoster的队列；如果当前线程不是主线程，那么直接调用订阅方法。</li>\n<li>ASYNC：加入asyncPoster的队列。</li>\n</ul>\n<h2 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h2><ul>\n<li>入门：<a href=\"http://liuwangshu.cn/application/eventbus/1-eventbus.html\" target=\"_blank\" rel=\"external\">http://liuwangshu.cn/application/eventbus/1-eventbus.html</a></li>\n<li>原理1：<a href=\"http://blog.csdn.net/u011240877/article/details/73196808\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/u011240877/article/details/73196808</a></li>\n<li>原理2：<a href=\"http://www.cnblogs.com/bugly/p/5475034.html\" target=\"_blank\" rel=\"external\">http://www.cnblogs.com/bugly/p/5475034.html</a></li>\n<li>原理3：<a href=\"http://liuwangshu.cn/application/eventbus/2-eventbus-sourcecode.html\" target=\"_blank\" rel=\"external\">http://liuwangshu.cn/application/eventbus/2-eventbus-sourcecode.html</a></li>\n<li>官方PPT：<a href=\"http://androiddevblog.com/wordpress/wp-content/uploads/EventBus3.pdf\" target=\"_blank\" rel=\"external\">http://androiddevblog.com/wordpress/wp-content/uploads/EventBus3.pdf</a></li>\n</ul>\n","categories":[],"tags":["Android"]},{"title":"Android图像处理-简单的实时肤色变换实现","url":"http://xiazdong.github.io/2017/07/25/skin-transfer/","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>肤色变换是一件非常有意思的事情，问题的定义是：给定一张图片且图中只有一个人，一个目标颜色（Target Color），将图中人的肤色变为目标颜色。比如图中有一个白人，目标颜色设为c，经过肤色变换，图中白人的肤色就自然的过渡为c。</p>\n<p>看到这个问题，凭空想觉得方法非常简单，无非两步：（1）检测出皮肤区域（2）对皮肤区域进行颜色变换。但在实现过程中会有几个问题：</p>\n<ul>\n<li>肤色检测不准确。</li>\n<li>如果只是纯粹把肤色区域直接变为目标颜色，会让皮肤失去皮肤纹理，变得很不真实。</li>\n</ul>\n<p>因此本文针对这些问题，实现了一个比较简单的肤色变换功能。</p>\n<h2 id=\"流程图\"><a href=\"#流程图\" class=\"headerlink\" title=\"流程图\"></a>流程图</h2><p>本文的肤色变换流程图如下图：</p>\n<p><img src=\"http://ac-HSNl7zbI.clouddn.com/HKJ8HKJCbJAyXIKPeW6FzUUxbXT38DPOSlV7q4lw.jpg\" alt=\"\"></p>\n<p>为了加快整个过程的处理速度，每个步骤的算法都是OpenGL Shader实现的，整体速度非常快。</p>\n<h2 id=\"具体实现\"><a href=\"#具体实现\" class=\"headerlink\" title=\"具体实现\"></a>具体实现</h2><h3 id=\"统计人脸平均肤色\"><a href=\"#统计人脸平均肤色\" class=\"headerlink\" title=\"统计人脸平均肤色\"></a>统计人脸平均肤色</h3><p>这个需要依赖现有的人脸检测库，获得人脸检测库返回的83个点后，利用83个点中的部分点画出人脸中的局部mask（此处并不需要很精确的获得整个人脸，只需要获得部分肯定为皮肤的光滑区域），具体方法为：利用第0到18点画出部分区域，然后扣除眼睛、鼻子、嘴巴区域。效果如下：</p>\n<p><img src=\"http://ac-HSNl7zbI.clouddn.com/LcOBt1QHFx8vMpB2rJ4PF4j16KD0Y2nnc9MEOIS1.jpg\" alt=\"\"></p>\n<p>接着统计Mask中白色区域的平均颜色，即获得了当前人脸的平均肤色，记为avgColor。</p>\n<h3 id=\"皮肤检测\"><a href=\"#皮肤检测\" class=\"headerlink\" title=\"皮肤检测\"></a>皮肤检测</h3><p>本文中，皮肤检测（Skin Detection）是基于像素的多尺度动态阈值算法，总共分为二步。</p>\n<p>第一步是皮肤检测算法，本文的皮肤检测是基于YCgCb颜色空间的多尺度动态阈值模型，生成SkinMask，该Mask的每个像素的取值为0到1，表示是皮肤的概率，该算法的特点：</p>\n<ul>\n<li>判断当前像素是否为皮肤不依赖其他像素，这也方便了我们实现为shader版本。</li>\n<li>动态阈值的意思是皮肤的判断基于当前人脸统计的平均肤色，而不是静态的模型，而是avgColor为中心的概率模型。</li>\n<li>多尺度的意思是对原图分别进行1/2，1/4，1/8的缩放，分别生成SkinMask后，再进行融合生成最终的SkinMask。</li>\n</ul>\n<p>效果如下：</p>\n<p><img src=\"http://ac-HSNl7zbI.clouddn.com/gECM9DyOn6pI099VTT7wKagVzPkSi8ew2VLMmPfe.jpg\" alt=\"\"></p>\n<blockquote>\n<p>后来发现利用深度学习构建卷积神经网络进行皮肤检测效果比基于像素的皮肤检测好。</p>\n</blockquote>\n<p>具体的fragment shader如下，其中x和y为avgColor的Cg和Cb分量值：</p>\n<figure class=\"highlight glsl\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">precision</span> <span class=\"keyword\">highp</span> <span class=\"type\">float</span>;</div><div class=\"line\"><span class=\"keyword\">varying</span> <span class=\"type\">vec2</span> textureCoordinate;</div><div class=\"line\"><span class=\"keyword\">uniform</span> <span class=\"type\">sampler2D</span> inputImageTexture;</div><div class=\"line\"><span class=\"keyword\">uniform</span> <span class=\"type\">float</span> x;<span class=\"comment\">//中心点x坐标</span></div><div class=\"line\"><span class=\"keyword\">uniform</span> <span class=\"type\">float</span> y;<span class=\"comment\">//中心点y坐标</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"type\">float</span> isSkinColor(<span class=\"type\">vec4</span> color) &#123;</div><div class=\"line\">  <span class=\"type\">float</span> cg1 = <span class=\"built_in\">dot</span>(<span class=\"type\">vec3</span>(<span class=\"number\">-81.085</span>,<span class=\"number\">112.0</span>,<span class=\"number\">-30.915</span>), color.rgb);</div><div class=\"line\">  <span class=\"type\">float</span> cb1 = <span class=\"built_in\">dot</span>(<span class=\"type\">vec3</span>(<span class=\"number\">-37.797</span>,<span class=\"number\">-74.203</span>,<span class=\"number\">112.0</span>), color.rgb);</div><div class=\"line\">  <span class=\"type\">float</span> cg = cg1+<span class=\"number\">128.0</span>-x;</div><div class=\"line\">  <span class=\"type\">float</span> cb = cb1+<span class=\"number\">128.0</span>-y;</div><div class=\"line\">  <span class=\"type\">float</span> v = <span class=\"built_in\">max</span>(<span class=\"built_in\">sqrt</span>(cg*cg+cb*cb)<span class=\"number\">-14.0</span>, <span class=\"number\">0.0</span>);</div><div class=\"line\">  <span class=\"type\">float</span> s = <span class=\"built_in\">pow</span>(<span class=\"number\">2.718281828459</span>, -v / <span class=\"number\">4.0</span>);</div><div class=\"line\">  <span class=\"type\">float</span> gray = <span class=\"built_in\">dot</span>(<span class=\"type\">vec3</span>(<span class=\"number\">0.3</span>,<span class=\"number\">0.6</span>,<span class=\"number\">0.1</span>), color.rgb);</div><div class=\"line\">  <span class=\"type\">float</span> s1 = <span class=\"built_in\">min</span>(<span class=\"number\">1.0</span>, gray/<span class=\"number\">0.25</span>);</div><div class=\"line\">  s = s * (s1*s1);</div><div class=\"line\">  s = <span class=\"built_in\">min</span>(<span class=\"number\">1.0</span>, s);</div><div class=\"line\">  <span class=\"keyword\">return</span> s;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"type\">void</span> main()</div><div class=\"line\">&#123;</div><div class=\"line\">  <span class=\"type\">vec4</span> texColor = <span class=\"built_in\">texture2D</span>(inputImageTexture, textureCoordinate);</div><div class=\"line\">  <span class=\"type\">float</span> s = isSkinColor(texColor);</div><div class=\"line\">  <span class=\"built_in\">gl_FragColor</span> = <span class=\"type\">vec4</span>(s,s,s, <span class=\"number\">1.0</span>);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>可以看出第一步获得的SkinMask可能是不精确的，如果背景有物体的颜色和当前人的肤色一样，会被认为是皮肤，为了让SkinMask更精确，我们需要使用人像分割技术（Fabby），把背景抠除。</p>\n<p>第二步是利用现有的Fabby库对原图做操作，将背景扣除，获得FabbyMask，效果如下：</p>\n<p><img src=\"http://ac-HSNl7zbI.clouddn.com/HtCbgKVB5vzXf5uohnmb2k42puuznIHgALaCDWfn.jpg\" alt=\"\"></p>\n<p>接着我们结合SkinMask和FabbyMask生成最终的FinalMask，效果如下：</p>\n<p><img src=\"http://ac-HSNl7zbI.clouddn.com/UecnHe8HO751bs1URSHXQTpt9Si6bdfCJUpAUEQ4.jpg\" alt=\"\"></p>\n<h3 id=\"肤色变换\"><a href=\"#肤色变换\" class=\"headerlink\" title=\"肤色变换\"></a>肤色变换</h3><p>肤色变换实际上是颜色变换（Color Transfer）的一种应用，最早的颜色变换论文是”Color Transfer Between Images”，该论文给定一张source image，给定一张target image，将source image的颜色基调变为target image的颜色基调。效果如下：</p>\n<p><img src=\"http://ac-HSNl7zbI.clouddn.com/aJ1S7A3H50c14WsA454tiGnGmD2UQ1MR7Msw2zF7.jpg\" alt=\"\"></p>\n<p>但是这篇论文中的颜色变换会对source image的整体颜色进行变换（global image recoloring），因此”Interactive Local Color Transfer Between Images”提出了局部颜色变换的概念，即对source image的一个部分进行颜色变换（尽量不改变其中的其他区域，实践证明效果一般，针对论文中的图片效果还不错）。该论文提出了一种交互式的局部颜色变换算法，先在source image中圈出一小块你需要变色的区域（不需要很精确，或指定一个颜色，记为sacolor），然后指定target color，接着该算法能自动将source image中越接近sacolor的颜色变换为target color。</p>\n<p>这篇论文也给出了将该算法应用到肤色变换的效果，如下：</p>\n<p><img src=\"http://ac-HSNl7zbI.clouddn.com/XyIYjPwj0w9Y1bDXFFQvyYLpkQhCaMzvjRgADtJI.jpg\" alt=\"\"></p>\n<p>我们这里实现的肤色变换算法就是基于这两篇论文，因此步骤为：</p>\n<ul>\n<li>获得sacolor：当前图片中人脸的肤色，该颜色我们已经在先前获得。</li>\n<li>指定targetcolor：目标颜色，下面指定为绿色。</li>\n<li>肤色变换，该算法基于LAB颜色空间。</li>\n</ul>\n<p>LAB中每个分量的含义如下：</p>\n<ul>\n<li>L表示亮度（0，100），其中0表示黑色，100表示白色。</li>\n<li>A表示红绿（-128，127），其中-128表示绿色，127表示红色。</li>\n<li>B表示黄蓝（-128，127），其中-128表示蓝色，127表示黄色。</li>\n</ul>\n<p>这里对其取值范围进行了一些转换，因此取值范围有些不同。</p>\n<p>RGB转LAB：</p>\n<figure class=\"highlight glsl\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"type\">vec3</span> rgb2lab(<span class=\"type\">vec4</span> color) &#123;</div><div class=\"line\">  <span class=\"type\">float</span> L = <span class=\"number\">0.3811</span> * color.b + <span class=\"number\">0.5783</span> * color.g + <span class=\"number\">0.0402</span> * color.r;</div><div class=\"line\">  <span class=\"type\">float</span> M = <span class=\"number\">0.1967</span> * color.b + <span class=\"number\">0.7244</span> * color.g + <span class=\"number\">0.0782</span> * color.r;</div><div class=\"line\">  <span class=\"type\">float</span> S = <span class=\"number\">0.0241</span> * color.b + <span class=\"number\">0.1288</span> * color.g + <span class=\"number\">0.8444</span> * color.r;</div><div class=\"line\">  <span class=\"keyword\">if</span> (L == <span class=\"number\">0.0</span>) L = <span class=\"number\">1.0</span>;</div><div class=\"line\">  <span class=\"keyword\">if</span> (M == <span class=\"number\">0.0</span>) M = <span class=\"number\">1.0</span>;</div><div class=\"line\">  <span class=\"keyword\">if</span> (S == <span class=\"number\">0.0</span>) S = <span class=\"number\">1.0</span>;</div><div class=\"line\">  L = <span class=\"built_in\">log</span>(L);</div><div class=\"line\">  M = <span class=\"built_in\">log</span>(M);</div><div class=\"line\">  S = <span class=\"built_in\">log</span>(S);</div><div class=\"line\"></div><div class=\"line\">  <span class=\"type\">float</span> ll = (L + M + S) / <span class=\"built_in\">sqrt</span>(<span class=\"number\">3.0</span>);</div><div class=\"line\">  <span class=\"type\">float</span> aa = (L + M - <span class=\"number\">2.0</span> * S) / <span class=\"built_in\">sqrt</span>(<span class=\"number\">6.0</span>);</div><div class=\"line\">  <span class=\"type\">float</span> bb = (L - M) / <span class=\"built_in\">sqrt</span>(<span class=\"number\">2.0</span>);</div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"type\">vec3</span>(ll, aa, bb);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>LAB转RGB：</p>\n<figure class=\"highlight glsl\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"type\">vec4</span> lab2rgb(<span class=\"type\">vec3</span> lab) &#123;</div><div class=\"line\">  <span class=\"type\">float</span> L = lab.r / <span class=\"built_in\">sqrt</span>(<span class=\"number\">3.0</span>) + lab.g / <span class=\"built_in\">sqrt</span>(<span class=\"number\">6.0</span>) + lab.b / <span class=\"built_in\">sqrt</span>(<span class=\"number\">2.0</span>);</div><div class=\"line\">  <span class=\"type\">float</span> M = lab.r / <span class=\"built_in\">sqrt</span>(<span class=\"number\">3.0</span>) + lab.g / <span class=\"built_in\">sqrt</span>(<span class=\"number\">6.0</span>) - lab.b / <span class=\"built_in\">sqrt</span>(<span class=\"number\">2.0</span>);</div><div class=\"line\">  <span class=\"type\">float</span> S = lab.r / <span class=\"built_in\">sqrt</span>(<span class=\"number\">3.0</span>) - <span class=\"number\">2.0</span> * lab.g / <span class=\"built_in\">sqrt</span>(<span class=\"number\">6.0</span>);</div><div class=\"line\">  L = <span class=\"built_in\">exp</span>(L);</div><div class=\"line\">  M = <span class=\"built_in\">exp</span>(M);</div><div class=\"line\">  S = <span class=\"built_in\">exp</span>(S);</div><div class=\"line\">  <span class=\"type\">float</span> b = <span class=\"number\">4.4679</span> * L - <span class=\"number\">3.5873</span> * M + <span class=\"number\">0.1193</span> * S;</div><div class=\"line\">  <span class=\"type\">float</span> g = <span class=\"number\">-1.2186</span> * L + <span class=\"number\">2.3809</span> * M - <span class=\"number\">0.1624</span> * S;</div><div class=\"line\">  <span class=\"type\">float</span> r = <span class=\"number\">-0.0497</span> * L - <span class=\"number\">0.2439</span> * M + <span class=\"number\">1.2045</span> * S;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">if</span> (b &gt; <span class=\"number\">1.0</span>) b = <span class=\"number\">1.0</span>;</div><div class=\"line\">  <span class=\"keyword\">if</span> (b &lt; <span class=\"number\">0.0</span>) b = <span class=\"number\">0.0</span>;</div><div class=\"line\">  <span class=\"keyword\">if</span> (g &gt; <span class=\"number\">1.0</span>) g = <span class=\"number\">1.0</span>;</div><div class=\"line\">  <span class=\"keyword\">if</span> (g &lt; <span class=\"number\">0.0</span>) g = <span class=\"number\">0.0</span>;</div><div class=\"line\">  <span class=\"keyword\">if</span> (r &gt; <span class=\"number\">1.0</span>) r = <span class=\"number\">1.0</span>;</div><div class=\"line\">  <span class=\"keyword\">if</span> (r &lt; <span class=\"number\">0.0</span>) r = <span class=\"number\">0.0</span>;</div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"type\">vec4</span>(r,g,b, <span class=\"number\">1.0</span>);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>接着就是颜色变换算法，该算法的思路为：对于原图的每个像素color，计算color与sacolor的距离，如果距离越近，那么变换成越接近targetcolor的颜色，否则，颜色改变越少。实现如下：</p>\n<figure class=\"highlight glsl\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">precision</span> <span class=\"keyword\">highp</span> <span class=\"type\">float</span>;</div><div class=\"line\"><span class=\"keyword\">varying</span> <span class=\"type\">vec2</span> textureCoordinate;</div><div class=\"line\"><span class=\"keyword\">uniform</span> <span class=\"type\">sampler2D</span> inputImageTexture;</div><div class=\"line\"><span class=\"keyword\">uniform</span> <span class=\"type\">float</span> skinl;  <span class=\"comment\">//当前人脸平均肤色的L分量</span></div><div class=\"line\"><span class=\"keyword\">uniform</span> <span class=\"type\">float</span> skina;  <span class=\"comment\">//当前人脸平均肤色的A分量</span></div><div class=\"line\"><span class=\"keyword\">uniform</span> <span class=\"type\">float</span> skinb;  <span class=\"comment\">//当前人脸平均肤色的B分量</span></div><div class=\"line\"><span class=\"keyword\">uniform</span> <span class=\"type\">float</span> targetl;<span class=\"comment\">//目标颜色的L分量</span></div><div class=\"line\"><span class=\"keyword\">uniform</span> <span class=\"type\">float</span> targeta;<span class=\"comment\">//目标颜色的A分量</span></div><div class=\"line\"><span class=\"keyword\">uniform</span> <span class=\"type\">float</span> targetb;<span class=\"comment\">//目标颜色的B分量</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"type\">vec3</span> rgb2lab(<span class=\"type\">vec4</span> color) &#123;</div><div class=\"line\">    ...</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"type\">vec4</span> lab2rgb(<span class=\"type\">vec3</span> lab) &#123;</div><div class=\"line\">    ...</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"type\">float</span> euclidean(<span class=\"type\">vec3</span> e1, <span class=\"type\">vec3</span> e2) &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">sqrt</span>((e1.r - e2.r) * (e1.r - e2.r) + (e1.g - e2.g) * (e1.g - e2.g) + (e1.b - e2.b) * (e1.b - e2.b));</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"type\">void</span> main()</div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"type\">vec4</span> texColor = <span class=\"built_in\">texture2D</span>(inputImageTexture, textureCoordinate);</div><div class=\"line\">    <span class=\"type\">vec3</span> lab = rgb2lab(texColor);</div><div class=\"line\">    <span class=\"type\">vec3</span> skin = <span class=\"type\">vec3</span>(skinl, skina, skinb);</div><div class=\"line\">    <span class=\"type\">float</span> <span class=\"built_in\">distance</span> = euclidean(lab, skin);</div><div class=\"line\">    <span class=\"built_in\">distance</span> = <span class=\"built_in\">distance</span> / <span class=\"number\">5.0</span>;</div><div class=\"line\">    <span class=\"type\">float</span> f = <span class=\"number\">1.0</span> / <span class=\"built_in\">exp</span>(<span class=\"number\">3.0</span> * <span class=\"built_in\">distance</span> * <span class=\"built_in\">distance</span>);</div><div class=\"line\">    <span class=\"type\">vec3</span> result_lab;</div><div class=\"line\">    result_lab.r = lab.r + f * (targetl - skinl);</div><div class=\"line\">    result_lab.g = lab.g + f * (targeta - skina);</div><div class=\"line\">    result_lab.b = lab.b + f * (targetb - skinb);</div><div class=\"line\">    <span class=\"built_in\">gl_FragColor</span> = lab2rgb(result_lab);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>效果如下：</p>\n<p><img src=\"http://ac-HSNl7zbI.clouddn.com/gMVvoPlI24TDvyLzuFd1GU4CC1QfFHwB03b2JMrS.jpg\" alt=\"\"></p>\n<p>论文中指出，颜色变换比较适合景色的颜色变换，对肤色变换效果不一定很理想。</p>\n<h3 id=\"融合\"><a href=\"#融合\" class=\"headerlink\" title=\"融合\"></a>融合</h3><p>最后用FinalMask对TransferImg进行过滤，最后生成的效果如下：</p>\n<p><img src=\"http://ac-HSNl7zbI.clouddn.com/dIOqHqiyHcn95kVtPwkULYjnAyciEXXr2mDbDozb.jpg\" alt=\"\"></p>\n<p>效果看起来还可以，但是边界处的变化较为明显，比较突兀。</p>\n","categories":[],"tags":["Android"]},{"title":"Android基础：Fragment，看这篇就够了","url":"http://xiazdong.github.io/2017/06/15/android-fragment/","content":"<p>下文中Demo的源代码地址：<a href=\"https://github.com/xiazdong/FragmentDemo\" target=\"_blank\" rel=\"external\">FragmentDemo</a>。</p>\n<h2 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h2><p>Fragment，简称碎片，是Android 3.0（API 11）提出的，为了兼容低版本，support-v4库中也开发了一套Fragment API，最低兼容Android 1.6。</p>\n<p>过去support-v4库是一个jar包，24.2.0版本开始，将support-v4库模块化为多个jar包，包含：support-fragment, support-ui, support-media-compat等，这么做是为了减少APK包大小，你需要用哪个模块就引入哪个模块。</p>\n<p>如果想引入整个support-v4库，则<code>compile &#39;com.android.support:support-v4:24.2.1&#39;</code>，如果只想引入support-fragment库，则<code>com.android.support:support-fragment:24.2.1</code>。</p>\n<blockquote>\n<p>因为support库是不断更新的，因此建议使用support库中的android.support.v4.app.Fragment，而不要用系统自带的android.app.Fragment。而如果要使用support库的Fragment，Activity必须要继承FragmentActivity（AppCompatActivity是FragmentActivity的子类）。</p>\n</blockquote>\n<p>Fragment官方的定义是：</p>\n<blockquote>\n<p>A Fragment represents a behavior or a portion of user interface in an Activity. You can combine multiple fragments in a single activity to build a multi-pane UI and reuse a fragment in multiple activities. You can think of a fragment as a modular section of an activity, which has its own lifecycle, receives its own input events, and which you can add or remove while the activity is running.</p>\n</blockquote>\n<p>根据上面的定义可知：</p>\n<ul>\n<li>Fragment是依赖于Activity的，不能独立存在的。</li>\n<li>一个Activity里可以有多个Fragment。</li>\n<li>一个Fragment可以被多个Activity重用。</li>\n<li>Fragment有自己的生命周期，并能接收输入事件。</li>\n<li>我们能在Activity运行时动态地添加或删除Fragment。</li>\n</ul>\n<blockquote>\n<p>Android 3.0系统只针对平板电脑，且闭源，那时候针对手机和针对平板是两套源代码，后来Android 4.0时整合了手机和平板的源码，因此市面上很难看到Android 3.0系统。</p>\n</blockquote>\n<p>Fragment的优势有以下几点：</p>\n<ul>\n<li>模块化（Modularity）：我们不必把所有代码全部写在Activity中，而是把代码写在各自的Fragment中。</li>\n<li>可重用（Reusability）：多个Activity可以重用一个Fragment。</li>\n<li>可适配（Adaptability）：根据硬件的屏幕尺寸、屏幕方向，能够方便地实现不同的布局，这样用户体验更好。</li>\n</ul>\n<p><img src=\"https://raw.githubusercontent.com/xiazdong/blog-image/master/fragment-01.png\" alt=\"\"></p>\n<p>Fragment核心的类有：</p>\n<ul>\n<li>Fragment：Fragment的基类，任何创建的Fragment都需要继承该类。</li>\n<li>FragmentManager：管理和维护Fragment。他是抽象类，具体的实现类是FragmentManagerImpl。</li>\n<li>FragmentTransaction：对Fragment的添加、删除等操作都需要通过事务方式进行。他是抽象类，具体的实现类是BackStackRecord。</li>\n</ul>\n<p>Nested Fragment（Fragment内部嵌套Fragment的能力）是Android 4.2提出的，support-fragment库可以兼容到1.6。通过<code>getChildFragmentManager()</code>能够获得子Fragment的FragmentManager，在子Fragment中可以通过<code>getParentFragment()</code>获得父Fragment。</p>\n<h2 id=\"基本使用\"><a href=\"#基本使用\" class=\"headerlink\" title=\"基本使用\"></a>基本使用</h2><p>这里给出Fragment最基本的使用方式。首先，创建继承Fragment的类，名为Fragment1：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Fragment1</span> <span class=\"keyword\">extends</span> <span class=\"title\">Fragment</span></span>&#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> String ARG_PARAM = <span class=\"string\">\"param_key\"</span>;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">private</span> String mParam;</div><div class=\"line\">    <span class=\"keyword\">private</span> Activity mActivity;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onAttach</span><span class=\"params\">(Context context)</span> </span>&#123;</div><div class=\"line\">        mActivity = (Activity) context;</div><div class=\"line\">        mParam = getArguments().getString(ARG_PARAM);  <span class=\"comment\">//获取参数</span></div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> View <span class=\"title\">onCreateView</span><span class=\"params\">(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState)</span> </span>&#123;</div><div class=\"line\">        View root = inflater.inflate(R.layout.fragment_1, container, <span class=\"keyword\">false</span>);</div><div class=\"line\">        TextView view = root.findViewById(R.id.text);</div><div class=\"line\">        view.setText(mParam);</div><div class=\"line\">        <span class=\"keyword\">return</span> root;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Fragment1 <span class=\"title\">newInstance</span><span class=\"params\">(String str)</span> </span>&#123;</div><div class=\"line\">        Fragment1 frag = <span class=\"keyword\">new</span> Fragment1();</div><div class=\"line\">        Bundle bundle = <span class=\"keyword\">new</span> Bundle();</div><div class=\"line\">        bundle.putString(ARG_PARAM, str);</div><div class=\"line\">        fragment.setArguments(bundle);   <span class=\"comment\">//设置参数</span></div><div class=\"line\">        <span class=\"keyword\">return</span> fragment;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>Fragment有很多可以复写的方法，其中最常用的就是<code>onCreateView()</code>，该方法返回Fragment的UI布局，需要注意的是<code>inflate()</code>的第三个参数是false，因为在Fragment内部实现中，会把该布局添加到container中，如果设为true，那么就会重复做两次添加，则会抛如下异常：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">Caused by: java.lang.IllegalStateException: The specified child already has a parent. You must call removeView() on the child&apos;s parent first.</div></pre></td></tr></table></figure>\n<p>如果在创建Fragment时要传入参数，必须要通过<code>setArguments(Bundle bundle)</code>方式添加，而不建议通过为Fragment添加带参数的构造函数，因为通过<code>setArguments()</code>方式添加，在由于内存紧张导致Fragment被系统杀掉并恢复（re-instantiate）时能保留这些数据。官方建议如下：</p>\n<blockquote>\n<p>It is strongly recommended that subclasses do not have other constructors with parameters, since these constructors will not be called when the fragment is re-instantiated.</p>\n</blockquote>\n<p>我们可以在Fragment的<code>onAttach()</code>中通过<code>getArguments()</code>获得传进来的参数，并在之后使用这些参数。如果要获取Activity对象，不建议调用<code>getActivity()</code>，而是在<code>onAttach()</code>中将Context对象强转为Activity对象。</p>\n<p>创建完Fragment后，接下来就是把Fragment添加到Activity中。在Activity中添加Fragment的方式有两种：</p>\n<ul>\n<li>静态添加：在xml中通过<code>&lt;fragment&gt;</code>的方式添加，缺点是一旦添加就不能在运行时删除。</li>\n<li>动态添加：运行时添加，这种方式比较灵活，因此建议使用这种方式。</li>\n</ul>\n<p>虽然Fragment能在XML中添加，但是这只是一个语法糖而已，Fragment并不是一个View，而是和Activity同一层次的。</p>\n<p>这里只给出动态添加的方式。首先Activity需要有一个容器存放Fragment，一般是FrameLayout，因此在Activity的布局文件中加入FrameLayout：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">FrameLayout</span></span></div><div class=\"line\">\t<span class=\"attr\">android:id</span>=<span class=\"string\">\"@+id/container\"</span></div><div class=\"line\">\t<span class=\"attr\">android:layout_width</span>=<span class=\"string\">\"match_parent\"</span></div><div class=\"line\">\t<span class=\"attr\">android:layout_height</span>=<span class=\"string\">\"match_parent\"</span></div><div class=\"line\">/&gt;</div></pre></td></tr></table></figure>\n<p>然后在<code>onCreate()</code>中，通过以下代码将Fragment添加进Activity中。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span> (bundle == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">\tgetSupportFragmentManager().beginTransaction()</div><div class=\"line\">        .add(R.id.container, Fragment1.newInstance(<span class=\"string\">\"hello world\"</span>), <span class=\"string\">\"f1\"</span>)</div><div class=\"line\">        <span class=\"comment\">//.addToBackStack(\"fname\")</span></div><div class=\"line\">        .commit();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这里需要注意几点：</p>\n<ul>\n<li>因为我们使用了support库的Fragment，因此需要使用<code>getSupportFragmentManager()</code>获取FragmentManager。</li>\n<li><code>add()</code>是对Fragment众多操作中的一种，还有<code>remove()</code>, <code>replace()</code>等，第一个参数是根容器的id（FrameLayout的id，即”@id/container”），第二个参数是Fragment对象，第三个参数是fragment的tag名，指定tag的好处是后续我们可以通过<code>Fragment1 frag = getSupportFragmentManager().findFragmentByTag(&quot;f1&quot;)</code>从FragmentManager中查找Fragment对象。</li>\n<li>在一次事务中，可以做多个操作，比如同时做<code>add().remove().replace()</code>。</li>\n<li><code>commit()</code>操作是异步的，内部通过<code>mManager.enqueueAction()</code>加入处理队列。对应的同步方法为<code>commitNow()</code>，<code>commit()</code>内部会有<code>checkStateLoss()</code>操作，如果开发人员使用不当（比如<code>commit()</code>操作在<code>onSaveInstanceState()</code>之后），可能会抛出异常，而<code>commitAllowingStateLoss()</code>方法则是不会抛出异常版本的<code>commit()</code>方法，但是尽量使用<code>commit()</code>，而不要使用<code>commitAllowingStateLoss()</code>。</li>\n<li><code>addToBackStack(&quot;fname&quot;)</code>是可选的。FragmentManager拥有回退栈（BackStack），类似于Activity的任务栈，如果添加了该语句，就把该事务加入回退栈，当用户点击返回按钮，会回退该事务（回退指的是如果事务是add(frag1)，那么回退操作就是remove(frag1)）；如果没添加该语句，用户点击返回按钮会直接销毁Activity。</li>\n<li>Fragment有一个常见的问题，即Fragment重叠问题，这是由于Fragment被系统杀掉，并重新初始化时再次将fragment加入activity，因此通过在外围加if语句能判断此时是否是被系统杀掉并重新初始化的情况。</li>\n</ul>\n<p>Fragment有个常见的异常：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">java.lang.IllegalStateException: Can not perform this action after onSaveInstanceState</div><div class=\"line\">    at android.support.v4.app.FragmentManagerImpl.checkStateLoss(FragmentManager.java:1341)</div><div class=\"line\">    at android.support.v4.app.FragmentManagerImpl.enqueueAction(FragmentManager.java:1352)</div><div class=\"line\">    at android.support.v4.app.BackStackRecord.commitInternal(BackStackRecord.java:595)</div><div class=\"line\">    at android.support.v4.app.BackStackRecord.commit(BackStackRecord.java:574)</div></pre></td></tr></table></figure>\n<p>该异常出现的原因是：commit()在onSaveInstanceState()后调用。首先，onSaveInstanceState()在onPause()之后，onStop()之前调用。onRestoreInstanceState()在onStart()之后，onResume()之前。</p>\n<p>因此避免出现该异常的方案有：</p>\n<ul>\n<li>不要把Fragment事务放在异步线程的回调中，比如不要把Fragment事务放在AsyncTask的onPostExecute()，因此onPostExecute()可能会在onSaveInstanceState()之后执行。</li>\n<li>逼不得已时使用commitAllowingStateLoss()。</li>\n</ul>\n<h2 id=\"生命周期\"><a href=\"#生命周期\" class=\"headerlink\" title=\"生命周期\"></a>生命周期</h2><p>Fragment的生命周期和Activity类似，但比Activity的生命周期复杂一些，基本的生命周期方法如下图：</p>\n<p><img src=\"https://raw.githubusercontent.com/xiazdong/blog-image/master/fragment-02.png\" alt=\"\"></p>\n<p>解释如下：</p>\n<ul>\n<li>onAttach()：Fragment和Activity相关联时调用。可以通过该方法获取Activity引用，还可以通过getArguments()获取参数。</li>\n<li>onCreate()：Fragment被创建时调用。</li>\n<li>onCreateView()：创建Fragment的布局。</li>\n<li>onActivityCreated()：当Activity完成onCreate()时调用。</li>\n<li>onStart()：当Fragment可见时调用。</li>\n<li>onResume()：当Fragment可见且可交互时调用。</li>\n<li>onPause()：当Fragment不可交互但可见时调用。</li>\n<li>onStop()：当Fragment不可见时调用。</li>\n<li>onDestroyView()：当Fragment的UI从视图结构中移除时调用。</li>\n<li>onDestroy()：销毁Fragment时调用。</li>\n<li>onDetach()：当Fragment和Activity解除关联时调用。</li>\n</ul>\n<p>上面的方法中，只有onCreateView()在重写时不用写super方法，其他都需要。</p>\n<p>因为Fragment是依赖Activity的，因此为了讲解Fragment的生命周期，需要和Activity的生命周期方法一起讲，即Fragment的各个生命周期方法和Activity的各个生命周期方法的关系和顺序，如图：</p>\n<p><img src=\"https://i.stack.imgur.com/fRxIQ.png\" alt=\"\"></p>\n<p>我们这里举个例子来理解Fragment生命周期方法。功能如下：共有两个Fragment：F1和F2，F1在初始化时就加入Activity，点击F1中的按钮调用replace替换为F2。</p>\n<p>当F1在Activity的onCreate()中被添加时，日志如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">BasicActivity: [onCreate] BEGIN</div><div class=\"line\">BasicActivity: [onCreate] END</div><div class=\"line\">BasicActivity: [onStart] BEGIN</div><div class=\"line\">Fragment1: [onAttach] BEGIN </div><div class=\"line\">Fragment1: [onAttach] END</div><div class=\"line\">BasicActivity: [onAttachFragment] BEGIN</div><div class=\"line\">BasicActivity: [onAttachFragment] END</div><div class=\"line\">Fragment1: [onCreate] BEGIN</div><div class=\"line\">Fragment1: [onCreate] END</div><div class=\"line\">Fragment1: [onCreateView]</div><div class=\"line\">Fragment1: [onViewCreated] BEGIN</div><div class=\"line\">Fragment1: [onViewCreated] END</div><div class=\"line\">Fragment1: [onActivityCreated] BEGIN</div><div class=\"line\">Fragment1: [onActivityCreated] END</div><div class=\"line\">Fragment1: [onStart] BEGIN</div><div class=\"line\">Fragment1: [onStart] END</div><div class=\"line\">BasicActivity: [onStart] END</div><div class=\"line\">BasicActivity: [onPostCreate] BEGIN</div><div class=\"line\">BasicActivity: [onPostCreate] END</div><div class=\"line\">BasicActivity: [onResume] BEGIN</div><div class=\"line\">BasicActivity: [onResume] END</div><div class=\"line\">BasicActivity: [onPostResume] BEGIN</div><div class=\"line\">Fragment1: [onResume] BEGIN</div><div class=\"line\">Fragment1: [onResume] END</div><div class=\"line\">BasicActivity: [onPostResume] END</div><div class=\"line\">BasicActivity: [onAttachedToWindow] BEGIN</div><div class=\"line\">BasicActivity: [onAttachedToWindow] END</div></pre></td></tr></table></figure>\n<p>可以看出：</p>\n<ul>\n<li>Fragment的onAttach()-&gt;onCreate()-&gt;onCreateView()-&gt;onActivityCreated()-&gt;onStart()都是在Activity的onStart()中调用的。</li>\n<li>Fragment的onResume()在Activity的onResume()之后调用。</li>\n</ul>\n<p>接下去分两种情况，分别是不加addToBackStack()和加addToBackStack()。</p>\n<p>1、当点击F1的按钮，调用replace()替换为F2，且不加addToBackStack()时，日志如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">Fragment2: [onAttach] BEGIN</div><div class=\"line\">Fragment2: [onAttach] END</div><div class=\"line\">BasicActivity: [onAttachFragment] BEGIN</div><div class=\"line\">BasicActivity: [onAttachFragment] END</div><div class=\"line\">Fragment2: [onCreate] BEGIN</div><div class=\"line\">Fragment2: [onCreate] END</div><div class=\"line\">Fragment1: [onPause] BEGIN</div><div class=\"line\">Fragment1: [onPause] END</div><div class=\"line\">Fragment1: [onStop] BEGIN</div><div class=\"line\">Fragment1: [onStop] END</div><div class=\"line\">Fragment1: [onDestroyView] BEGIN</div><div class=\"line\">Fragment1: [onDestroyView] END</div><div class=\"line\">Fragment1: [onDestroy] BEGIN</div><div class=\"line\">Fragment1: [onDestroy] END</div><div class=\"line\">Fragment1: [onDetach] BEGIN</div><div class=\"line\">Fragment1: [onDetach] END</div><div class=\"line\">Fragment2: [onCreateView]</div><div class=\"line\">Fragment2: [onViewCreated] BEGIN</div><div class=\"line\">Fragment2: [onViewCreated] END</div><div class=\"line\">Fragment2: [onActivityCreated] BEGIN</div><div class=\"line\">Fragment2: [onActivityCreated] END</div><div class=\"line\">Fragment2: [onStart] BEGIN</div><div class=\"line\">Fragment2: [onStart] END</div><div class=\"line\">Fragment2: [onResume] BEGIN</div><div class=\"line\">Fragment2: [onResume] END</div></pre></td></tr></table></figure>\n<p>可以看到，F1最后调用了onDestroy()和onDetach()。</p>\n<p>2、当点击F1的按钮，调用replace()替换为F2，且加addToBackStack()时，日志如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">Fragment2: [onAttach] BEGIN</div><div class=\"line\">Fragment2: [onAttach] END</div><div class=\"line\">BasicActivity: [onAttachFragment] BEGIN</div><div class=\"line\">BasicActivity: [onAttachFragment] END</div><div class=\"line\">Fragment2: [onCreate] BEGIN</div><div class=\"line\">Fragment2: [onCreate] END</div><div class=\"line\">Fragment1: [onPause] BEGIN</div><div class=\"line\">Fragment1: [onPause] END</div><div class=\"line\">Fragment1: [onStop] BEGIN</div><div class=\"line\">Fragment1: [onStop] END</div><div class=\"line\">Fragment1: [onDestroyView] BEGIN</div><div class=\"line\">Fragment1: [onDestroyView] END</div><div class=\"line\">Fragment2: [onCreateView]</div><div class=\"line\">Fragment2: [onViewCreated] BEGIN</div><div class=\"line\">Fragment2: [onViewCreated] END</div><div class=\"line\">Fragment2: [onActivityCreated] BEGIN</div><div class=\"line\">Fragment2: [onActivityCreated] END</div><div class=\"line\">Fragment2: [onStart] BEGIN</div><div class=\"line\">Fragment2: [onStart] END</div><div class=\"line\">Fragment2: [onResume] BEGIN</div><div class=\"line\">Fragment2: [onResume] END</div></pre></td></tr></table></figure>\n<p>可以看到，F1被替换时，最后只调到了onDestroyView()，并没有调用onDestroy()和onDetach()。当用户点返回按钮回退事务时，F1会调onCreateView()-&gt;onStart()-&gt;onResume()，因此在Fragment事务中加不加addToBackStack()会影响Fragment的生命周期。</p>\n<p>FragmentTransaction有一些基本方法，下面给出调用这些方法时，Fragment生命周期的变化：</p>\n<ul>\n<li>add(): onAttach()-&gt;…-&gt;onResume()。</li>\n<li>remove(): onPause()-&gt;…-&gt;onDetach()。</li>\n<li>replace(): 相当于旧Fragment调用remove()，新Fragment调用add()。</li>\n<li>show(): 不调用任何生命周期方法，调用该方法的前提是要显示的Fragment已经被添加到容器，只是纯粹把Fragment UI的setVisibility为true。</li>\n<li>hide(): 不调用任何生命周期方法，调用该方法的前提是要显示的Fragment已经被添加到容器，只是纯粹把Fragment UI的setVisibility为false。</li>\n<li>detach(): onPause()-&gt;onStop()-&gt;onDestroyView()。UI从布局中移除，但是仍然被FragmentManager管理。</li>\n<li>attach(): onCreateView()-&gt;onStart()-&gt;onResume()。</li>\n</ul>\n<h2 id=\"Fragment实现原理和Back-Stack\"><a href=\"#Fragment实现原理和Back-Stack\" class=\"headerlink\" title=\"Fragment实现原理和Back Stack\"></a>Fragment实现原理和Back Stack</h2><p>我们知道Activity有任务栈，用户通过startActivity将Activity加入栈，点击返回按钮将Activity出栈。Fragment也有类似的栈，称为回退栈（Back Stack），回退栈是由FragmentManager管理的。默认情况下，Fragment事务是不会加入回退栈的，如果想将Fragment事务加入回退栈，则可以加入<code>addToBackStack(&quot;&quot;)</code>。如果没有加入回退栈，则用户点击返回按钮会直接将Activity出栈；如果加入了回退栈，则用户点击返回按钮会回滚Fragment事务。</p>\n<p>我们将通过最常见的Fragment用法，讲解Back Stack的实现原理：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">getSupportFragmentManager().beginTransaction()</div><div class=\"line\">    .add(R.id.container, f1, <span class=\"string\">\"f1\"</span>)</div><div class=\"line\">    .addToBackStack(<span class=\"string\">\"\"</span>)</div><div class=\"line\">    .commit();</div></pre></td></tr></table></figure>\n<p>上面这个代码的功能就是将Fragment加入Activity中，内部实现为：创建一个BackStackRecord对象，该对象记录了这个事务的全部操作轨迹（这里只做了一次add操作，并且加入回退栈），随后将该对象提交到FragmentManager的执行队列中，等待执行。</p>\n<p>BackStackRecord类的定义如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BackStackRecord</span> <span class=\"keyword\">extends</span> <span class=\"title\">FragmentTransaction</span> <span class=\"keyword\">implements</span> <span class=\"title\">FragmentManager</span>.<span class=\"title\">BackStackEntry</span>, <span class=\"title\">Runnable</span> </span>&#123;&#125;</div></pre></td></tr></table></figure>\n<p>从定义可以看出，BackStackRecord有三重含义：</p>\n<ul>\n<li>继承了FragmentTransaction，即是事务，保存了整个事务的全部操作轨迹。</li>\n<li>实现了BackStackEntry，作为回退栈的元素，正是因为该类拥有事务全部的操作轨迹，因此在popBackStack()时能回退整个事务。</li>\n<li>继承了Runnable，即被放入FragmentManager执行队列，等待被执行。</li>\n</ul>\n<p>先看第一层含义，<code>getSupportFragmentManager.beginTransaction()</code>返回的就是BackStackRecord对象，代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> FragmentTransaction <span class=\"title\">beginTransaction</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> BackStackRecord(<span class=\"keyword\">this</span>);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>BackStackRecord类包含了一次事务的整个操作轨迹，是以链表形式存在的，链表的元素是Op类，表示其中某个操作，定义如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Op</span> </span>&#123;</div><div class=\"line\">    Op next; <span class=\"comment\">//链表后一个节点</span></div><div class=\"line\">    Op prev; <span class=\"comment\">//链表前一个节点</span></div><div class=\"line\">    <span class=\"keyword\">int</span> cmd;  <span class=\"comment\">//操作是add或remove或replace或hide或show等</span></div><div class=\"line\">    Fragment fragment; <span class=\"comment\">//对哪个Fragment对象做操作</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>我们来看下具体场景下这些类是怎么被使用的，比如我们的事务做add操作。add函数的定义：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> FragmentTransaction <span class=\"title\">add</span><span class=\"params\">(<span class=\"keyword\">int</span> containerViewId, Fragment fragment, String tag)</span> </span>&#123;</div><div class=\"line\">    doAddOp(containerViewId, fragment, tag, OP_ADD);</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>doAddOp()方法就是创建Op对象，并加入链表，定义如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">doAddOp</span><span class=\"params\">(<span class=\"keyword\">int</span> containerViewId, Fragment fragment, String tag, <span class=\"keyword\">int</span> opcmd)</span> </span>&#123;</div><div class=\"line\">    fragment.mTag = tag;  <span class=\"comment\">//设置fragment的tag</span></div><div class=\"line\">    fragment.mContainerId = fragment.mFragmentId = containerViewId;  <span class=\"comment\">//设置fragment的容器id</span></div><div class=\"line\">    Op op = <span class=\"keyword\">new</span> Op();</div><div class=\"line\">    op.cmd = opcmd;</div><div class=\"line\">    op.fragment = fragment;</div><div class=\"line\">    addOp(op);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>addOp()是将创建好的Op对象加入链表，定义如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">addOp</span><span class=\"params\">(Op op)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (mHead == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">        mHead = mTail = op;</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">        op.prev = mTail;</div><div class=\"line\">        mTail.next = op;</div><div class=\"line\">        mTail = op;</div><div class=\"line\">    &#125;</div><div class=\"line\">    mNumOp++;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>addToBackStack(“”)是将mAddToBackStack变量记为true，在commit()中会用到该变量。<code>commit()</code>是异步的，即不是立即生效的，但是后面会看到整个过程还是在主线程完成，只是把事务的执行扔给主线程的Handler，commit()内部是<code>commitInternal()</code>，实现如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">commitInternal</span><span class=\"params\">(<span class=\"keyword\">boolean</span> allowStateLoss)</span> </span>&#123;</div><div class=\"line\">    mCommitted = <span class=\"keyword\">true</span>;</div><div class=\"line\">    <span class=\"keyword\">if</span> (mAddToBackStack) &#123;</div><div class=\"line\">        mIndex = mManager.allocBackStackIndex(<span class=\"keyword\">this</span>);</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">        mIndex = -<span class=\"number\">1</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    mManager.enqueueAction(<span class=\"keyword\">this</span>, allowStateLoss); <span class=\"comment\">//将事务添加进待执行队列中</span></div><div class=\"line\">    <span class=\"keyword\">return</span> mIndex;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>如果mAddToBackStack为true，则调用<code>allocBackStackIndex(this)</code>将事务添加进回退栈，FragmentManager类的变量<code>ArrayList&lt;BackStackRecord&gt; mBackStackIndices;</code>就是回退栈。实现如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">allocBackStackIndex</span><span class=\"params\">(BackStackRecord bse)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (mBackStackIndices == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">        mBackStackIndices = <span class=\"keyword\">new</span> ArrayList&lt;BackStackRecord&gt;();</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">int</span> index = mBackStackIndices.size();</div><div class=\"line\">    mBackStackIndices.add(bse);</div><div class=\"line\">    <span class=\"keyword\">return</span> index;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>在<code>commitInternal()</code>中，<code>mManager.enqueueAction(this, allowStateLoss);</code>是将BackStackRecord加入待执行队列中，定义如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">enqueueAction</span><span class=\"params\">(Runnable action, <span class=\"keyword\">boolean</span> allowStateLoss)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (mPendingActions == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">        mPendingActions = <span class=\"keyword\">new</span> ArrayList&lt;Runnable&gt;();</div><div class=\"line\">    &#125;</div><div class=\"line\">    mPendingActions.add(action);</div><div class=\"line\">    <span class=\"keyword\">if</span> (mPendingActions.size() == <span class=\"number\">1</span>) &#123;</div><div class=\"line\">        mHost.getHandler().removeCallbacks(mExecCommit);</div><div class=\"line\">        mHost.getHandler().post(mExecCommit); <span class=\"comment\">//调用execPendingActions()执行待执行队列的事务</span></div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>mPendingActions就是前面说的待执行队列，<code>mHost.getHandler()</code>就是主线程的Handler，因此Runnable是在主线程执行的，mExecCommit的内部就是调用了<code>execPendingActions()</code>，即把mPendingActions中所有积压的没被执行的事务全部执行。执行队列中的事务会怎样被执行呢？就是调用BackStackRecord的<code>run()</code>方法，<code>run()</code>方法就是执行Fragment的生命周期函数，还有将视图添加进container中。</p>\n<p>与<code>addToBackStack()</code>对应的是<code>popBackStack()</code>，有以下几种变种：</p>\n<ul>\n<li>popBackStack()：将回退栈的栈顶弹出，并回退该事务。</li>\n<li>popBackStack(String name, int flag)：name为addToBackStack(String name)的参数，通过name能找到回退栈的特定元素，flag可以为0或者FragmentManager.POP_BACK_STACK_INCLUSIVE，0表示只弹出该元素以上的所有元素，POP_BACK_STACK_INCLUSIVE表示弹出包含该元素及以上的所有元素。这里说的弹出所有元素包含回退这些事务。</li>\n<li>popBackStack()是异步执行的，是丢到主线程的MessageQueue执行，popBackStackImmediate()是同步版本。</li>\n</ul>\n<p>我们通过讲解Demo1来更清晰地了解回退栈的使用。功能如下：共有三个Fragment：F1, F2, F3，F1在初始化时就加入Activity，点击F1中的按钮跳转到F2，点击F2的按钮跳转到F3，点击F3的按钮回退到F1。</p>\n<p>在Activity的onCreate()中，将F1加入Activity中：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">getSupportFragmentManager().beginTransaction()</div><div class=\"line\">    .add(R.id.container, f1, <span class=\"string\">\"f1\"</span>)</div><div class=\"line\">    .addToBackStack(Fragment1.class.getSimpleName())</div><div class=\"line\">    .commit();</div></pre></td></tr></table></figure>\n<p>F1按钮的onClick()内容如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">getFragmentManager().beginTransaction()</div><div class=\"line\">    .replace(R.id.container, f2, <span class=\"string\">\"f2\"</span>)</div><div class=\"line\">    .addToBackStack(Fragment2.class.getSimpleName())</div><div class=\"line\">    .commit();</div></pre></td></tr></table></figure>\n<p>F2按钮的onClick()如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">getFragmentManager().beginTransaction()</div><div class=\"line\">    .replace(R.id.container, f3, <span class=\"string\">\"f3\"</span>)</div><div class=\"line\">    .addToBackStack(Fragment3.class.getSimpleName())</div><div class=\"line\">    .commit();</div></pre></td></tr></table></figure>\n<p>F3按钮的onClick()如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">getFragmentManager().popBackStack(Fragment2.class.getSimpleName(), FragmentManager.POP_BACK_STACK_INCLUSIVE);</div></pre></td></tr></table></figure>\n<p>这样就完成了整个界面的跳转逻辑。</p>\n<p>这里补充一个点，getSupportFragmentManager().findFragmentByTag()是经常用到的方法，他是FragmentManager的方法，FragmentManager是抽象类，FragmentManagerImpl是继承FragmentManager的实现类，他的内部实现是：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FragmentManagerImpl</span> <span class=\"keyword\">extends</span> <span class=\"title\">FragmentManager</span> </span>&#123;</div><div class=\"line\">    ArrayList&lt;Fragment&gt; mActive;</div><div class=\"line\">    ArrayList&lt;Fragment&gt; mAdded;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Fragment <span class=\"title\">findFragmentByTag</span><span class=\"params\">(String tag)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (mAdded != <span class=\"keyword\">null</span> &amp;&amp; tag != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=mAdded.size()-<span class=\"number\">1</span>; i&gt;=<span class=\"number\">0</span>; i--) &#123;</div><div class=\"line\">                Fragment f = mAdded.get(i);</div><div class=\"line\">                <span class=\"keyword\">if</span> (f != <span class=\"keyword\">null</span> &amp;&amp; tag.equals(f.mTag)) &#123;</div><div class=\"line\">                    <span class=\"keyword\">return</span> f;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">if</span> (mActive != <span class=\"keyword\">null</span> &amp;&amp; tag != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=mActive.size()-<span class=\"number\">1</span>; i&gt;=<span class=\"number\">0</span>; i--) &#123;</div><div class=\"line\">                Fragment f = mActive.get(i);</div><div class=\"line\">                <span class=\"keyword\">if</span> (f != <span class=\"keyword\">null</span> &amp;&amp; tag.equals(f.mTag)) &#123;</div><div class=\"line\">                    <span class=\"keyword\">return</span> f;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>从上面看到，先从mAdded中查找是否有该Fragment，如果没找到，再从mActive中查找是否有该Fragment。mAdded是已经添加到Activity的Fragment的集合，mActive不仅包含mAdded，还包含虽然不在Activity中，但还在回退栈中的Fragment。</p>\n<h2 id=\"Fragment通信\"><a href=\"#Fragment通信\" class=\"headerlink\" title=\"Fragment通信\"></a>Fragment通信</h2><h3 id=\"Fragment向Activity传递数据\"><a href=\"#Fragment向Activity传递数据\" class=\"headerlink\" title=\"Fragment向Activity传递数据\"></a>Fragment向Activity传递数据</h3><p>首先，在Fragment中定义接口，并让Activity实现该接口（具体实现省略）：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">OnFragmentInteractionListener</span> </span>&#123;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">onItemClick</span><span class=\"params\">(String str)</span></span>;  <span class=\"comment\">//将str从Fragment传递给Activity</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>在Fragment的onAttach()中，将参数Context强转为OnFragmentInteractionListener对象：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onAttach</span><span class=\"params\">(Context context)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">super</span>.onAttach(context);</div><div class=\"line\">    <span class=\"keyword\">if</span> (context <span class=\"keyword\">instanceof</span> OnFragmentInteractionListener) &#123;</div><div class=\"line\">        mListener = (OnFragmentInteractionListener) context;</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(context.toString()</div><div class=\"line\">                + <span class=\"string\">\" must implement OnFragmentInteractionListener\"</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>并在Fragment合适的地方调用<code>mListener.onItemClick(&quot;hello&quot;)</code>将”hello”从Fragment传递给Activity。</p>\n<h3 id=\"FABridge\"><a href=\"#FABridge\" class=\"headerlink\" title=\"FABridge\"></a>FABridge</h3><p>由于通过接口的方式从Fragment向Activity进行数据传递比较麻烦，需要在Fragment中定义interface，并让Activity实现该interface，<a href=\"https://github.com/hongyangAndroid/FABridge\" target=\"_blank\" rel=\"external\">FABridge</a>通过注解的形式免去了这些定义。</p>\n<p>在build.gradle中添加依赖：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">annotationProcessor <span class=\"string\">'com.zhy.fabridge:fabridge-compiler:1.0.0'</span></div><div class=\"line\">compile <span class=\"string\">'com.zhy.fabridge:fabridge-api:1.0.0'</span></div></pre></td></tr></table></figure>\n<p>首先定义方法ID，这里为FAB_ITEM_CLICK，接着在Activity中定义接口：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@FCallbackId</span>(id = FAB_ITEM_CLICK)</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onItemClick</span><span class=\"params\">(String str)</span> </span>&#123;  <span class=\"comment\">//方法名任意</span></div><div class=\"line\">    Toast.makeText(<span class=\"keyword\">this</span>, str, Toast.LENGTH_SHORT).show();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>最后，在Fragment中，通过以下形式调用”ID=FAB_ITEM_CLICK”的方法（该方法可能在Activity中，也可能在任何类中）：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">Fabridge.call(mActivity,FAB_ITEM_CLICK,<span class=\"string\">\"data\"</span>);  <span class=\"comment\">//调用ID对应的方法，\"data\"为参数值</span></div></pre></td></tr></table></figure>\n<h3 id=\"Activity向Fragment传递数据\"><a href=\"#Activity向Fragment传递数据\" class=\"headerlink\" title=\"Activity向Fragment传递数据\"></a>Activity向Fragment传递数据</h3><p>Activity向Fragment传递数据比较简单，获取Fragment对象，并调用Fragment的方法即可，比如要将一个字符串传递给Fragment，则在Fragment中定义方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setString</span><span class=\"params\">(String str)</span> </span>&#123;</div><div class=\"line\">     <span class=\"keyword\">this</span>.str = str;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>并在Activity中调用<code>fragment.setString(&quot;hello&quot;)</code>即可。</p>\n<h3 id=\"Fragment之间通信\"><a href=\"#Fragment之间通信\" class=\"headerlink\" title=\"Fragment之间通信\"></a>Fragment之间通信</h3><p>由于Fragment之间是没有任何依赖关系的，因此如果要进行Fragment之间的通信，建议通过Activity作为中介，不要Fragment之间直接通信。</p>\n<h2 id=\"DialogFragment\"><a href=\"#DialogFragment\" class=\"headerlink\" title=\"DialogFragment\"></a>DialogFragment</h2><p>DialogFragment是Android 3.0提出的，代替了Dialog，用于实现对话框。他的优点是：即使旋转屏幕，也能保留对话框状态。</p>\n<p>如果要自定义对话框样式，只需要继承DialogFragment，并重写onCreateView()，该方法返回对话框UI。这里我们举个例子，实现进度条样式的圆角对话框。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ProgressDialogFragment</span> <span class=\"keyword\">extends</span> <span class=\"title\">DialogFragment</span> </span>&#123;</div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> View <span class=\"title\">onCreateView</span><span class=\"params\">(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState)</span> </span>&#123;</div><div class=\"line\">        getDialog().requestWindowFeature(Window.FEATURE_NO_TITLE); <span class=\"comment\">//消除Title区域</span></div><div class=\"line\">        getDialog().getWindow().setBackgroundDrawable(<span class=\"keyword\">new</span> ColorDrawable(Color.TRANSPARENT));  <span class=\"comment\">//将背景变为透明</span></div><div class=\"line\">        setCancelable(<span class=\"keyword\">false</span>);  <span class=\"comment\">//点击外部不可取消</span></div><div class=\"line\">        View root = inflater.inflate(R.layout.fragment_progress_dialog, container);</div><div class=\"line\">        <span class=\"keyword\">return</span> root;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> ProgressDialogFragment <span class=\"title\">newInstance</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ProgressDialogFragment();</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>进度条动画我们使用<a href=\"https://github.com/airbnb/lottie-android\" target=\"_blank\" rel=\"external\">Lottie</a>实现，Lottie动画从<a href=\"https://www.lottiefiles.com/\" target=\"_blank\" rel=\"external\">这里</a>找到。使用非常方便，只需要下载JSON动画文件，然后在XML中写入：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">com.airbnb.lottie.LottieAnimationView</span></span></div><div class=\"line\">    <span class=\"attr\">android:layout_width</span>=<span class=\"string\">\"wrap_content\"</span>  //大小根据<span class=\"attr\">JSON</span>文件确定</div><div class=\"line\">    <span class=\"attr\">android:layout_height</span>=<span class=\"string\">\"wrap_content\"</span></div><div class=\"line\">    <span class=\"attr\">app:lottie_fileName</span>=<span class=\"string\">\"loader_ring.json\"</span>   //<span class=\"attr\">JSON</span>文件</div><div class=\"line\">    <span class=\"attr\">app:lottie_loop</span>=<span class=\"string\">\"true\"</span>    //循环播放</div><div class=\"line\">    <span class=\"attr\">app:lottie_autoPlay</span>=<span class=\"string\">\"true\"</span> /&gt;  //自动播放</div></pre></td></tr></table></figure>\n<p>然后通过下面代码显示对话框：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">ProgressDialogFragment fragment = ProgressDialogFragment.newInstance();</div><div class=\"line\">fragment.show(getSupportFragmentManager(), <span class=\"string\">\"tag\"</span>);</div><div class=\"line\"><span class=\"comment\">//fragment.dismiss();</span></div></pre></td></tr></table></figure>\n<p>为了实现圆角，除了在onCreateView()中把背景设为透明，还需要对UI加入背景：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">shape</span> <span class=\"attr\">xmlns:android</span>=<span class=\"string\">\"http://schemas.android.com/apk/res/android\"</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">solid</span> <span class=\"attr\">android:color</span>=<span class=\"string\">\"#ffffff\"</span>/&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">corners</span></span></div><div class=\"line\">        <span class=\"attr\">android:radius</span>=<span class=\"string\">\"20dp\"</span>/&gt;</div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">shape</span>&gt;</span></div></pre></td></tr></table></figure>\n<h2 id=\"ViewPager-Fragment相关\"><a href=\"#ViewPager-Fragment相关\" class=\"headerlink\" title=\"ViewPager+Fragment相关\"></a>ViewPager+Fragment相关</h2><h3 id=\"基本使用-1\"><a href=\"#基本使用-1\" class=\"headerlink\" title=\"基本使用\"></a>基本使用</h3><p>ViewPager是support v4库中提供界面滑动的类，继承自ViewGroup。PagerAdapter是ViewPager的适配器类，为ViewPager提供界面。但是一般来说，通常都会使用PagerAdapter的两个子类：FragmentPagerAdapter和FragmentStatePagerAdapter作为ViewPager的适配器，他们的特点是界面是Fragment。</p>\n<blockquote>\n<p>在support v13和support v4中都提供了FragmentPagerAdapter和FragmentStatePagerAdapter，区别在于：support v13中使用android.app.Fragment，而support v4使用android.support.v4.app.Fragment。一般都使用support v4中的FragmentPagerAdapter和FragmentStatePagerAdapter。</p>\n</blockquote>\n<p>默认，ViewPager会缓存当前页相邻的界面，比如当滑动到第2页时，会初始化第1页和第3页的界面（即Fragment对象，且生命周期函数运行到onResume()），可以通过setOffscreenPageLimit(count)设置离线缓存的界面个数。</p>\n<p>FragmentPagerAdapter和FragmentStatePagerAdapter需要重写的方法都一样，常见的重写方法如下：</p>\n<ul>\n<li><code>public FragmentPagerAdapter(FragmentManager fm)</code>: 构造函数，参数为FragmentManager。如果是嵌套Fragment场景，子PagerAdapter的参数传入getChildFragmentManager()。</li>\n<li><code>Fragment getItem(int position)</code>: 返回第position位置的Fragment，<strong>必须重写</strong>。</li>\n<li><code>int getCount()</code>: 返回ViewPager的页数，<strong>必须重写</strong>。</li>\n<li><code>Object instantiateItem(ViewGroup container, int position)</code>: container是ViewPager对象，返回第position位置的Fragment。</li>\n<li><code>void destroyItem(ViewGroup container, int position, Object object)</code>: container是ViewPager对象，object是Fragment对象。</li>\n<li><code>getItemPosition(Object object)</code>: object是Fragment对象，如果返回POSITION_UNCHANGED，则表示当前Fragment不刷新，如果返回POSITION_NONE，则表示当前Fragment需要调用<code>destroyItem()</code>和<code>instantiateItem()</code>进行销毁和重建。 默认情况下返回POSITION_UNCHANGED。</li>\n</ul>\n<h3 id=\"懒加载\"><a href=\"#懒加载\" class=\"headerlink\" title=\"懒加载\"></a>懒加载</h3><p>懒加载主要用于ViewPager且每页是Fragment的情况，场景为微信主界面，底部有4个tab，当滑到另一个tab时，先显示”正在加载”，过一会才会显示正常界面。</p>\n<p>默认情况，ViewPager会缓存当前页和左右相邻的界面。实现懒加载的主要原因是：用户没进入的界面需要有一系列的网络、数据库等耗资源、耗时的操作，预先做这些数据加载是不必要的。</p>\n<p>这里懒加载的实现思路是：用户不可见的界面，只初始化UI，但是不会做任何数据加载。等滑到该页，才会异步做数据加载并更新UI。</p>\n<p>这里就实现类似微信那种效果，整个UI布局为：底部用<a href=\"https://github.com/tyzlmjj/PagerBottomTabStrip\" target=\"_blank\" rel=\"external\">PagerBottomTabStrip</a>项目实现，上面是ViewPager，使用FragmentPagerAdapter。逻辑为：当用户滑到另一个界面，首先会显示正在加载，等数据加载完毕后（这里用睡眠1秒钟代替）显示正常界面。</p>\n<p>ViewPager默认缓存左右相邻界面，为了避免不必要的重新数据加载（重复调用<code>onCreateView()</code>），因为有4个tab，因此将离线缓存的半径设置为3，即<code>setOffscreenPageLimit(3)</code>。</p>\n<p>懒加载主要依赖Fragment的<code>setUserVisibleHint(boolean isVisible)</code>方法，当Fragment变为可见时，会调用<code>setUserVisibleHint(true)</code>；当Fragment变为不可见时，会调用<code>setUserVisibleHint(false)</code>，且该方法调用时机：</p>\n<ul>\n<li><code>onAttach()</code>之前，调用<code>setUserVisibleHint(false)</code>。</li>\n<li><code>onCreateView()</code>之前，如果该界面为当前页，则调用<code>setUserVisibleHint(true)</code>，否则调用<code>setUserVisibleHint(false)</code>。</li>\n<li>界面变为可见时，调用<code>setUserVisibleHint(true)</code>。</li>\n<li>界面变为不可见时，调用<code>setUserVisibleHint(false)</code>。</li>\n</ul>\n<p>懒加载Fragment的实现：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LazyFragment</span> <span class=\"keyword\">extends</span> <span class=\"title\">Fragment</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">private</span> View mRootView;</div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> mIsInited;</div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> mIsPrepared;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> View <span class=\"title\">onCreateView</span><span class=\"params\">(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState)</span> </span>&#123;</div><div class=\"line\">        mRootView = inflater.inflate(R.layout.fragment_lazy, container, <span class=\"keyword\">false</span>);</div><div class=\"line\">        mIsPrepared = <span class=\"keyword\">true</span>;</div><div class=\"line\">        lazyLoad();</div><div class=\"line\">        <span class=\"keyword\">return</span> mRootView;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">lazyLoad</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (getUserVisibleHint() &amp;&amp; mIsPrepared &amp;&amp; !mIsInited) &#123;</div><div class=\"line\">            <span class=\"comment\">//异步初始化，在初始化后显示正常UI</span></div><div class=\"line\">            loadData();</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">loadData</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">new</span> Thread() &#123;</div><div class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">                <span class=\"comment\">//1. 加载数据</span></div><div class=\"line\">                <span class=\"comment\">//2. 更新UI</span></div><div class=\"line\">                <span class=\"comment\">//3. mIsInited = true</span></div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;.start();</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setUserVisibleHint</span><span class=\"params\">(<span class=\"keyword\">boolean</span> isVisibleToUser)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">super</span>.setUserVisibleHint(isVisibleToUser);</div><div class=\"line\">        <span class=\"keyword\">if</span> (isVisibleToUser) &#123;</div><div class=\"line\">            lazyLoad();</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> LazyFragment <span class=\"title\">newInstance</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> LazyFragment();</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>注意点：</p>\n<ul>\n<li>在Fragment中有两个变量控制是否需要做数据加载：<ul>\n<li>mIsPrepared：表示UI是否准备好，因为数据加载后需要更新UI，如果UI还没有inflate，就不需要做数据加载，因为<code>setUserVisibleHint()</code>会在<code>onCreateView()</code>之前调用一次，如果此时调用，UI还没有inflate，因此不能加载数据。</li>\n<li>mIsInited：表示是否已经做过数据加载，如果做过了就不需要做了。因为<code>setUserVisibleHint(true)</code>在界面可见时都会调用，如果滑到该界面做过数据加载后，滑走，再滑回来，还是会调用<code>setUserVisibleHint(true)</code>，此时由于mIsInited=true，因此不会再做一遍数据加载。</li>\n</ul>\n</li>\n<li>lazyLoad()：懒加载的核心类，在该方法中，只有界面可见（getUserVisibleHint()==true）、UI准备好（mIsPrepared==true）、过去没做过数据加载（mIsInited==false）时，才需要调<code>loadData()</code>做数据加载，数据加载做完后把mIsInited置为true。</li>\n</ul>\n<p>布局XML主要分两个container，一个是初始显示的状态，即R.id.container_empty，当数据加载完成，就显示R.id.container：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">FrameLayout</span> <span class=\"attr\">xmlns:android</span>=<span class=\"string\">\"http://schemas.android.com/apk/res/android\"</span></span></div><div class=\"line\">    <span class=\"attr\">android:orientation</span>=<span class=\"string\">\"vertical\"</span> <span class=\"attr\">android:layout_width</span>=<span class=\"string\">\"match_parent\"</span></div><div class=\"line\">    <span class=\"attr\">android:layout_height</span>=<span class=\"string\">\"match_parent\"</span>&gt;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">RelativeLayout</span></span></div><div class=\"line\">        <span class=\"attr\">android:id</span>=<span class=\"string\">\"@+id/container_empty\"</span></div><div class=\"line\">        <span class=\"attr\">android:layout_width</span>=<span class=\"string\">\"match_parent\"</span></div><div class=\"line\">        <span class=\"attr\">android:layout_height</span>=<span class=\"string\">\"match_parent\"</span>&gt;</div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">TextView</span></span></div><div class=\"line\">            <span class=\"attr\">android:layout_width</span>=<span class=\"string\">\"wrap_content\"</span></div><div class=\"line\">            <span class=\"attr\">android:layout_height</span>=<span class=\"string\">\"wrap_content\"</span></div><div class=\"line\">            <span class=\"attr\">android:layout_centerInParent</span>=<span class=\"string\">\"true\"</span></div><div class=\"line\">            <span class=\"attr\">android:text</span>=<span class=\"string\">\"正在加载\"</span></div><div class=\"line\">            /&gt;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">RelativeLayout</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">RelativeLayout</span></span></div><div class=\"line\">        <span class=\"attr\">android:id</span>=<span class=\"string\">\"@+id/container\"</span></div><div class=\"line\">        <span class=\"attr\">android:layout_width</span>=<span class=\"string\">\"match_parent\"</span></div><div class=\"line\">        <span class=\"attr\">android:layout_height</span>=<span class=\"string\">\"match_parent\"</span></div><div class=\"line\">        <span class=\"attr\">android:visibility</span>=<span class=\"string\">\"gone\"</span></div><div class=\"line\">        &gt;</div><div class=\"line\">        ...</div><div class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">RelativeLayout</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">FrameLayout</span>&gt;</span></div></pre></td></tr></table></figure>\n<h2 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h2><ul>\n<li><a href=\"https://www.raywenderlich.com/149112/android-fragments-tutorial-introduction\" target=\"_blank\" rel=\"external\">入门</a></li>\n<li><a href=\"http://assets.en.oreilly.com/1/event/68/Fragments%20for%20All%20Presentation.pdf\" target=\"_blank\" rel=\"external\">教程1</a></li>\n<li><a href=\"http://vinsol.com/blog/2014/09/15/advocating-fragment-oriented-applications-in-android/\" target=\"_blank\" rel=\"external\">教程2</a></li>\n<li><a href=\"https://github.com/xxv/android-lifecycle\" target=\"_blank\" rel=\"external\">生命周期</a></li>\n<li><a href=\"https://stackoverflow.com/questions/9156406/whats-the-difference-between-detaching-a-fragment-and-removing-it\" target=\"_blank\" rel=\"external\">detach vs remove</a></li>\n<li>Google I/O 2016: <a href=\"https://www.youtube.com/watch?v=k3IT-IJ0J98\" target=\"_blank\" rel=\"external\">What the Fragment?</a></li>\n<li>Google I/O 2017: <a href=\"https://www.youtube.com/watch?v=eUG3VWnXFtg\" target=\"_blank\" rel=\"external\">Fragment Tricks</a></li>\n<li><a href=\"https://stackoverflow.com/questions/25695960/difference-between-madded-mactive-in-source-code-of-support-fragmentmanager\" target=\"_blank\" rel=\"external\">mAdded和mActive的区别</a></li>\n<li><a href=\"http://www.androiddesignpatterns.com/2013/08/fragment-transaction-commit-state-loss.html\" target=\"_blank\" rel=\"external\">如何避免IllegalStateException异常</a></li>\n</ul>\n","categories":[],"tags":["Android"]},{"title":"Timber和Bugly使用入门","url":"http://xiazdong.github.io/2017/05/17/Timber/","content":"<p>在Android开发中，打日志、crash上报、统计DAU等功能是很常见的。使用系统提供的Log类打日志很方便，但是他有一些不方便：</p>\n<ul>\n<li>每次需要加TAG。</li>\n<li>不会打印当前线程。</li>\n<li>不会打印当前行号。</li>\n</ul>\n<p>而<a href=\"https://github.com/JakeWharton/timber\" target=\"_blank\" rel=\"external\">Timber</a>很简单的解决了这些问题。</p>\n<p><a href=\"https://bugly.qq.com\" target=\"_blank\" rel=\"external\">Bugly</a>是腾讯的一款crash上报和运营统计的平台。APP的crash上报和统计DAU等功能可以通过该平台实现，集成很简单，见<a href=\"https://bugly.qq.com/docs/user-guide/instruction-manual-android/?v=20170517185032\" target=\"_blank\" rel=\"external\">Bugly Android SDK 使用指南</a>。</p>\n<p>Timber的配置方法：build.gradle中加入 <code>compile &#39;com.jakewharton.timber:timber:4.5.1&#39;</code>。</p>\n<p>Timber提供了DebugTree，只需要在Application的onCreate()中调用<code>Timber.plant(new DebugTree())</code>初始化Timber。但是DebugTree的功能还有所欠缺，比如：</p>\n<ul>\n<li>不会打印当前线程。</li>\n<li>不会打印当前行号。</li>\n</ul>\n<p>因此需要新建一个继承Timber.DebugTree的类：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ThreadAwareDebugTree</span> <span class=\"keyword\">extends</span> <span class=\"title\">Timber</span>.<span class=\"title\">DebugTree</span> </span>&#123;</div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">log</span><span class=\"params\">(<span class=\"keyword\">int</span> priority, String tag, String message, Throwable t)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (tag != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">            String threadName = Thread.currentThread().getName();</div><div class=\"line\">            tag = <span class=\"string\">\"&lt;\"</span> + threadName + <span class=\"string\">\"&gt; \"</span> + tag;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">super</span>.log(priority, tag, message, t);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> String <span class=\"title\">createStackElementTag</span><span class=\"params\">(StackTraceElement element)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">super</span>.createStackElementTag(element) + <span class=\"string\">\"(Line \"</span> + element.getLineNumber() + <span class=\"string\">\")\"</span>;  <span class=\"comment\">//日志显示行号</span></div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这只是debug版本的Tree，我们还需要创建release版本的Tree，叫ReleaseTree，不显示v,d,i，只显示w,e,wtf。这些日志都会以”跟踪日志”的形式上报给Bugly，实现如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ReleaseTree</span> <span class=\"keyword\">extends</span> <span class=\"title\">ThreadAwareDebugTree</span> </span>&#123;</div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isLoggable</span><span class=\"params\">(String tag, <span class=\"keyword\">int</span> priority)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (priority == Log.VERBOSE || priority == Log.DEBUG || priority == Log.INFO) &#123;</div><div class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">log</span><span class=\"params\">(<span class=\"keyword\">int</span> priority, String tag, String message, Throwable t)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (!isLoggable(tag, priority)) &#123;</div><div class=\"line\">            <span class=\"keyword\">return</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">super</span>.log(priority, tag, message, t);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>接着，在Application的onCreate()方法中添加：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span> (BuildConfig.DEBUG) &#123;</div><div class=\"line\">    Timber.plant(<span class=\"keyword\">new</span> ThreadAwareDebugTree());</div><div class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">    Timber.plant(<span class=\"keyword\">new</span> ReleaseTree());</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>最后，在需要打印日志的地方，调用类似<code>Timber.v(&quot;Hello&quot;)</code>即可，TAG为调用该语句的类名。</p>\n<p>视频教程：<a href=\"https://caster.io/episodes/episode-14-logging-with-timber/\" target=\"_blank\" rel=\"external\">Logging with Timber</a>。</p>\n","categories":[],"tags":["Android"]},{"title":"Android图像处理-像素化的原理及实现","url":"http://xiazdong.github.io/2017/05/16/android-pixelize/","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>像素化（Pixelization），又称马赛克，是图像处理中非常常见的技术，现阶段已经成为了一种创作手段。本文首先会讲解像素化的实现原理，接着会给出Java版的实现，最后介绍马赛克相关的开源项目。</p>\n<h2 id=\"算法介绍\"><a href=\"#算法介绍\" class=\"headerlink\" title=\"算法介绍\"></a>算法介绍</h2><p>马赛克算法首先需要确定马赛克单元的大小，即小方块的大小。马赛克图的每个马赛克单元都是纯色的块，其取值一般为原图中该块区域的颜色的均值（这里的实现为了简化，取了原图中该区域左上角的像素）。马赛克单元的大小决定了最后的马赛克图的样子，当值为1时，就是原图。</p>\n<p><img src=\"https://raw.githubusercontent.com/xiazdong/BlurDemo/master/images/small-pixelate.jpg\" alt=\"\"></p>\n<p>上图中，最左边的图是原图，中间的图是马赛克图。当然你也可以对图像的某块区域打马赛克，如最右边的图，他只对头部打马赛克。</p>\n<p>算法实现如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PixelateUtil</span> </span>&#123;</div><div class=\"line\">    <span class=\"comment\">/**</span></div><div class=\"line\">     * 普通图像－&gt;像素图，zoneWidth为像素图的大像素的宽度</div><div class=\"line\">     */</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Bitmap <span class=\"title\">pixelate</span><span class=\"params\">(Bitmap bitmap, <span class=\"keyword\">int</span> zoneWidth)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> pixelate(bitmap, zoneWidth, <span class=\"number\">0</span>, <span class=\"number\">0</span>, bitmap.getWidth(), bitmap.getHeight());</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">/**</span></div><div class=\"line\">     * 普通图－&gt;像素图，left、top、right、bottom可指定打马赛克区域</div><div class=\"line\">     */</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Bitmap <span class=\"title\">pixelate</span><span class=\"params\">(Bitmap bitmap, <span class=\"keyword\">int</span> zoneWidth, <span class=\"keyword\">int</span> left, <span class=\"keyword\">int</span> top, <span class=\"keyword\">int</span> right, <span class=\"keyword\">int</span> bottom)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">int</span> w = bitmap.getWidth();</div><div class=\"line\">        <span class=\"keyword\">int</span> h = bitmap.getHeight();</div><div class=\"line\">        Bitmap result = bitmap.copy(Bitmap.Config.ARGB_8888, <span class=\"keyword\">true</span>);</div><div class=\"line\">        Canvas canvas = <span class=\"keyword\">new</span> Canvas(result);</div><div class=\"line\">        Paint paint = <span class=\"keyword\">new</span> Paint();</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = left; i &lt; right; i += zoneWidth) &#123;</div><div class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = top; j &lt; bottom; j += zoneWidth) &#123;</div><div class=\"line\">                <span class=\"keyword\">int</span> color = bitmap.getPixel(i, j);</div><div class=\"line\">                paint.setColor(color);</div><div class=\"line\">                <span class=\"keyword\">int</span> gridRight = Math.min(w, i + zoneWidth);</div><div class=\"line\">                <span class=\"keyword\">int</span> gridBottom = Math.min(h, j + zoneWidth);</div><div class=\"line\">                canvas.drawRect(i, j, gridRight, gridBottom, paint);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">return</span> result;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>使用方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">Bitmap result = PixelateUtil.pixelate(bitmap, zoneWidth);  <span class=\"comment\">//对全图打马赛克</span></div><div class=\"line\">Bitmap result = PixelateUtil.pixelate(bitmap, zoneWidth, left, top, right, bottom); <span class=\"comment\">//对指定区域打马赛克</span></div></pre></td></tr></table></figure>\n<h2 id=\"开源项目\"><a href=\"#开源项目\" class=\"headerlink\" title=\"开源项目\"></a>开源项目</h2><p><a href=\"https://github.com/DanielMartinus/Pixelate\" target=\"_blank\" rel=\"external\">Pixelate</a>是实现基本马赛克效果的开源项目，它能够异步对整个或者部分的Bitmap区域打马赛克，处理完后会在OnPixelateListener的onPixelated()中回调，最小的SDK版本为16。</p>\n<p>使用方法如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">new</span> Pixelate(origin)</div><div class=\"line\">    .setArea(<span class=\"number\">0</span>,<span class=\"number\">0</span>,origin.getWidth(),origin.getHeight())  <span class=\"comment\">//设置区域</span></div><div class=\"line\">    .setDensity(<span class=\"number\">12</span>) <span class=\"comment\">//值越大，马赛克单元越小</span></div><div class=\"line\">    .setListener(<span class=\"keyword\">new</span> OnPixelateListener() &#123;</div><div class=\"line\">        <span class=\"meta\">@Override</span></div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onPixelated</span><span class=\"params\">(Bitmap bitmap, <span class=\"keyword\">int</span> density)</span> </span>&#123;</div><div class=\"line\">            <span class=\"comment\">//bitmap为马赛克图</span></div><div class=\"line\">            Log.v(TAG, <span class=\"string\">\"\"</span>);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;)</div><div class=\"line\">    .make</div><div class=\"line\">    ();</div></pre></td></tr></table></figure>\n<p><a href=\"https://github.com/bmaslakov/android-close-pixelate\" target=\"_blank\" rel=\"external\">android-close-pixelate</a>能够实现多样式的马赛克效果。使用方法如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">Bitmap pixelated = Pixelate.fromBitmap(</div><div class=\"line\">        origin,</div><div class=\"line\">        <span class=\"keyword\">new</span> PixelateLayer.Builder(PixelateLayer.Shape.Circle) <span class=\"comment\">//设置马赛克形状</span></div><div class=\"line\">                .setResolution(<span class=\"number\">30</span>) <span class=\"comment\">//每个像素的密度（如果该值和size值一样，那么圆形之间相邻）</span></div><div class=\"line\">                .setSize(<span class=\"number\">30</span>) <span class=\"comment\">//圆圈的大小</span></div><div class=\"line\">                .build()</div><div class=\"line\">);</div></pre></td></tr></table></figure>\n<p>效果如下：</p>\n<p><img src=\"https://raw.githubusercontent.com/xiazdong/BlurDemo/master/images/small-circle-pixelate.jpg\" alt=\"\"></p>\n","categories":[],"tags":["Android"]},{"title":"Android图像处理 - 高斯模糊的原理及实现","url":"http://xiazdong.github.io/2017/04/30/高斯模糊/","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>高斯模糊是图像处理中几乎每个程序员都或多或少听过的名词，但是对其原理大家可能并不了解，只知道通过高斯模糊能实现图像毛玻璃效果。</p>\n<p>本文首先介绍图像处理中最基本的概念：卷积；随后介绍高斯模糊的核心内容：高斯滤波器；接着，我们从头实现了一个Java版本的高斯模糊算法，以及实现RenderScript版本。由于我们自己实现的Java版本的高斯模糊算法的效率太低，因此最后介绍比较有名的高斯模糊的开源项目：<a href=\"https://github.com/wasabeef/Blurry\" target=\"_blank\" rel=\"external\">Blurry</a>以及<a href=\"https://github.com/gogopop/BlurKit-Android\" target=\"_blank\" rel=\"external\">BlurKit-Android</a>。 </p>\n<p><a href=\"https://github.com/xiazdong/BlurDemo\" target=\"_blank\" rel=\"external\">BlurDemo</a>是本文的配套Demo：</p>\n<ul>\n<li>Demo1：Java版本的高斯模糊的简单实现。</li>\n<li>Demo2：RenderScript的高斯模糊实现。</li>\n<li>Demo3：BlurKit-Android的基本使用。</li>\n<li>Demo4：Blurry的基本使用。</li>\n</ul>\n<h2 id=\"卷积\"><a href=\"#卷积\" class=\"headerlink\" title=\"卷积\"></a>卷积</h2><p>本文只讨论图像，而图像可以表示为二维矩阵，其中每个元素为ARGB像素值，因此这里讨论二维矩阵的卷积操作。卷积（Convolution）是图像处理中最基本的操作，就是一个二维矩阵A（M*N）和一个二维矩阵B（m*n）做若干操作，生成一个新的二维矩阵C（M*N），其中m和n远小于M和N，B称为卷积核（kernel），又称滤波器矩阵或模板。</p>\n<p>这里举个卷积的例子，如图：</p>\n<p><img src=\"https://raw.githubusercontent.com/xiazdong/BlurDemo/master/images/small-convolution-01.png\" alt=\"\"> </p>\n<p>上图中，最左边的是源矩阵（8*8），中间是卷积核（3*3，半径为1），最右边是通过对前面两个矩阵做卷积生成的结果矩阵。图中，如果我们要求出结果矩阵中第二行第二列的元素的值，则把卷积核的中心元素（值为0）和源矩阵的第二行第二列（值为6）对齐，然后求加权和，即图中的公式，最后得到-3。</p>\n<p>我们再举一个例子：</p>\n<p><img src=\"https://raw.githubusercontent.com/xiazdong/BlurDemo/master/images/small-convolution-02.jpg\" alt=\"\"></p>\n<p>上图也展示了如何做卷积的过程，比如要求出结果矩阵中第一行第一列的值，则把卷积核的中心对准源矩阵的第一行第一列，发现部分区域超出源矩阵的范围了（图中红色部分），解决方法有很多，这里的方案是：用边界值填充。接着做加权和，结果为-5。接着用同样的方法依次计算结果矩阵的每个元素即可。</p>\n<p>通常来说卷积核需要满足：</p>\n<ul>\n<li>宽和高都为奇数，这样才会有半径和中心的概念。</li>\n<li>元素总和为1。</li>\n</ul>\n<h2 id=\"滤波器\"><a href=\"#滤波器\" class=\"headerlink\" title=\"滤波器\"></a>滤波器</h2><h3 id=\"均值滤波器\"><a href=\"#均值滤波器\" class=\"headerlink\" title=\"均值滤波器\"></a>均值滤波器</h3><p>均值滤波器（Mean Filter）是最简单的一种滤波器，它是最粗糙的一种模糊图像的方法，高斯滤波是均值滤波的高级版本。实际上不同的滤波器就是通过改变卷积核（滤波器），从而改变最后的结果矩阵，中间步骤都一样，都是求加权和。均值滤波器的卷积核通常是m*m的矩阵，其中每个元素为1/(m^2)，可以看出卷积核的元素总和为1。比如3*3的均值滤波器，卷积核的每个元素就是1/9。</p>\n<h3 id=\"高斯滤波器\"><a href=\"#高斯滤波器\" class=\"headerlink\" title=\"高斯滤波器\"></a>高斯滤波器</h3><p>高斯滤波器是均值滤波器的高级版本，唯一的区别在于，均值滤波器的卷积核的每个元素都相同，而高斯滤波器的卷积核的元素服从高斯分布。</p>\n<p>高斯滤波器是基于二维的高斯分布函数，因此首先介绍二维高斯分布函数。二维高斯分布函数和图如下：</p>\n<p><img src=\"https://raw.githubusercontent.com/xiazdong/BlurDemo/master/images/small-two_dimension_gussian.png\" alt=\"\"></p>\n<p>其中x和y表示卷积核中某个元素横坐标和纵坐标距离中心点的距离。sigma控制曲线的平缓程度，值越大，越平缓，最高点越低。我们可以轻易看出当x=0且y=0时值最大，即卷积核的中心点权重最大。</p>\n<p>比如卷积核中一个元素距离中心点，横向距离2，纵向距离1，那么x=2,y=1，就能求出该元素的值。当然为了保证卷积核元素总和为1，最后每个元素都需要除以卷积核中所有元素之和。</p>\n<p>怎么确定卷积核的大小呢？确定sigma之后，虽然不管距离中心点多远，该元素的高斯分布函数值总为非负数，但是根据经验，卷积核的半径定为3*sigma，因此宽高为6*sigma+1。</p>\n<p>如果高斯滤波器的卷积核是二维的（m*n），则算法复杂度为O(m*n*M*N)，复杂度较高，因此接下来我们对算法复杂度进行优化。</p>\n<p>一维的高斯分布函数和图如下：</p>\n<p><img src=\"https://raw.githubusercontent.com/xiazdong/BlurDemo/master/images/small-one_dimension_gussian.png\" alt=\"\"></p>\n<p>实际上，二维高斯分布函数可以分解为两个一维高斯分布函数相乘，如下：</p>\n<p><img src=\"https://raw.githubusercontent.com/xiazdong/BlurDemo/master/images/small-gussian_formula.png\" alt=\"\"></p>\n<p>因此原本的源矩阵和二维卷积核做卷积等价于源矩阵先与1*m的一维卷积核做卷积，再与m*1的一维卷积核做卷积。一维卷积核的半径仍定为3*sigma。此时算法复杂度变为O(2*m*M*N)。</p>\n<h2 id=\"高斯模糊的实现\"><a href=\"#高斯模糊的实现\" class=\"headerlink\" title=\"高斯模糊的实现\"></a>高斯模糊的实现</h2><h3 id=\"Java版本\"><a href=\"#Java版本\" class=\"headerlink\" title=\"Java版本\"></a>Java版本</h3><p>这里实现了简单版本的高斯模糊，通过使用横向和纵向的一维高斯滤波器分别对源矩阵卷积，通过设置sigma的大小能控制图片的模糊程度，值越大越模糊。但是算法速度仍比较慢，建议直接使用RenderScript版本或直接使用成熟的开源项目。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">GussianBlur</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> GussianBlur INSTANCE = <span class=\"keyword\">new</span> GussianBlur();</div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> sigma = <span class=\"number\">15</span>;   <span class=\"comment\">//通过调节该参数设置高斯模糊的模糊程度，越大越模糊</span></div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> radius = <span class=\"number\">3</span> * sigma;</div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">double</span>[] kernel = <span class=\"keyword\">new</span> <span class=\"keyword\">double</span>[radius + <span class=\"number\">1</span>];  <span class=\"comment\">//kernel[i]表示离中心点距离为i的权重</span></div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">GussianBlur</span><span class=\"params\">()</span> </span>&#123;&#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">/**</span></div><div class=\"line\">     * 初始化卷积核</div><div class=\"line\">     * 0.39894 = 1 / (Math.sqrt(2 * PI))</div><div class=\"line\">     */</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">initKernel</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">double</span> sum = <span class=\"number\">0.0</span>;</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; kernel.length; i++) &#123;</div><div class=\"line\">            kernel[i] = <span class=\"number\">0.39894</span> * Math.exp(- (i * i * <span class=\"number\">1.0</span>) / (<span class=\"number\">2.0</span> * sigma * sigma)) / sigma;</div><div class=\"line\">            <span class=\"keyword\">if</span> (i &gt; <span class=\"number\">0</span>) &#123;</div><div class=\"line\">                sum = sum + kernel[i] * <span class=\"number\">2.0</span>;</div><div class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">                sum = sum + kernel[i];</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; kernel.length; i++) &#123;</div><div class=\"line\">            kernel[i] = kernel[i] / sum;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">/**</span></div><div class=\"line\">     * 高斯模糊</div><div class=\"line\">     */</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Bitmap <span class=\"title\">blur</span><span class=\"params\">(Bitmap bitmap)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">int</span> w = bitmap.getWidth();</div><div class=\"line\">        <span class=\"keyword\">int</span> h = bitmap.getHeight();</div><div class=\"line\">        <span class=\"keyword\">int</span>[] pix = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[w * h];</div><div class=\"line\">        bitmap.getPixels(pix, <span class=\"number\">0</span>, w, <span class=\"number\">0</span>, <span class=\"number\">0</span>, w, h);</div><div class=\"line\">        Bitmap tmp = Bitmap.createBitmap(w, h, Bitmap.Config.ARGB_8888);</div><div class=\"line\">        Bitmap result = Bitmap.createBitmap(w, h, Bitmap.Config.ARGB_8888);</div><div class=\"line\">        <span class=\"comment\">//横向</span></div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; w * h; i++) &#123;</div><div class=\"line\">            <span class=\"keyword\">int</span> x = i % w;</div><div class=\"line\">            <span class=\"keyword\">int</span> y = i / w;</div><div class=\"line\">            <span class=\"keyword\">double</span>[] sum = <span class=\"keyword\">new</span> <span class=\"keyword\">double</span>[<span class=\"number\">4</span>];</div><div class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = -radius; j &lt;= radius; j++) &#123;</div><div class=\"line\">                <span class=\"keyword\">int</span> currentX = Math.min(Math.max(x + j, <span class=\"number\">0</span>), w - <span class=\"number\">1</span>);</div><div class=\"line\">                <span class=\"keyword\">int</span> index = y * w + currentX;</div><div class=\"line\">                <span class=\"keyword\">int</span> a = Color.alpha(pix[index]);</div><div class=\"line\">                <span class=\"keyword\">int</span> r = Color.red(pix[index]);</div><div class=\"line\">                <span class=\"keyword\">int</span> g = Color.green(pix[index]);</div><div class=\"line\">                <span class=\"keyword\">int</span> b = Color.blue(pix[index]);</div><div class=\"line\">                sum[<span class=\"number\">0</span>] = sum[<span class=\"number\">0</span>] + a * kernel[Math.abs(j)];</div><div class=\"line\">                sum[<span class=\"number\">1</span>] = sum[<span class=\"number\">1</span>] + r * kernel[Math.abs(j)];</div><div class=\"line\">                sum[<span class=\"number\">2</span>] = sum[<span class=\"number\">2</span>] + g * kernel[Math.abs(j)];</div><div class=\"line\">                sum[<span class=\"number\">3</span>] = sum[<span class=\"number\">3</span>] + b * kernel[Math.abs(j)];</div><div class=\"line\">            &#125;</div><div class=\"line\">            <span class=\"keyword\">int</span> rc = Color.argb((<span class=\"keyword\">int</span>) sum[<span class=\"number\">0</span>], (<span class=\"keyword\">int</span>) sum[<span class=\"number\">1</span>], (<span class=\"keyword\">int</span>) sum[<span class=\"number\">2</span>], (<span class=\"keyword\">int</span>) sum[<span class=\"number\">3</span>]);</div><div class=\"line\">            tmp.setPixel(x, y, rc);</div><div class=\"line\">        &#125;</div><div class=\"line\">        tmp.getPixels(pix, <span class=\"number\">0</span>, w, <span class=\"number\">0</span>, <span class=\"number\">0</span>, w, h);</div><div class=\"line\">        <span class=\"comment\">//纵向</span></div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; w * h; i++) &#123;</div><div class=\"line\">            <span class=\"keyword\">int</span> x = i % w;</div><div class=\"line\">            <span class=\"keyword\">int</span> y = i / w;</div><div class=\"line\">            <span class=\"keyword\">double</span>[] sum = <span class=\"keyword\">new</span> <span class=\"keyword\">double</span>[<span class=\"number\">4</span>];</div><div class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = -radius; j &lt;= radius; j++) &#123;</div><div class=\"line\">                <span class=\"keyword\">int</span> currentY = Math.min(Math.max(y + j, <span class=\"number\">0</span>), h - <span class=\"number\">1</span>);</div><div class=\"line\">                <span class=\"keyword\">int</span> index = currentY * w + x;</div><div class=\"line\">                <span class=\"keyword\">int</span> r = Color.red(pix[index]);</div><div class=\"line\">                <span class=\"keyword\">int</span> g = Color.green(pix[index]);</div><div class=\"line\">                <span class=\"keyword\">int</span> b = Color.blue(pix[index]);</div><div class=\"line\">                <span class=\"keyword\">int</span> a = Color.alpha(pix[index]);</div><div class=\"line\">                sum[<span class=\"number\">0</span>] = sum[<span class=\"number\">0</span>] + a * kernel[Math.abs(j)];</div><div class=\"line\">                sum[<span class=\"number\">1</span>] = sum[<span class=\"number\">1</span>] + r * kernel[Math.abs(j)];</div><div class=\"line\">                sum[<span class=\"number\">2</span>] = sum[<span class=\"number\">2</span>] + g * kernel[Math.abs(j)];</div><div class=\"line\">                sum[<span class=\"number\">3</span>] = sum[<span class=\"number\">3</span>] + b * kernel[Math.abs(j)];</div><div class=\"line\">            &#125;</div><div class=\"line\">            <span class=\"keyword\">int</span> rc = Color.argb((<span class=\"keyword\">int</span>) sum[<span class=\"number\">0</span>], (<span class=\"keyword\">int</span>) sum[<span class=\"number\">1</span>], (<span class=\"keyword\">int</span>) sum[<span class=\"number\">2</span>], (<span class=\"keyword\">int</span>) sum[<span class=\"number\">3</span>]);</div><div class=\"line\">            result.setPixel(x, y, rc);</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">return</span> result;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">setRadius</span><span class=\"params\">(<span class=\"keyword\">int</span> radius)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.sigma = radius;</div><div class=\"line\">        <span class=\"keyword\">this</span>.radius = <span class=\"number\">3</span> * sigma;</div><div class=\"line\">        <span class=\"keyword\">this</span>.kernel = <span class=\"keyword\">new</span> <span class=\"keyword\">double</span>[<span class=\"keyword\">this</span>.radius + <span class=\"number\">1</span>];</div><div class=\"line\">        initKernel();</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> GussianBlur <span class=\"title\">getInstance</span><span class=\"params\">(<span class=\"keyword\">int</span> radius)</span> </span>&#123;</div><div class=\"line\">        INSTANCE.setRadius(radius);</div><div class=\"line\">        <span class=\"keyword\">return</span> INSTANCE;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> GussianBlur <span class=\"title\">getInstance</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        INSTANCE.setRadius(<span class=\"number\">15</span>);</div><div class=\"line\">        <span class=\"keyword\">return</span> INSTANCE;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>效果如下：</p>\n<p><img src=\"https://raw.githubusercontent.com/xiazdong/BlurDemo/master/images/small-gussian_blur.jpg\" alt=\"\"></p>\n<h3 id=\"RenderScript版本\"><a href=\"#RenderScript版本\" class=\"headerlink\" title=\"RenderScript版本\"></a>RenderScript版本</h3><p>RenderScript是Android提出的一个计算密集型任务的高性能框架，能并行的处理任务，他可以充分利用多核CPU和GPU，你不需要管怎么调度你的任务，只需要管任务具体做什么。这里不深入介绍RenderScript，因为RenderScript已经提供了一个实现高斯模糊的类：ScriptIntrinsicBlur。</p>\n<p>实现起来非常简单：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Bitmap <span class=\"title\">blur</span><span class=\"params\">(Bitmap bmp)</span> </span>&#123;</div><div class=\"line\">    Bitmap result = Bitmap.createBitmap(bmp.getWidth(), bmp.getHeight(), Bitmap.Config.ARGB_8888);</div><div class=\"line\">    RenderScript rs = RenderScript.create(<span class=\"keyword\">this</span>); <span class=\"comment\">//创建RenderScript对象</span></div><div class=\"line\">    ScriptIntrinsicBlur blur = ScriptIntrinsicBlur.create(rs, Element.U8_4(rs)); <span class=\"comment\">//创建高斯模糊脚本对象</span></div><div class=\"line\">    Allocation in = Allocation.createFromBitmap(rs, bmp);  <span class=\"comment\">//输入</span></div><div class=\"line\">    Allocation out = Allocation.createFromBitmap(rs, result); <span class=\"comment\">//输出</span></div><div class=\"line\">    blur.setRadius(<span class=\"number\">25f</span>); <span class=\"comment\">//设置模糊半径</span></div><div class=\"line\">    blur.setInput(in); <span class=\"comment\">//把输入图像传进去</span></div><div class=\"line\">    blur.forEach(out); <span class=\"comment\">//执行，并写入到out</span></div><div class=\"line\">    out.copyTo(result); <span class=\"comment\">//拷贝到Bitmap中</span></div><div class=\"line\">    rs.destroy();</div><div class=\"line\">    <span class=\"keyword\">return</span> result;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"开源项目\"><a href=\"#开源项目\" class=\"headerlink\" title=\"开源项目\"></a>开源项目</h2><p>关于Android图像模糊的开源项目有很多，比如<a href=\"https://github.com/wasabeef/Blurry\" target=\"_blank\" rel=\"external\">Blurry</a>是专门针对Bitmap或View做模糊，可以设置模糊的基底色，而且还能对模糊操作异步化；<a href=\"https://github.com/gogopop/BlurKit-Android\" target=\"_blank\" rel=\"external\">BlurKit-Android</a>也能对Bitmap做高斯模糊（内部通过RenderScript实现），但最吸引人的是实现了毛玻璃的遮罩，效果如下：</p>\n<p><img src=\"https://github.com/gogopop/BlurKit-Android/raw/master/.repo/demo.gif\" alt=\"\"></p>\n<p>BlurKit-Android支持的最低版本是Android 4.1（API 16），因此如果应用需要支持的最低版本是4.0，则不能使用该库，Blurry支持的最低版本是3.0。</p>\n<h3 id=\"BlurKit-Android\"><a href=\"#BlurKit-Android\" class=\"headerlink\" title=\"BlurKit-Android\"></a>BlurKit-Android</h3><p>配置过程如下：</p>\n<ul>\n<li>在build.gradle中设置：<code>compile &#39;com.wonderkiln:blurkit:1.0.0&#39;</code>，并在defaultConfig中设置<code>renderscriptTargetApi 24</code>和<code>renderscriptSupportModeEnabled true</code>。</li>\n<li>在Application的onCreate()最开始处加入<code>BlurKit.init(this);</code>。</li>\n</ul>\n<p>配置完成后，通过调用<code>BlurKit.getInstance().blur(Bitmap src, int radius);</code>实现高斯模糊，并会把高斯模糊的结果图写入src，其中0&lt;radius&lt;=25。</p>\n<p>该库还提供了<code>fastBlur()</code>实现速度更快的高斯模糊，和<code>blur()</code>的区别在于，<code>fastBlur()</code>在高斯模糊之前对图片采样，使得图片大小缩小好几倍，从而加快高斯模糊的速度。这种加快速度的方法是合理的，因为高斯模糊并不需要原图像很精确的信息。</p>\n<p>BlurKit-Android最吸引人的是提供高斯模糊的遮罩（BlurLayout），随着遮罩下面的内容的变化，高斯模糊效果也会随之改变。使用如下：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">com.wonderkiln.blurkit.BlurLayout</span></span></div><div class=\"line\">    <span class=\"attr\">android:id</span>=<span class=\"string\">\"@+id/blurLayout\"</span></div><div class=\"line\">    <span class=\"attr\">android:layout_width</span>=<span class=\"string\">\"150dp\"</span></div><div class=\"line\">    <span class=\"attr\">android:layout_height</span>=<span class=\"string\">\"150dp\"</span>/&gt;</div></pre></td></tr></table></figure>\n<p>该Layout能够实现实时的对该Layout下面的内容做高斯模糊。</p>\n<h3 id=\"Blurry\"><a href=\"#Blurry\" class=\"headerlink\" title=\"Blurry\"></a>Blurry</h3><p>配置方法：在build.gradle中添加<code>compile &#39;jp.wasabeef:blurry:2.1.1&#39;</code>。</p>\n<p>使用方法如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">Blurry.with(<span class=\"keyword\">this</span>)</div><div class=\"line\">\t  .radius(<span class=\"number\">10</span>)    <span class=\"comment\">//值越大越模糊</span></div><div class=\"line\">\t  .sampling(<span class=\"number\">2</span>)   <span class=\"comment\">//对原图像抽样</span></div><div class=\"line\">\t  .async()       <span class=\"comment\">//异步</span></div><div class=\"line\">\t  .from(Bitmap bmp)   <span class=\"comment\">//对bmp做高斯模糊</span></div><div class=\"line\">\t  .into(ImageView view); <span class=\"comment\">//把结果写入ImageView</span></div></pre></td></tr></table></figure>\n<p>总的来说，这两个库都使用起来非常方便。</p>\n","categories":[],"tags":["Android"]},{"title":"Android性能优化：图片保存，还能更快","url":"http://xiazdong.github.io/2017/03/28/Android性能优化：图片保存，还能更快/","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>本文主要介绍带Exif信息的JPEG图片的保存优化。原来在这种情况下，整个过程分为两步：</p>\n<ul>\n<li>首先调用Bitmap的<code>compress()</code>保存图片数据。</li>\n<li>然后通过ExifInterface类设置需要保存的Exif信息。</li>\n</ul>\n<p>是否能通过一步直接完成Exif信息和Bitmap数据的写入呢？答案是能。</p>\n<p>本文首先介绍了JPEG文件结构，通过对该结构的剖析，可以看出一次写入Exif信息和Bitmap数据是完全可能的。其次介绍了ExifInterface的使用方法。最后介绍了JPEG保存优化的核心类ExifOutputStream。</p>\n<h2 id=\"JPEG文件结构\"><a href=\"#JPEG文件结构\" class=\"headerlink\" title=\"JPEG文件结构\"></a>JPEG文件结构</h2><p>基本概念：</p>\n<ul>\n<li>JPEG（Joint Photographic Experts Group，一种针对图像的有损压缩方法）：描述一个图像如何转换为字节流。</li>\n<li>JFIF（JPEG File Interchange Format，JPEG文件交换格式）：描述一个JPEG字节流如何转换为电脑上存储的文件。</li>\n<li>EXIF（Exchangeable image file format，可交换图像文件格式）：可以记录照片的属性信息和拍摄信息。Exif信息是附加在JPEG文件头中的，以0xFFE1为开头，后面两个字节表示Exif信息的长度。</li>\n</ul>\n<p>为了更加简单的说明JPEG文件的结构，我们拿带有EXIF信息的最简单的图片作为例子，一共8张图，如下图所示：</p>\n<p><img src=\"https://raw.githubusercontent.com/xiazdong/BlurDemo/master/images/exif.png\" alt=\"\"></p>\n<p>第一张图是正常的F，后面7张都是对F进行了翻转或旋转，这些图片只有Exif中的Orientation值不一样，其余数据完全一样，因此这里我们就拿第八张图分析，我们通过iHex应用查看了该图片的16进制串，如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">FFD8FFE0 00104A46 49460001 010100DC 00DC0000 FFE10022 45786966 00004949 2A000800 00000100 12010300 01000000 08000000 00000000 FFDB0043 00060504 04050606 0506060A 08060707 0A09090A 0A101417 100C0F0E 141D1A16 16141718 18161C23 1B1A1F25 2623202C 20161929 2A29272D 302D1F25 30282928 28FFC000 0B080030 00500101 1100FFC4 001F0000 01050101 01010101 00000000 00000000 01020304 05060708 090A0BFF C400B510 00020103 03020403 05050404 0000017D 01020300 04110512 21314106 13516107 22711432 8191A108 2342B1C1 1552D1F0 24336272 82090A16 1718191A 25262728 292A3435 36373839 3A434445 46474849 4A535455 56575859 5A636465 66676869 6A737475 76777879 7A838485 86878889 8A929394 95969798 999AA2A3 A4A5A6A7 A8A9AAB2 B3B4B5B6 B7B8B9BA C2C3C4C5 C6C7C8C9 CAD2D3D4 D5D6D7D8 D9DAE1E2 E3E4E5E6 E7E8E9EA F1F2F3F4 F5F6F7F8 F9FAFFDA 00080101 00003F00 F9528A28 A28A28A2 8A28A28A 28A28A28 AFD54A28 A2BF2AE8 AFD54A2B F2AE8AFD 54A28A2B F2AE8AFD 54A2BF2A E8AFD54A 28A28A28 A2BF2AE8 AFD54A28 A28A28A2 BF2AE8AF FFD9</div></pre></td></tr></table></figure>\n<p>是不是一头雾水？首先我们给出几个概念：</p>\n<ul>\n<li>Exif信息以0xFFE1开头，后面的2个字节是Exif信息的长度，该长度为这2个字节和后面Exif信息的长度和。</li>\n<li>Exif每个Tag的结构为AAAA BBBB CCCCCCCC DDDDDDDD，其中AAAA为Tag Name，DDDDDDDD为Tag Value，BBBB为Tag Value的数据类型，CCCCCCCC为Tag Value的个数。</li>\n</ul>\n<p>这里将该串进行了拆解，并一一进行分析：</p>\n<table>\n<thead>\n<tr>\n<th>十六进制串</th>\n<th>解释</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>FFD8</td>\n<td>SOI(Start Of Image)，JPEG的文件头。</td>\n</tr>\n<tr>\n<td>FFE0</td>\n<td>数码相机信息的标记头，即以下信息是数码配置信息。</td>\n</tr>\n<tr>\n<td>0010</td>\n<td>长度信息+真实数据的总长度为16字节，即真实数据的长度为14字节。</td>\n</tr>\n<tr>\n<td>4A46 49460001 010100DC 00DC0000</td>\n<td>数码相机配置信息。</td>\n</tr>\n<tr>\n<td>FFE1</td>\n<td>Exif 标记，表示Exif信息的开始。</td>\n</tr>\n<tr>\n<td>0022</td>\n<td>值为34，即Exif的数据+长度信息的长度为34字节，表示下面的Exif数据长度为32字节。</td>\n</tr>\n<tr>\n<td>45786966 0000</td>\n<td>Exif的ASCII字符串。</td>\n</tr>\n<tr>\n<td>4949</td>\n<td>Exif的数据是按大端（motorola byte align）还是小端（Intel byte align），4949表示小端，4d4d表示大端。</td>\n</tr>\n<tr>\n<td>2A00</td>\n<td>值为002A，常量。因为是小端，所以是2A00。</td>\n</tr>\n<tr>\n<td>0800 0000</td>\n<td>值为00000008，常量，表示第一个exif tag距离4949的偏移量。</td>\n</tr>\n<tr>\n<td>0100</td>\n<td>值为0001，表示后面有一个tag。</td>\n</tr>\n<tr>\n<td>1201</td>\n<td>值为0112，表示tag name为orientation。</td>\n</tr>\n<tr>\n<td>0300</td>\n<td>值为0003，表示类型为unsigned short，即orientation的值占2个字节。</td>\n</tr>\n<tr>\n<td>01000000</td>\n<td>orientation对应的值的个数，这里是1个。</td>\n</tr>\n<tr>\n<td>08000000 00000000</td>\n<td>值为00000000 00000008，具体的含义在下文中解释。</td>\n</tr>\n<tr>\n<td>…</td>\n<td>图片数据。</td>\n</tr>\n<tr>\n<td>FFD9</td>\n<td>EOI(End Of Image)，JPEG的文件尾。</td>\n</tr>\n</tbody>\n</table>\n<p>其中，需要进一步解释的是ORIENTATION，值可以从1－8，每个值对应的是图片的不同偏转，如下图所示：</p>\n<p>在Android相机拍照中，一般只需要处理其中4种情况，分别是：</p>\n<ul>\n<li>1：正常角度，对应ExifInterface.ORIENTATION_NORMAL。</li>\n<li>3：偏转180度，需要偏转180度去纠正，对应ExifInterface.ORIENTATION_ROTATE_180。</li>\n<li>6：偏转270度，需要偏转90度去纠正，对应ExifInterface.ORIENTATION_ROTATE_90。</li>\n<li>8：偏转90度，需要偏转270度去纠正，对应ExifInterface.ORIENTATION_ROTATE_270。</li>\n</ul>\n<p>如下图所示：</p>\n<p><img src=\"https://raw.githubusercontent.com/xiazdong/BlurDemo/master/images/camera_exif.png\" alt=\"\"></p>\n<p>在Android Studio中能够看到没纠正过角度的图片，Mac的预览图片看到的是自动纠正过角度的图片。</p>\n<p>一般来说，我们可以通过switch语句对每个orientation的值进行不同的纠正，但是 <a href=\"http://magnushoff.com/jpeg-orientation.html\" target=\"_blank\" rel=\"external\">JPEG Orientation</a> 给出了一个通用的纠正算法，思想为：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">value = value - 1;</div><div class=\"line\">if (value &amp; 100b != 0) 图片对角线翻转</div><div class=\"line\">if (value &amp; 010b != 0) 图片旋转180度</div><div class=\"line\">if (value &amp; 001b != 0) 图片水平翻转</div></pre></td></tr></table></figure>\n<p>具体实现如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Bitmap <span class=\"title\">fixOrientation</span><span class=\"params\">(String file)</span> </span>&#123;</div><div class=\"line\">    Matrix matrix = <span class=\"keyword\">new</span> Matrix();</div><div class=\"line\">    Bitmap bitmap = BitmapFactory.decodeFile(file);</div><div class=\"line\">    <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">        ExifInterface exif = <span class=\"keyword\">new</span> ExifInterface(file);</div><div class=\"line\">        <span class=\"keyword\">int</span> value = exif.getAttributeInt(ExifInterface.TAG_ORIENTATION, ExifInterface.ORIENTATION_UNDEFINED);</div><div class=\"line\">        <span class=\"keyword\">if</span> (value &gt; <span class=\"number\">0</span>) &#123;</div><div class=\"line\">            value --;</div><div class=\"line\">            <span class=\"keyword\">if</span> ((value &amp; <span class=\"number\">0b100</span>) != <span class=\"number\">0</span>) &#123; <span class=\"comment\">//对角线翻转</span></div><div class=\"line\">                matrix.postScale(-<span class=\"number\">1.0f</span>, <span class=\"number\">1.0f</span>);</div><div class=\"line\">                matrix.postRotate(-<span class=\"number\">90</span>);</div><div class=\"line\">            &#125;</div><div class=\"line\">            <span class=\"keyword\">if</span> ((value &amp; <span class=\"number\">0b010</span>) != <span class=\"number\">0</span>) &#123; <span class=\"comment\">//旋转180度</span></div><div class=\"line\">                matrix.postRotate(<span class=\"number\">180</span>);</div><div class=\"line\">            &#125;</div><div class=\"line\">            <span class=\"keyword\">if</span> ((value &amp; <span class=\"number\">0b001</span>) != <span class=\"number\">0</span>) &#123; <span class=\"comment\">//水平翻转</span></div><div class=\"line\">                matrix.postScale(-<span class=\"number\">1.0f</span>, <span class=\"number\">1.0f</span>);</div><div class=\"line\">            &#125;</div><div class=\"line\">            <span class=\"keyword\">return</span> Bitmap.createBitmap(bitmap, <span class=\"number\">0</span>, <span class=\"number\">0</span>, bitmap.getWidth(), bitmap.getHeight(), matrix, <span class=\"keyword\">true</span>);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</div><div class=\"line\">        e.printStackTrace();</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> bitmap;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这里用到了ExifInterface类，该类是系统提供的操作Exif信息的核心类，使用方法是：</p>\n<figure class=\"highlight\"><table><tr><td class=\"code\"><pre><div class=\"line\">ExifInterface exif = new ExifInterface(PATH);</div><div class=\"line\">int orientation = exif.getAttributeInt(ExifInterface.TAG_ORIENTATION, ExifInterface.ORIENTATION_NORMAL);</div><div class=\"line\">exif.setAttribute(ExifInterface.TAG_ORIENTATION, \"1”); //设置ORIENTATION</div><div class=\"line\">exif.saveAttributes(); //保存Exif信息</div></pre></td></tr></table></figure>\n<p>这里需要注意一点：saveAttributes()这个方法很耗时，需要将原文件的数据拷贝到另一个文件，并删除原文件，然后重命名新文件，因此建议在调用该方法之前把该设置的Exif信息全通过setAttribute()设置完，使得saveAttributes()只调用一次。</p>\n<blockquote>\n<p>Android 7.1中新增了ExifInterface Support Library，但是很奇怪，我使用该类获取orientation，始终获取不到，而用android.media.ExifInterface类却没问题。</p>\n</blockquote>\n<h2 id=\"ExifOutputStream\"><a href=\"#ExifOutputStream\" class=\"headerlink\" title=\"ExifOutputStream\"></a>ExifOutputStream</h2><p><a href=\"http://www.imaotao.cn/xref/webrtc-201604/chromium/src/third_party/android_tools/sdk/sources/android-23/com/android/gallery3d/exif/ExifOutputStream.java\" target=\"_blank\" rel=\"external\">ExifOutputStream</a>是系统内部不public的类，位于”com.android.gallery3d.exif”包中，它提供了一次写入Exif信息和JPEG数据的方式。我们可以通过<code>writeExif()</code>实现一次IO写入JPEG和Exif信息。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">writeExif</span><span class=\"params\">(<span class=\"keyword\">byte</span>[] jpeg, ExifData exif, String path)</span> </span>&#123;</div><div class=\"line\">\tOutputStream os = <span class=\"keyword\">null</span>;</div><div class=\"line\">\t<span class=\"keyword\">try</span> &#123;</div><div class=\"line\">\t\tos = <span class=\"keyword\">new</span> FileOutputStream(path);</div><div class=\"line\">\t\tExifOutputStream eos = <span class=\"keyword\">new</span> ExifOutputStream(os);</div><div class=\"line\">\t\t<span class=\"comment\">// Set the exif header</span></div><div class=\"line\">\t\teos.setExifData(exif);</div><div class=\"line\">\t\t<span class=\"comment\">// Write the original jpeg out, the header will be add into the file.</span></div><div class=\"line\">\t\teos.write(jpeg);</div><div class=\"line\">\t&#125; <span class=\"keyword\">catch</span> (FileNotFoundException e) &#123;</div><div class=\"line\">\t\te.printStackTrace();</div><div class=\"line\">\t&#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</div><div class=\"line\">\t\te.printStackTrace();</div><div class=\"line\">\t&#125; <span class=\"keyword\">finally</span> &#123;</div><div class=\"line\">\t\t<span class=\"keyword\">if</span> (os != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">\t\t\t<span class=\"keyword\">try</span> &#123;</div><div class=\"line\">\t\t\t\tos.close();</div><div class=\"line\">\t\t\t&#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</div><div class=\"line\">\t\t\t\te.printStackTrace();</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>根据统计，相比原来的实现，速度提升了10%。</p>\n<h2 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h2><ul>\n<li><a href=\"https://www.media.mit.edu/pia/Research/deepview/exif.html\" target=\"_blank\" rel=\"external\">Exif结构介绍</a></li>\n<li><a href=\"http://magnushoff.com/jpeg-orientation.html\" target=\"_blank\" rel=\"external\">Exif orientation介绍</a></li>\n<li><a href=\"http://www.impulseadventure.com/photo/exif-orientation.html\" target=\"_blank\" rel=\"external\">JPEG Rotation and EXIF Orientation</a></li>\n</ul>\n","categories":[],"tags":["Android"]},{"title":"减少APK大小","url":"http://xiazdong.github.io/2017/03/26/减少APK大小/","content":"<p>本文转载于Bugly。</p>\n<blockquote>\n<p>本文是对 <a href=\"https://developer.android.com/topic/performance/reduce-apk-size.html\" target=\"_blank\" rel=\"external\">Reduce APK Size</a> 的翻译。</p>\n</blockquote>\n<p>用户经常会避免下载看起来体积较大的应用，特别是在不稳定的2G、3G网络或者在以字节付费的网络。这篇文章描述了怎样减少你的APK大小，这会让更多的用户愿意下载你的应用。</p>\n<h2 id=\"理解APK的结构\"><a href=\"#理解APK的结构\" class=\"headerlink\" title=\"理解APK的结构\"></a>理解APK的结构</h2><p>在讨论怎样减少应用大小之前，先了解APK的结构是有用的。一个APK文件就是ZIP包，其中包含了组成你的应用的所有文件，比如Java类文件，资源文件，和一个包含被编译资源的文件。</p>\n<p>一个APK包含了以下目录：</p>\n<ul>\n<li><code>META-INF/</code>: 包含CERT.SF和CERT.RSA签名文件，也包含了MANIFEST.MF文件。（译注：校验这个APK是否被人改动过）</li>\n<li><code>assets/</code>: 包含了应用的资源，这些资源能够通过AssetManager对象获得。</li>\n<li><code>res/</code>: 包含了没被被编译到resources.arsc的资源。</li>\n<li><code>lib/</code>: 包含了针对处理器层面的被编译的代码。这个目录针对每个平台类型都有一个子目录，比如armeabi, armeabi-v7a, arm64-v8a, x86, x86_64和mips。</li>\n</ul>\n<p>一个APK也包含了以下文件，其中只有AndroidManifest.xml是强制的：</p>\n<ul>\n<li><code>resources.arsc</code>: 包含了被编译的资源。该文件包含了<code>res/values</code>目录的所有配置的XML内容。打包工具将XML内容编译成二进制形式并压缩。这些内容包含了语言字符串和styles，还包含了那些内容虽然不直接存储在resources.arsc文件中，但是给定了该内容的路径，比如布局文件和图片。</li>\n<li><code>classes.dex</code>: 包含了能被Dalvik/Art虚拟机理解的DEX文件格式的类。</li>\n<li><code>AndroidManifest.xml</code>: 包含了主要的Android配置文件。这个文件列出了应用名称、版本、访问权限、引用的库文件。该文件使用二进制XML格式存储。（译注：该文件还能看到应用的minSdkVersion, targetSdkVersion等信息）</li>\n</ul>\n<blockquote>\n<p>译注：使用APK Analyzer能够清晰地看出以上文件的内容，具体请看：<a href=\"https://xiazdong.github.io/2017/03/20/%E4%BD%BF%E7%94%A8APK%20Analyzer%E5%88%86%E6%9E%90%E4%BD%A0%E7%9A%84APK/\">使用APK Analyzer分析你的APK</a>。</p>\n</blockquote>\n<h2 id=\"减少资源个数和尺寸\"><a href=\"#减少资源个数和尺寸\" class=\"headerlink\" title=\"减少资源个数和尺寸\"></a>减少资源个数和尺寸</h2><p>APK的大小会影响应用加载的速度，使用的内存大小，消耗的电量大小。一个最简单的缩小APK大小的方式是减少资源的个数和大小。特别地，你能移除应用中不再使用的资源，你也能使用可缩放的Drawable对象代替图片文件。这节讨论一些通过减少资源从而减少APK大小的方法。</p>\n<blockquote>\n<p>译注：减少资源个数和缩小资源大小的效果是很显著的，比如有一天发现我组里的项目中还包含了旧版本的引导页视频（1.5M），一下就就减少了1.5M，想想为了减少1.5M你得删多少代码才能办到。</p>\n</blockquote>\n<h3 id=\"移除不使用的资源\"><a href=\"#移除不使用的资源\" class=\"headerlink\" title=\"移除不使用的资源\"></a>移除不使用的资源</h3><p>lint是Android Studio中的一个静态代码分析工具，检测在”res/“目录中你的代码没有引用的资源。当lint工具发现了项目中潜在的未使用的资源，它会打印以下类似信息：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">res/layout/preferences.xml: Warning: The resource R.layout.preferences appears to be unused [UnusedResources]</div></pre></td></tr></table></figure>\n<blockquote>\n<p>注意：lint工具不会扫描”asset/“目录，这个目录是通过反射引用的资源，或者链接到应用中的库文件。还有，lint不会移除资源，只会发出警告。</p>\n</blockquote>\n<p>被引用的库中可能会包含没使用的资源。如果你在build.gradle文件中启用shrinkResources，则Gradle能自动移除这些资源。</p>\n<p>为了使用shrinkResources，你必须要启用代码混淆。在构建过程中，首先proguard移除了未使用的代码，然后gradle移除未使用的资源。</p>\n<blockquote>\n<p>译注：lint工具还能够检查出未使用的类、类中未使用的方法或变量。</p>\n</blockquote>\n<p>更多关于通过代码混淆和其他方式减包，请看<a href=\"https://developer.android.com/studio/build/shrink-code.html\" target=\"_blank\" rel=\"external\">Shrink Your Code and Resources</a>。</p>\n<p>在Gradle插件0.7或更高版本，你能申明应用支持的配置。Gradle通过传递resConfigs和defaultConfig给构建系统，构建系统会防止不支持的配置出现在APK中，从而减少APK大小。更多信息请看<a href=\"https://developer.android.com/studio/build/shrink-code.html#unused-alt-resources\" target=\"_blank\" rel=\"external\">Remove unused alternative resources</a>。</p>\n<blockquote>\n<p>译注：在hello world工程里，resConfigs配置为”zh”和不配置resConfigs，resources.arsc文件相差了80K。</p>\n</blockquote>\n<h3 id=\"最小化第三方库中资源的使用\"><a href=\"#最小化第三方库中资源的使用\" class=\"headerlink\" title=\"最小化第三方库中资源的使用\"></a>最小化第三方库中资源的使用</h3><p>当开发Android应用时，你经常使用第三方库提升应用的可用性和灵活性。比如，你引用Android Support Library提升旧设备的用户体验，或者使用Google Play服务实现文字自动翻译。</p>\n<p>如果一个第三方库原本是为服务器或普通电脑设计，会引入许多不需要的对象和方法。为了只引入应用需要的库中的那部分，你可以编辑库文件（如果库的license允许你这么做）。你也能使用另外的针对手机的实现同样功能的库。</p>\n<blockquote>\n<p>注意：代码混淆能清除库中不被使用的代码，但是他不能移除库的大量内部依赖。</p>\n</blockquote>\n<h3 id=\"只支持部分屏幕密度\"><a href=\"#只支持部分屏幕密度\" class=\"headerlink\" title=\"只支持部分屏幕密度\"></a>只支持部分屏幕密度</h3><p>Android支持很多设备集，其中包含了各种不同的屏幕密度。在Android 4.4及更高版本，框架支持不同的密度：ldpi, mdpi, tvdpi, hdpi, xhdpi, xxhdpi和xxxhdpi。尽管Android支持所有这些屏幕密度，但你不需要为每个密度都配置相应的资源。</p>\n<p>如果你知道某种特定屏幕密度已经很少有用户使用了，那么你可以考虑是否需要为这个屏幕密度配置资源。如果你不包含针对特定屏幕密度的资源，那么Android会自动缩放原本针对其他密度的已有资源。</p>\n<p>如果你的应用只需要缩放的图片，你甚至可以把图片存放在drawable-nodpi目录，从而节省更多空间。我们推荐每个应用都应该至少包含xxhdpi的图片。</p>\n<p>更多关于屏幕密度的信息，请看<a href=\"https://developer.android.com/about/dashboards/index.html#Screens\" target=\"_blank\" rel=\"external\">Screen Sizes and Densities</a>。</p>\n<h3 id=\"减少动画帧数\"><a href=\"#减少动画帧数\" class=\"headerlink\" title=\"减少动画帧数\"></a>减少动画帧数</h3><p>使用帧动画会大大增加APK的大小。图1显示了目录中构成帧动画的多个PNG文件。每个图片都是动画的一帧。</p>\n<p>对于加入动画的每帧，你都增加了APK中图片的个数。图1中，帧动画的帧率是30 FPS。如果帧率降到15 FPS，图片数量将减少一半。</p>\n<p><img src=\"https://developer.android.com/images/training/performance/animation-frames_2x.png\" alt=\"\"></p>\n<p>图1：帧动画的每一帧图片。</p>\n<blockquote>\n<p>译注：还有一个常见的减包方案是删除帧动画中重复的图片资源，比如第1帧和第3帧的图片一样，那么只保留一个。</p>\n</blockquote>\n<h3 id=\"使用Drawable对象\"><a href=\"#使用Drawable对象\" class=\"headerlink\" title=\"使用Drawable对象\"></a>使用Drawable对象</h3><p>一些图片不需要静态的图片资源，框架能在运行时动态地绘制图像。Drawable对象（XML的<code>&lt;shape&gt;</code>）只需要占用APK中的一点空间。另外，XML形式的Drawable对象能够产生遵循Material Design设计规范的图像。</p>\n<h3 id=\"重用资源\"><a href=\"#重用资源\" class=\"headerlink\" title=\"重用资源\"></a>重用资源</h3><p>你能包含一张图片的很多变种，比如染色、阴影、旋转的版本。但是，我们推荐在运行时复用一张图片来定制化他们。</p>\n<p>Android提供了很多方式改变资源的颜色。对于Android 5.0及以上，使用<code>android:tint</code>和tintMode属性。对于更低版本，使用ColorFilter类。</p>\n<p>你也能够删除那些只是对另一个资源做旋转的资源。下面的代码片段提供了对一个箭头旋转180度。</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;</div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">rotate</span> <span class=\"attr\">xmlns:android</span>=<span class=\"string\">\"http://schemas.android.com/apk/res/android\"</span></span></div><div class=\"line\">    <span class=\"attr\">android:drawable</span>=<span class=\"string\">\"@drawable/ic_arrow_expand\"</span></div><div class=\"line\">    <span class=\"attr\">android:fromDegrees</span>=<span class=\"string\">\"180\"</span></div><div class=\"line\">    <span class=\"attr\">android:pivotX</span>=<span class=\"string\">\"50%\"</span></div><div class=\"line\">    <span class=\"attr\">android:pivotY</span>=<span class=\"string\">\"50%\"</span></div><div class=\"line\">    <span class=\"attr\">android:toDegrees</span>=<span class=\"string\">\"180\"</span> /&gt;</div></pre></td></tr></table></figure>\n<h3 id=\"通过代码绘制\"><a href=\"#通过代码绘制\" class=\"headerlink\" title=\"通过代码绘制\"></a>通过代码绘制</h3><p>你也能通过代码绘制图像，从而减少APK大小。代码方式绘制图像不需要任何空间因为你不再需要在APK中存储图像文件。</p>\n<h3 id=\"压缩PNG文件\"><a href=\"#压缩PNG文件\" class=\"headerlink\" title=\"压缩PNG文件\"></a>压缩PNG文件</h3><p>AAPT工具能够在构建过程中通过无损压缩优化<code>res/drawable/</code>中的图片资源。比如aapt工具能将需要颜色少于256色的PNG变为8位PNG图，这样能够在保证图片质量的同时减少内存使用。</p>\n<p>需要注意aapt有以下局限性：</p>\n<ul>\n<li>aapt工具不会压缩asset目录的PNG文件。</li>\n<li>通过aapt的优化，图片文件会使用少于256色。</li>\n<li>aapt工具可能会影响已经被压缩过的PNG文件。为了防止这种情况，你可以在gradle文件中设置cruncherEnabled为false禁用aapt对PNG的压缩。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">aaptOptions &#123;</div><div class=\"line\">    cruncherEnabled = <span class=\"keyword\">false</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<blockquote>\n<p>译注：建议把cruncherEnabled设为false，然后通过tinypng手工压缩PNG图片。</p>\n</blockquote>\n<h3 id=\"压缩PNG和JPEG文件\"><a href=\"#压缩PNG和JPEG文件\" class=\"headerlink\" title=\"压缩PNG和JPEG文件\"></a>压缩PNG和JPEG文件</h3><p>你能使用一些工具（比如pngcrush, pngquant, zopflipng）在不降低图像质量的前提下减少PNG文件大小。所有这些工具都能保留图像质量的情况下减少PNG文件大小。</p>\n<p>pngcrush工具特别有效：这个工具通过迭代png过滤器和zlib参数，使用每种过滤器和参数的组合压缩图像，并选择最小的那个作为最后的输出。</p>\n<p>对于JPEG文件，能使用packJPG压缩JPEG文件。</p>\n<blockquote>\n<p>译注：guetzli是Google最近推出的JPEG编码器，官方宣称相同图片质量时，比libjpeg生成的图片小20-30%。</p>\n</blockquote>\n<h3 id=\"使用WebP文件格式\"><a href=\"#使用WebP文件格式\" class=\"headerlink\" title=\"使用WebP文件格式\"></a>使用WebP文件格式</h3><p>你也能使用WebP文件格式存储图片而不是PNG或者JPEG。WebP格式是有损压缩（像JPEG）且有透明通道（像PNG），且压缩率高于JPEG或PNG。</p>\n<p>使用WebP文件格式也有一些缺点。第一，低于Android 3.2的版本不支持WebP，第二，WebP的解码时间比PNG长。</p>\n<blockquote>\n<p>注意：Google Play的APK的应用启动图标只能使用PNG格式，而不支持其他格式。</p>\n</blockquote>\n<p>在Android Studio中，能将BMP，JPG,PNG或者静态GIF图片转换成WebP格式。更多信息，请看<a href=\"https://developer.android.com/studio/write/convert-webp.html#convert_images_to_webp\" target=\"_blank\" rel=\"external\">Create WebP Images Using Android Studio</a>。</p>\n<h3 id=\"使用向量图\"><a href=\"#使用向量图\" class=\"headerlink\" title=\"使用向量图\"></a>使用向量图</h3><p>你能使用向量图去创建一个分辨率无关的图标。使用向量图能够显著减少APK大小。在Android中向量图是以VectorDrawable对象形式存在的。使用VectorDrawable对象，一个100B的文件能生成一个屏幕大小的清晰图片。</p>\n<p>但是，系统需要很长时间渲染VectorDrawable对象，更大的图片需要更长的时间显示在屏幕上。因此只有小图片才考虑使用向量图。</p>\n<p>更多关于VectorDrawable对象的信息，请看<a href=\"https://developer.android.com/training/material/drawables.html\" target=\"_blank\" rel=\"external\">Working with Drawables</a>。</p>\n<h2 id=\"减少Native和Java代码\"><a href=\"#减少Native和Java代码\" class=\"headerlink\" title=\"减少Native和Java代码\"></a>减少Native和Java代码</h2><p>有许多方法能够减少Java和Native的代码量。</p>\n<h3 id=\"减少不必要的生成代码\"><a href=\"#减少不必要的生成代码\" class=\"headerlink\" title=\"减少不必要的生成代码\"></a>减少不必要的生成代码</h3><p>确保理解任何自动生成的代码。比如，许多protocol buffer工具生成了过多的方法和类，这会让你的应用大小翻倍。</p>\n<h3 id=\"移除枚举\"><a href=\"#移除枚举\" class=\"headerlink\" title=\"移除枚举\"></a>移除枚举</h3><p>一个枚举能让classes.dex文件增加1-1.4K。枚举的加入会快速增加应用体积。我们可以使用<code>@IntDef</code>注解和Proguard代替枚举，它能提供和枚举一样的类型安全转换。</p>\n<h3 id=\"减少Native库的大小\"><a href=\"#减少Native库的大小\" class=\"headerlink\" title=\"减少Native库的大小\"></a>减少Native库的大小</h3><p>如果你的应用使用了Native代码和Android NDK，你也能通过优化代码减少应用体积，这里介绍的两个技巧是删除调试符号和避免抽取Native库。</p>\n<h4 id=\"移除调试符号\"><a href=\"#移除调试符号\" class=\"headerlink\" title=\"移除调试符号\"></a>移除调试符号</h4><p>如果应用在开发中并且仍需要调试，那么我们能理解使用调试符号。使用Android NDK提供的arm-eabi-strip工具，能从Native库中删除不必要的调试符号，之后你再编译release包。</p>\n<h4 id=\"避免抽取Native库\"><a href=\"#避免抽取Native库\" class=\"headerlink\" title=\"避免抽取Native库\"></a>避免抽取Native库</h4><p>在APK中存储未压缩的so文件，并且在Manifest文件的<code>&lt;application&gt;</code>中设置<code>android:extractNativeLibs</code>为false，这会防止在安装时PackageManager将APK中的so文件拷贝到文件系统，避免这种拷贝会让应用在做增量更新时的更新包更小。</p>\n<h2 id=\"维持多个小的APK包\"><a href=\"#维持多个小的APK包\" class=\"headerlink\" title=\"维持多个小的APK包\"></a>维持多个小的APK包</h2><p>你的APK会包含用户下载了但从未使用的内容，比如地区或语言信息（译注：比如我是中国人，我就不会用到其他语种的资源）。为了给用户创建小的下载包，你能把你的应用拆分成多个APK，这些APK的差别在于一些因素（比如屏幕大小或者GPU纹理支持）。</p>\n<p>当一个用户下载了应用，设备根据自身的特性和设置获取正确的APK。这种方式能够让设备不获取设备不需要的资源。比如，如果设备是hdpi的，那么他就不需要xxxhdpi的资源。</p>\n<p>更多信息请看<a href=\"https://developer.android.com/studio/build/configure-apk-splits.html\" target=\"_blank\" rel=\"external\">Configure APK Splits</a>和<a href=\"https://developer.android.com/training/multiple-apks/index.html\" target=\"_blank\" rel=\"external\">Maintaining Multiple APKs</a>。</p>\n","categories":[],"tags":["Android"]},{"title":"使用APK Analyzer分析你的APK","url":"http://xiazdong.github.io/2017/03/20/android-use-apk-analyzer/","content":"<p>本文转载于Bugly。</p>\n<blockquote>\n<p>本文是对 <a href=\"https://developer.android.com/studio/build/apk-analyzer.html\" target=\"_blank\" rel=\"external\">Analyze Your Build with APK Analyzer</a> 的翻译。</p>\n</blockquote>\n<p>Android Studio 2.2包含了APK Analyzer，通过它我们能够直观地看到APK的组成。使用APK Analyzer不仅能够减少你花在debug上的时间，而且还能减少你的APK大小。使用APK Analyzer，你能够实现：</p>\n<ul>\n<li>查看APK中文件的绝对大小和相对大小。（译注：相对大小指的是该文件占整个APK大小的百分比）</li>\n<li>理解DEX文件的组成。（译注：能看到DEX文件中包含了哪些类）</li>\n<li>快速查看APK中文件的最终版本（比如AndroidManifest.xml）。（译注：AndroidManifest.xml、resources.arsc本来是二进制形式显示的，APK Analyzer能够解析并显示这些文件的内容）</li>\n<li>对比两个APK。（译注：新版APK和旧版APK之间文件大小的差异）</li>\n</ul>\n<p>这里有3种方法访问APK Analyzer：</p>\n<ul>\n<li>拖拽APK到Android Studio的编辑窗口。</li>\n<li>切换到Project视图，并且双击APK文件。</li>\n<li>在菜单栏中选择Build &gt; Analyzer APK，并且选择APK。</li>\n</ul>\n<p>视频：<a href=\"https://www.youtube.com/watch?v=ZiP3BGVpE9E\" target=\"_blank\" rel=\"external\">https://www.youtube.com/watch?v=ZiP3BGVpE9E</a></p>\n<p>注意：当使用APK Analyzer分析debug的APK，请使用Build &gt; Build APK生成的APK。点击Run将会生成Instant Run的APK。APK Analyzer不能分析通过Instant Run生成的APK，判断APK是否是Intant Run生成的可以通过看APK中是否有instant-run.zip文件。</p>\n<blockquote>\n<p>译注：APK Analyzer是让我们更有效地制定减包方案的实用工具，它能够让我们发现使得APK变大的元凶。</p>\n</blockquote>\n<h2 id=\"查看文件和大小信息\"><a href=\"#查看文件和大小信息\" class=\"headerlink\" title=\"查看文件和大小信息\"></a>查看文件和大小信息</h2><p>APK就是一个zip包。APK Analyzer显示每个文件或目录作为一个实体，实体的层级说明了APK文件的结构。</p>\n<p>如图1，APK Analyzer对每个实体显示了raw file size和download file size。Raw File Size表示实体在磁盘中解压后的大小，而Download Size表示实体在Google Play中压缩后的大小。% of Total Download Size表示实体的download size占APK总的download size的百分比。</p>\n<blockquote>\n<p>译注：图1中，最上面的5.8M是指APK在磁盘中的大小，而4.9M是指从Google Play中下载的大小。</p>\n</blockquote>\n<p><img src=\"https://developer.android.com/studio/images/build/apk-file-sizes_2x.png\" alt=\"\"></p>\n<p>图1：在APK Analyzer中的文件大小</p>\n<blockquote>\n<p>译注：通过查看各个目录或文件的大小，我们能发现APK中哪个区域的文件太大了，比如如果dex太大，我们是不是引入了重复功能的第三方库（比如Glide和Fresco），或者抽取出一个精简的第三方库（精简ffmpeg库）；如果res目录太大，我们可以看看哪些图片过大了，需要通过tinypng压缩，或者用webp代替。</p>\n</blockquote>\n<h2 id=\"查看AndroidManifest-xml\"><a href=\"#查看AndroidManifest-xml\" class=\"headerlink\" title=\"查看AndroidManifest.xml\"></a>查看AndroidManifest.xml</h2><p>如果项目中包含了多个AndroidManifest.xml或者包含提供manifest文件的library，在APK中他们将被合并为一个manifest文件。在APK中manifest文件是普通的二进制文件，但是在APK Analyzer中查看manifest文件，该文件是以XML形式显示的。这种显示形式让我们能理解应用中的任何变化。比如，你能看到library中的AndroidManifest.xml是怎么合入最后的AndroidManifest.xml的。</p>\n<p>另外，这种显示形式提供了lint的能力，会在右上角显示警告、错误提示。图5显示了manifest文件的错误提示。</p>\n<p><img src=\"https://developer.android.com/studio/images/build/apk-manifest-error_2x.png\" alt=\"\"></p>\n<p>图5：manifest文件的一个错误。</p>\n<h2 id=\"查看代码和资源实体\"><a href=\"#查看代码和资源实体\" class=\"headerlink\" title=\"查看代码和资源实体\"></a>查看代码和资源实体</h2><p>不同的构建任务会改变APK文件最后的实体。比如混淆压缩规则能改变你最后的代码和图片资源。在APK Analyzer中能够快速查看文件的最终版本：点击实体，就能在下面看到文件的内容，包含文字和图片实体的预览。</p>\n<p><img src=\"https://developer.android.com/studio/images/build/apk-image-preview_2x.png\" alt=\"\"></p>\n<p>图2：最终图片资源的预览。</p>\n<p>APK Analyzer也能展示文本或二进制文件。比如点击resources.arsc能够让你看到针对配置特定的值（例如一个字符串资源的特定语言的翻译）。如图3，你能看到每个字符串资源的翻译。</p>\n<p><img src=\"https://developer.android.com/studio/images/build/apk-strings_2x.png\" alt=\"\"></p>\n<p>图3：翻译的字符串资源预览</p>\n<h2 id=\"查看DEX文件\"><a href=\"#查看DEX文件\" class=\"headerlink\" title=\"查看DEX文件\"></a>查看DEX文件</h2><p>APK Analyzer的DEX文件浏览器让你能够快速了解DEX文件的信息。我们能看到类、包、总的引用和声明个数，这些信息能够帮助我们决定是否使用multi-dex或者移除依赖使得满足64K方法数限制。</p>\n<p>图4展示了一个中等大小的APP（方法数接近64K）。每个包、类、方法都列有Defined Method和Referenced Method。Referenced Method列是DEX文件中引用的全部方法，它包含了你定义的方法、依赖的library、定义在标准Java和Android包中的方法。Defined Method列只包含了定义在DEX文件中方法，因此它是Referenced Method方法的子集。注意当你引入一个依赖，在依赖中定义的方法会包含在Defined Method和Referenced Method中。还要注意，混淆压缩也会改变DEX文件的内容。</p>\n<p><img src=\"https://developer.android.com/studio/images/build/apk-multidex_2x.png\" alt=\"\"></p>\n<p>图4：一个使用了multi-dex的应用。</p>\n<h2 id=\"比较APK文件\"><a href=\"#比较APK文件\" class=\"headerlink\" title=\"比较APK文件\"></a>比较APK文件</h2><p>APK Analyzer能比较两个不同APK中各个实体的大小。这对于我们了解为何你的APP相比上个版本变大了是很有用的。</p>\n<p>在发布一个新版APK之前，在APK Analyzer中导入你即将发布的APK。在右上角点击Compare With，选择上一个版本的APK，点击OK。然后就会出现类似图6的对话框，允许你比较之间的差别。</p>\n<p>图6显示了一个APP的debug和release包的差别，不同的编译类型会导致实体的不同。</p>\n<blockquote>\n<p>译注：Old Size是先选择的APK，New Size是后选择的APK。</p>\n</blockquote>\n<p><img src=\"https://developer.android.com/studio/images/build/apk-compare_2x.png\" alt=\"\"></p>\n<p>图6：debug和release的APK之间的差别。</p>\n","categories":[],"tags":["Android"]},{"title":"RecyclerView必知必会","url":"http://xiazdong.github.io/2017/02/01/android-recyclerview/","content":"<p>本文转载于<a href=\"http://mp.weixin.qq.com/s/CzrKotyupXbYY6EY2HP_dA\" target=\"_blank\" rel=\"external\">Bugly</a>公众号。</p>\n<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>下文中Demo的源代码地址：<a href=\"https://github.com/xiazdong/RecyclerViewDemo\" target=\"_blank\" rel=\"external\">RecyclerViewDemo</a>。</p>\n<ul>\n<li>Demo1: RecyclerView添加HeaderView和FooterView，ItemDecoration范例。</li>\n<li>Demo2: ListView实现局部刷新。</li>\n<li>Demo3: RecyclerView实现拖拽、侧滑删除。</li>\n<li>Demo4: RecyclerView闪屏问题。</li>\n<li>Demo5: RecyclerView实现<code>setEmptyView()</code>。</li>\n<li>Demo6: RecyclerView实现万能适配器，瀑布流布局，嵌套滑动机制。</li>\n</ul>\n<h2 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h2><p>RecyclerView是Android 5.0提出的新UI控件，位于support-v7包中，可以通过在build.gradle中添加<code>compile &#39;com.android.support:recyclerview-v7:24.2.1&#39;</code>导入。</p>\n<p>RecyclerView的官方定义如下：</p>\n<blockquote>\n<p>A flexible view for providing a limited window into a large data set.</p>\n</blockquote>\n<p>从定义可以看出，flexible（可扩展性）是RecyclerView的特点。不过我们发现和ListView有点像，本文后面会介绍RecyclerView和ListView的区别。</p>\n<h2 id=\"为什么会出现RecyclerView？\"><a href=\"#为什么会出现RecyclerView？\" class=\"headerlink\" title=\"为什么会出现RecyclerView？\"></a>为什么会出现RecyclerView？</h2><p>RecyclerView并不会完全替代ListView（这点从ListView没有被标记为@Deprecated可以看出），两者的使用场景不一样。但是RecyclerView的出现会让很多开源项目被废弃，例如<a href=\"https://github.com/MeetMe/Android-HorizontalListView\" target=\"_blank\" rel=\"external\">横向滚动的ListView</a>, <a href=\"https://github.com/jess-anders/two-way-gridview\" target=\"_blank\" rel=\"external\">横向滚动的GridView</a>, <a href=\"https://github.com/maurycyw/StaggeredGridView\" target=\"_blank\" rel=\"external\">瀑布流控件</a>，因为RecyclerView能够实现所有这些功能。</p>\n<p>比如有一个需求是屏幕竖着的时候的显示形式是ListView，屏幕横着的时候的显示形式是2列的GridView，此时如果用RecyclerView，则通过设置LayoutManager一行代码实现替换。</p>\n<h2 id=\"ListView-vs-RecyclerView\"><a href=\"#ListView-vs-RecyclerView\" class=\"headerlink\" title=\"ListView vs RecyclerView\"></a>ListView vs RecyclerView</h2><p>ListView相比RecyclerView，有一些优点：</p>\n<ul>\n<li><code>addHeaderView()</code>, <code>addFooterView()</code>添加头视图和尾视图。</li>\n<li>通过”android:divider”设置自定义分割线。</li>\n<li><code>setOnItemClickListener()</code>和<code>setOnItemLongClickListener()</code>设置点击事件和长按事件。</li>\n</ul>\n<p>这些功能在RecyclerView中都没有直接的接口，要自己实现（虽然实现起来很简单），因此如果只是实现简单的显示功能，ListView无疑更简单。</p>\n<p>RecyclerView相比ListView，有一些明显的优点：</p>\n<ul>\n<li>默认已经实现了View的复用，不需要类似<code>if(convertView == null)</code>的实现，而且回收机制更加完善。</li>\n<li>默认支持局部刷新。</li>\n<li>容易实现添加item、删除item的动画效果。</li>\n<li>容易实现拖拽、侧滑删除等功能。</li>\n</ul>\n<p>RecyclerView是一个插件式的实现，对各个功能进行解耦，从而扩展性比较好。</p>\n<h2 id=\"ListView实现局部刷新\"><a href=\"#ListView实现局部刷新\" class=\"headerlink\" title=\"ListView实现局部刷新\"></a>ListView实现局部刷新</h2><p>我们都知道ListView通过<code>adapter.notifyDataSetChanged()</code>实现ListView的更新，这种更新方法的缺点是全局更新，即对每个Item View都进行重绘。但事实上很多时候，我们只是更新了其中一个Item的数据，其他Item其实可以不需要重绘。</p>\n<p>这里给出ListView实现局部更新的方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">updateItemView</span><span class=\"params\">(ListView listview, <span class=\"keyword\">int</span> position, Data data)</span></span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> firstPos = listview.getFirstVisiblePosition();</div><div class=\"line\">    <span class=\"keyword\">int</span> lastPos = listview.getLastVisiblePosition();</div><div class=\"line\">    <span class=\"keyword\">if</span>(position &gt;= firstPos &amp;&amp; position &lt;= lastPos)&#123;  <span class=\"comment\">//可见才更新，不可见则在getView()时更新</span></div><div class=\"line\">\t\t<span class=\"comment\">//listview.getChildAt(i)获得的是当前可见的第i个item的view</span></div><div class=\"line\">        View view = listview.getChildAt(position - firstPos);</div><div class=\"line\">        VH vh = (VH)view.getTag();</div><div class=\"line\">        vh.text.setText(data.text);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>可以看出，我们通过ListView的<code>getChildAt()</code>来获得需要更新的View，然后通过<code>getTag()</code>获得ViewHolder，从而实现更新。</p>\n<h2 id=\"标准用法\"><a href=\"#标准用法\" class=\"headerlink\" title=\"标准用法\"></a>标准用法</h2><p>RecyclerView的标准实现步骤如下：</p>\n<ul>\n<li>创建Adapter：创建一个继承<code>RecyclerView.Adapter&lt;VH&gt;</code>的Adapter类（VH是ViewHolder的类名），记为NormalAdapter。</li>\n<li>创建ViewHolder：在NormalAdapter中创建一个继承<code>RecyclerView.ViewHolder</code>的静态内部类，记为VH。ViewHolder的实现和ListView的ViewHolder实现几乎一样。</li>\n<li>在NormalAdapter中实现：<ul>\n<li><code>VH onCreateViewHolder(ViewGroup parent, int viewType)</code>: 映射Item Layout Id，创建VH并返回。</li>\n<li><code>void onBindViewHolder(VH holder, int position)</code>: 为holder设置指定数据。</li>\n<li><code>int getItemCount()</code>: 返回Item的个数。</li>\n</ul>\n</li>\n</ul>\n<p>可以看出，RecyclerView将ListView中<code>getView()</code>的功能拆分成了<code>onCreateViewHolder()</code>和<code>onBindViewHolder()</code>。</p>\n<p>基本的Adapter实现如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">NormalAdapter</span> <span class=\"keyword\">extends</span> <span class=\"title\">RecyclerView</span>.<span class=\"title\">Adapter</span>&lt;<span class=\"title\">NormalAdapter</span>.<span class=\"title\">VH</span>&gt;</span>&#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">private</span> List&lt;String&gt; mDatas;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">NormalAdapter</span><span class=\"params\">(List&lt;String&gt; data)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.mDatas = data;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onBindViewHolder</span><span class=\"params\">(VH holder, <span class=\"keyword\">int</span> position)</span> </span>&#123;</div><div class=\"line\">        holder.title.setText(mDatas.get(position));</div><div class=\"line\">        holder.itemView.setOnClickListener(<span class=\"keyword\">new</span> View.OnClickListener() &#123;</div><div class=\"line\">            <span class=\"meta\">@Override</span></div><div class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onClick</span><span class=\"params\">(View v)</span> </span>&#123;</div><div class=\"line\">                <span class=\"comment\">//item 点击事件</span></div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getItemCount</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> mDatas.size();</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> VH <span class=\"title\">onCreateViewHolder</span><span class=\"params\">(ViewGroup parent, <span class=\"keyword\">int</span> viewType)</span> </span>&#123;</div><div class=\"line\">        View v = LayoutInflater.from(parent.getContext()).inflate(R.layout.item_1, parent, <span class=\"keyword\">false</span>);</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> VH(v);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">VH</span> <span class=\"keyword\">extends</span> <span class=\"title\">RecyclerView</span>.<span class=\"title\">ViewHolder</span></span>&#123;</div><div class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">final</span> TextView title;</div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">VH</span><span class=\"params\">(View v)</span> </span>&#123;</div><div class=\"line\">            <span class=\"keyword\">super</span>(v);</div><div class=\"line\">            title = (TextView) v.findViewById(R.id.title);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>创建完Adapter，接着对RecyclerView进行设置，一般来说，需要为RecyclerView进行四大设置，也就是后文说的四大组成：Adapter(必选),Layout Manager(必选),Item Decoration(可选，默认为空), Item Animator(可选，默认为DefaultItemAnimator)。</p>\n<p>需要注意的是在<code>onCreateViewHolder()</code>中，映射Layout必须为</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">View v = LayoutInflater.from(parent.getContext()).inflate(R.layout.item_1, parent, <span class=\"keyword\">false</span>);</div></pre></td></tr></table></figure>\n<p>而不能是：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">View v = LayoutInflater.from(parent.getContext()).inflate(R.layout.item_1, <span class=\"keyword\">null</span>);</div></pre></td></tr></table></figure>\n<p>如果要实现ListView的效果，只需要设置Adapter和Layout Manager，如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">List&lt;String&gt; data = initData();</div><div class=\"line\">RecyclerView rv = (RecyclerView) findViewById(R.id.rv);</div><div class=\"line\">rv.setLayoutManager(<span class=\"keyword\">new</span> LinearLayoutManager(<span class=\"keyword\">this</span>));</div><div class=\"line\">rv.setAdapter(<span class=\"keyword\">new</span> NormalAdapter(data));</div></pre></td></tr></table></figure>\n<p>ListView只提供了<code>notifyDataSetChanged()</code>更新整个视图，这是很不合理的。RecyclerView提供了<code>notifyItemInserted()</code>,<code>notifyItemRemoved()</code>,<code>notifyItemChanged()</code>等API更新单个或某个范围的Item视图。</p>\n<h2 id=\"四大组成\"><a href=\"#四大组成\" class=\"headerlink\" title=\"四大组成\"></a>四大组成</h2><p>RecyclerView的四大组成是：</p>\n<ul>\n<li>Adapter：为Item提供数据。</li>\n<li>Layout Manager：Item的布局。</li>\n<li>Item Animator：添加、删除Item动画。</li>\n<li>Item Decoration：Item之间的Divider。</li>\n</ul>\n<h3 id=\"Adapter\"><a href=\"#Adapter\" class=\"headerlink\" title=\"Adapter\"></a>Adapter</h3><p>Adapter的使用方式前面已经介绍了，功能就是为RecyclerView提供数据，这里主要介绍万能适配器的实现。其实万能适配器的概念在ListView就已经存在了，即<a href=\"https://github.com/JoanZapata/base-adapter-helper\" target=\"_blank\" rel=\"external\">base-adapter-helper</a>。</p>\n<p>这里我们只针对RecyclerView，聊聊万能适配器出现的原因。为了创建一个RecyclerView的Adapter，每次我们都需要去做重复劳动，包括重写<code>onCreateViewHolder()</code>,<code>getItemCount()</code>、创建ViewHolder，并且实现过程大同小异，因此万能适配器出现了，他能通过以下方式快捷地创建一个Adapter：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">mAdapter = <span class=\"keyword\">new</span> QuickAdapter&lt;String&gt;(data) &#123;</div><div class=\"line\">\t<span class=\"meta\">@Override</span></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getLayoutId</span><span class=\"params\">(<span class=\"keyword\">int</span> viewType)</span> </span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">return</span> R.layout.item;</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"meta\">@Override</span></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">convert</span><span class=\"params\">(VH holder, String data, <span class=\"keyword\">int</span> position)</span> </span>&#123;</div><div class=\"line\">\t\tholder.setText(R.id.text, data);</div><div class=\"line\">\t\t<span class=\"comment\">//holder.itemView.setOnClickListener(); 此处还可以添加点击事件</span></div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>是不是很方便。当然复杂情况也可以轻松解决。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">mAdapter = <span class=\"keyword\">new</span> QuickAdapter&lt;Model&gt;(data) &#123;</div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getLayoutId</span><span class=\"params\">(<span class=\"keyword\">int</span> viewType)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">switch</span>(viewType)&#123;</div><div class=\"line\">            <span class=\"keyword\">case</span> TYPE_1:</div><div class=\"line\">                <span class=\"keyword\">return</span> R.layout.item_1;</div><div class=\"line\">            <span class=\"keyword\">case</span> TYPE_2:</div><div class=\"line\">                <span class=\"keyword\">return</span> R.layout.item_2;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getItemViewType</span><span class=\"params\">(<span class=\"keyword\">int</span> position)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">if</span>(position % <span class=\"number\">2</span> == <span class=\"number\">0</span>)&#123;</div><div class=\"line\">            <span class=\"keyword\">return</span> TYPE_1;</div><div class=\"line\">        &#125; <span class=\"keyword\">else</span>&#123;</div><div class=\"line\">            <span class=\"keyword\">return</span> TYPE_2;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">convert</span><span class=\"params\">(VH holder, Model data, <span class=\"keyword\">int</span> position)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">int</span> type = getItemViewType(position);</div><div class=\"line\">        <span class=\"keyword\">switch</span>(type)&#123;</div><div class=\"line\">            <span class=\"keyword\">case</span> TYPE_1:</div><div class=\"line\">                holder.setText(R.id.text, data.text);</div><div class=\"line\">                <span class=\"keyword\">break</span>;</div><div class=\"line\">            <span class=\"keyword\">case</span> TYPE_2:</div><div class=\"line\">                holder.setImage(R.id.image, data.image);</div><div class=\"line\">                <span class=\"keyword\">break</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>这里讲解下万能适配器的实现思路。</p>\n<p>我们通过<code>public abstract class QuickAdapter&lt;T&gt; extends RecyclerView.Adapter&lt;QuickAdapter.VH&gt;</code>定义万能适配器QuickAdapter类，T是列表数据中每个元素的类型，QuickAdapter.VH是QuickAdapter的ViewHolder实现类，称为万能ViewHolder。</p>\n<p>首先介绍QuickAdapter.VH的实现：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">VH</span> <span class=\"keyword\">extends</span> <span class=\"title\">RecyclerView</span>.<span class=\"title\">ViewHolder</span></span>&#123;</div><div class=\"line\">    <span class=\"keyword\">private</span> SparseArray&lt;View&gt; mViews;</div><div class=\"line\">    <span class=\"keyword\">private</span> View mConvertView;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">VH</span><span class=\"params\">(View v)</span></span>&#123;</div><div class=\"line\">        <span class=\"keyword\">super</span>(v);</div><div class=\"line\">        mConvertView = v;</div><div class=\"line\">        mViews = <span class=\"keyword\">new</span> SparseArray&lt;&gt;();</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> VH <span class=\"title\">get</span><span class=\"params\">(ViewGroup parent, <span class=\"keyword\">int</span> layoutId)</span></span>&#123;</div><div class=\"line\">        View convertView = LayoutInflater.from(parent.getContext()).inflate(layoutId, parent, <span class=\"keyword\">false</span>);</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> VH(convertView);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">public</span> &lt;T extends View&gt; <span class=\"function\">T <span class=\"title\">getView</span><span class=\"params\">(<span class=\"keyword\">int</span> id)</span></span>&#123;</div><div class=\"line\">        View v = mViews.get(id);</div><div class=\"line\">        <span class=\"keyword\">if</span>(v == <span class=\"keyword\">null</span>)&#123;</div><div class=\"line\">            v = mConvertView.findViewById(id);</div><div class=\"line\">            mViews.put(id, v);</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">return</span> (T)v;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setText</span><span class=\"params\">(<span class=\"keyword\">int</span> id, String value)</span></span>&#123;</div><div class=\"line\">        TextView view = getView(id);</div><div class=\"line\">        view.setText(value);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>其中的关键点在于通过<code>SparseArray&lt;View&gt;</code>存储item view的控件，<code>getView(int id)</code>的功能就是通过id获得对应的View（首先在mViews中查询是否存在，如果没有，那么<code>findViewById()</code>并放入mViews中，避免下次再执行<code>findViewById()</code>）。</p>\n<p>QuickAdapter的实现如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">QuickAdapter</span>&lt;<span class=\"title\">T</span>&gt; <span class=\"keyword\">extends</span> <span class=\"title\">RecyclerView</span>.<span class=\"title\">Adapter</span>&lt;<span class=\"title\">QuickAdapter</span>.<span class=\"title\">VH</span>&gt;</span>&#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">private</span> List&lt;T&gt; mDatas;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">QuickAdapter</span><span class=\"params\">(List&lt;T&gt; datas)</span></span>&#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.mDatas = datas;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">int</span> <span class=\"title\">getLayoutId</span><span class=\"params\">(<span class=\"keyword\">int</span> viewType)</span></span>;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> VH <span class=\"title\">onCreateViewHolder</span><span class=\"params\">(ViewGroup parent, <span class=\"keyword\">int</span> viewType)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> VH.get(parent,getLayoutId(viewType));</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onBindViewHolder</span><span class=\"params\">(VH holder, <span class=\"keyword\">int</span> position)</span> </span>&#123;</div><div class=\"line\">        convert(holder, mDatas.get(position), position);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getItemCount</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> mDatas.size();</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title\">convert</span><span class=\"params\">(VH holder, T data, <span class=\"keyword\">int</span> position)</span></span>;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">VH</span> <span class=\"keyword\">extends</span> <span class=\"title\">RecyclerView</span>.<span class=\"title\">ViewHolder</span></span>&#123;...&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>其中：</p>\n<ul>\n<li><code>getLayoutId(int viewType)</code>是根据viewType返回布局ID。</li>\n<li><code>convert()</code>做具体的bind操作。</li>\n</ul>\n<p>就这样，万能适配器实现完成了。</p>\n<h3 id=\"Item-Decoration\"><a href=\"#Item-Decoration\" class=\"headerlink\" title=\"Item Decoration\"></a>Item Decoration</h3><p>RecyclerView通过<code>addItemDecoration()</code>方法添加item之间的分割线。Android并没有提供实现好的Divider，因此任何分割线样式都需要自己实现。</p>\n<p>方法是：创建一个类并继承RecyclerView.ItemDecoration，重写以下两个方法：</p>\n<ul>\n<li>onDraw(): 绘制分割线。</li>\n<li>getItemOffsets(): 设置分割线的宽、高。</li>\n</ul>\n<p>Google在sample中给了一个参考的实现类：<a href=\"https://android.googlesource.com/platform/development/%2B/master/samples/Support7Demos/src/com/example/android/supportv7/widget/decorator/DividerItemDecoration.java\" target=\"_blank\" rel=\"external\">DividerItemDecoration</a>，这里我们通过分析这个例子来看如何自定义Item Decoration。</p>\n<p>首先看构造函数，构造函数中获得系统属性<code>android:listDivider</code>，该属性是一个Drawable对象。</p>\n<p>因此如果要设置，则需要在value/styles.xml中设置：</p>\n<figure class=\"highlight\"><table><tr><td class=\"code\"><pre><div class=\"line\">&lt;style name=\"AppTheme\" parent=\"Theme.AppCompat.Light.DarkActionBar\"&gt;</div><div class=\"line\">    &lt;item name=\"android:listDivider\"&gt;@drawable/item_divider&lt;/item&gt;</div><div class=\"line\">&lt;/style&gt;</div></pre></td></tr></table></figure>\n<p>接着来看<code>getItemOffsets()</code>的实现：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">getItemOffsets</span><span class=\"params\">(Rect outRect, <span class=\"keyword\">int</span> position, RecyclerView parent)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (mOrientation == VERTICAL_LIST) &#123;</div><div class=\"line\">        outRect.set(<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, mDivider.getIntrinsicHeight());</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">        outRect.set(<span class=\"number\">0</span>, <span class=\"number\">0</span>, mDivider.getIntrinsicWidth(), <span class=\"number\">0</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这里只看<code>mOrientation == VERTICAL_LIST</code>的情况，outRect是当前item四周的间距，类似margin属性，现在设置了该item下间距为<code>mDivider.getIntrinsicHeight()</code>。</p>\n<p>那么<code>getItemOffsets()</code>是怎么被调用的呢？</p>\n<p>RecyclerView继承了ViewGroup，并重写了<code>measureChild()</code>，该方法在<code>onMeasure()</code>中被调用，用来计算每个child的大小，计算每个child大小的时候就需要加上<code>getItemOffsets()</code>设置的外间距：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">measureChild</span><span class=\"params\">(View child, <span class=\"keyword\">int</span> widthUsed, <span class=\"keyword\">int</span> heightUsed)</span></span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">final</span> Rect insets = mRecyclerView.getItemDecorInsetsForChild(child);<span class=\"comment\">//调用getItemOffsets()获得Rect对象</span></div><div class=\"line\">\twidthUsed += insets.left + insets.right;</div><div class=\"line\">    heightUsed += insets.top + insets.bottom;</div><div class=\"line\">    <span class=\"comment\">//...</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这里我们只考虑<code>mOrientation == VERTICAL_LIST</code>的情况，DividerItemDecoration的<code>onDraw()</code>实际上调用了<code>drawVertical()</code>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">drawVertical</span><span class=\"params\">(Canvas c, RecyclerView parent)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> left = parent.getPaddingLeft();</div><div class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> right = parent.getWidth() - parent.getPaddingRight();</div><div class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> childCount = parent.getChildCount();</div><div class=\"line\">    <span class=\"comment\">/**</span></div><div class=\"line\">     * 画每个item的分割线</div><div class=\"line\">     */</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; childCount; i++) &#123;</div><div class=\"line\">        <span class=\"keyword\">final</span> View child = parent.getChildAt(i);</div><div class=\"line\">        <span class=\"keyword\">final</span> RecyclerView.LayoutParams params = (RecyclerView.LayoutParams) child</div><div class=\"line\">                .getLayoutParams();</div><div class=\"line\">        <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> top = child.getBottom() + params.bottomMargin + Math.round(ViewCompat.getTranslationY(child));</div><div class=\"line\">        <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> bottom = top + mDivider.getIntrinsicHeight();</div><div class=\"line\">        mDivider.setBounds(left, top, right, bottom);<span class=\"comment\">/*规定好左上角和右下角*/</span></div><div class=\"line\">        mDivider.draw(c);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>那么<code>onDraw()</code>是怎么被调用的呢？还有ItemDecoration还有一个方法<code>onDrawOver()</code>，该方法也可以被重写，那么<code>onDraw()</code>和<code>onDrawOver()</code>之间有什么关系呢？</p>\n<p>我们来看下面的代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RecyclerView</span> <span class=\"keyword\">extends</span> <span class=\"title\">ViewGroup</span></span>&#123;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">draw</span><span class=\"params\">(Canvas c)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">super</span>.draw(c); <span class=\"comment\">//调用View的draw()，该方法会先调用onDraw()，再调用dispatchDraw()绘制children</span></div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> count = mItemDecorations.size();</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; count; i++) &#123;</div><div class=\"line\">            mItemDecorations.get(i).onDrawOver(c, <span class=\"keyword\">this</span>, mState);</div><div class=\"line\">        &#125;</div><div class=\"line\">        ...</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onDraw</span><span class=\"params\">(Canvas c)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">super</span>.onDraw(c);</div><div class=\"line\">        <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> count = mItemDecorations.size();</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; count; i++) &#123;</div><div class=\"line\">            mItemDecorations.get(i).onDraw(c, <span class=\"keyword\">this</span>, mState);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>根据<a href=\"http://a.codekk.com/detail/Android/lightSky/%E5%85%AC%E5%85%B1%E6%8A%80%E6%9C%AF%E7%82%B9%E4%B9%8B%20View%20%E7%BB%98%E5%88%B6%E6%B5%81%E7%A8%8B\" target=\"_blank\" rel=\"external\">View的绘制流程</a>，首先调用RecyclerView重写的<code>draw()</code>方法，随后<code>super.draw()</code>即调用View的<code>draw()</code>，该方法会先调用<code>onDraw()</code>（这个方法在RecyclerView重写了），再调用<code>dispatchDraw()</code>绘制children。因此：ItemDecoration的<code>onDraw()</code>在绘制Item之前调用，ItemDecoration的<code>onDrawOver()</code>在绘制Item之后调用。</p>\n<p>当然，如果只需要实现Item之间相隔一定距离，那么只需要为Item的布局设置margin即可，没必要自己实现ItemDecoration这么麻烦。</p>\n<h3 id=\"Layout-Manager\"><a href=\"#Layout-Manager\" class=\"headerlink\" title=\"Layout Manager\"></a>Layout Manager</h3><p>LayoutManager负责RecyclerView的布局，其中包含了Item View的获取与回收。这里我们简单分析LinearLayoutManager的实现。</p>\n<p>对于LinearLayoutManager来说，比较重要的几个方法有：</p>\n<ul>\n<li><code>onLayoutChildren()</code>: 对RecyclerView进行布局的入口方法。</li>\n<li><code>fill()</code>: 负责填充RecyclerView。</li>\n<li><code>scrollVerticallyBy()</code>:根据手指的移动滑动一定距离，并调用<code>fill()</code>填充。</li>\n<li><code>canScrollVertically()</code>或<code>canScrollHorizontally()</code>: 判断是否支持纵向滑动或横向滑动。</li>\n</ul>\n<p><code>onLayoutChildren()</code>的核心实现如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onLayoutChildren</span><span class=\"params\">(RecyclerView.Recycler recycler, RecyclerView.State state)</span> </span>&#123;</div><div class=\"line\">\tdetachAndScrapAttachedViews(recycler); <span class=\"comment\">//将原来所有的Item View全部放到Recycler的Scrap Heap或Recycle Pool</span></div><div class=\"line\">\tfill(recycler, mLayoutState, state, <span class=\"keyword\">false</span>); <span class=\"comment\">//填充现在所有的Item View</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>RecyclerView的回收机制有个重要的概念，即将回收站分为Scrap Heap和Recycle Pool，其中Scrap Heap的元素可以被直接复用，而不需要调用<code>onBindViewHolder()</code>。<code>detachAndScrapAttachedViews()</code>会根据情况，将原来的Item View放入Scrap Heap或Recycle Pool，从而在复用时提升效率。</p>\n<p><code>fill()</code>是对剩余空间不断地调用<code>layoutChunk()</code>，直到填充完为止。<code>layoutChunk()</code>的核心实现如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">layoutChunk</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\tView view = layoutState.next(recycler); <span class=\"comment\">//调用了getViewForPosition()</span></div><div class=\"line\">\taddView(view);  <span class=\"comment\">//加入View</span></div><div class=\"line\">\tmeasureChildWithMargins(view, <span class=\"number\">0</span>, <span class=\"number\">0</span>); <span class=\"comment\">//计算View的大小</span></div><div class=\"line\">\tlayoutDecoratedWithMargins(view, left, top, right, bottom); <span class=\"comment\">//布局View</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>其中<code>next()</code>调用了<code>getViewForPosition(currentPosition)</code>，该方法是从RecyclerView的回收机制实现类Recycler中获取合适的View，在后文的回收机制中会介绍该方法的具体实现。</p>\n<p>如果要自定义LayoutManager，可以参考：</p>\n<ul>\n<li><a href=\"https://github.com/hehonghui/android-tech-frontier/blob/master/issue-9/%E5%88%9B%E5%BB%BA-RecyclerView-LayoutManager-Part-1.md\" target=\"_blank\" rel=\"external\">创建一个 RecyclerView LayoutManager – Part 1</a></li>\n<li><a href=\"https://github.com/hehonghui/android-tech-frontier/blob/master/issue-13/%E5%88%9B%E5%BB%BA-RecyclerView-LayoutManager-Part-2.md\" target=\"_blank\" rel=\"external\">创建一个 RecyclerView LayoutManager – Part 2</a></li>\n<li><a href=\"https://github.com/hehonghui/android-tech-frontier/blob/master/issue-13/%E5%88%9B%E5%BB%BA-RecyclerView-LayoutManager-Part-3.md\" target=\"_blank\" rel=\"external\">创建一个 RecyclerView LayoutManager – Part 3</a></li>\n</ul>\n<h3 id=\"Item-Animator\"><a href=\"#Item-Animator\" class=\"headerlink\" title=\"Item Animator\"></a>Item Animator</h3><p>RecyclerView能够通过<code>mRecyclerView.setItemAnimator(ItemAnimator animator)</code>设置添加、删除、移动、改变的动画效果。RecyclerView提供了默认的ItemAnimator实现类：DefaultItemAnimator。这里我们通过分析DefaultItemAnimator的源码来介绍如何自定义Item Animator。</p>\n<p>DefaultItemAnimator继承自SimpleItemAnimator，SimpleItemAnimator继承自ItemAnimator。</p>\n<p>首先我们介绍ItemAnimator类的几个重要方法：</p>\n<ul>\n<li><em>animateAppearance()</em>: 当ViewHolder出现在屏幕上时被调用（可能是add或move）。</li>\n<li><em>animateDisappearance()</em>: 当ViewHolder消失在屏幕上时被调用（可能是remove或move）。</li>\n<li><em>animatePersistence()</em>: 在没调用<code>notifyItemChanged()</code>和<code>notifyDataSetChanged()</code>的情况下布局发生改变时被调用。</li>\n<li><em>animateChange()</em>: 在显式调用<code>notifyItemChanged()</code>或<code>notifyDataSetChanged()</code>时被调用。</li>\n<li>runPendingAnimations(): RecyclerView动画的执行方式并不是立即执行，而是每帧执行一次，比如两帧之间添加了多个Item，则会将这些将要执行的动画Pending住，保存在成员变量中，等到下一帧一起执行。该方法执行的前提是前面<code>animateXxx()</code>返回true。</li>\n<li>isRunning(): 是否有动画要执行或正在执行。</li>\n<li>dispatchAnimationsFinished(): 当全部动画执行完毕时被调用。</li>\n</ul>\n<p>上面用斜体字标识的方法比较难懂，不过没关系，因为Android提供了SimpleItemAnimator类（继承自ItemAnimator），该类提供了一系列更易懂的API，在自定义Item Animator时只需要继承SimpleItemAnimator即可：</p>\n<ul>\n<li>animateAdd(ViewHolder holder): 当Item添加时被调用。</li>\n<li>animateMove(ViewHolder holder, int fromX, int fromY, int toX, int toY): 当Item移动时被调用。</li>\n<li>animateRemove(ViewHolder holder): 当Item删除时被调用。</li>\n<li>animateChange(ViewHolder oldHolder, ViewHolder newHolder, int fromLeft, int fromTop, int toLeft, int toTop): 当显式调用<code>notifyItemChanged()</code>或<code>notifyDataSetChanged()</code>时被调用。</li>\n</ul>\n<p>对于以上四个方法，注意两点：</p>\n<ul>\n<li>当Xxx动画开始执行前（在<code>runPendingAnimations()</code>中）需要调用<code>dispatchXxxStarting(holder)</code>，执行完后需要调用<code>dispatchXxxFinished(holder)</code>。</li>\n<li>这些方法的内部实际上并不是书写执行动画的代码，而是将需要执行动画的Item全部存入成员变量中，并且返回值为true，然后在<code>runPendingAnimations()</code>中一并执行。</li>\n</ul>\n<p>DefaultItemAnimator类是RecyclerView提供的默认动画类。我们通过阅读该类源码学习如何自定义Item Animator。我们先看DefaultItemAnimator的成员变量：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">private</span> ArrayList&lt;ViewHolder&gt; mPendingAdditions = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();<span class=\"comment\">//存放下一帧要执行的一系列add动画</span></div><div class=\"line\">ArrayList&lt;ArrayList&lt;ViewHolder&gt;&gt; mAdditionsList = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();<span class=\"comment\">//存放正在执行的一批add动画</span></div><div class=\"line\">ArrayList&lt;ViewHolder&gt; mAddAnimations = <span class=\"keyword\">new</span> ArrayList&lt;&gt;(); <span class=\"comment\">//存放当前正在执行的add动画</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">private</span> ArrayList&lt;ViewHolder&gt; mPendingRemovals = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</div><div class=\"line\">ArrayList&lt;ViewHolder&gt; mRemoveAnimations = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">private</span> ArrayList&lt;MoveInfo&gt; mPendingMoves = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</div><div class=\"line\">ArrayList&lt;ArrayList&lt;MoveInfo&gt;&gt; mMovesList = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</div><div class=\"line\">ArrayList&lt;ViewHolder&gt; mMoveAnimations = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">private</span> ArrayList&lt;ChangeInfo&gt; mPendingChanges = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</div><div class=\"line\">ArrayList&lt;ArrayList&lt;ChangeInfo&gt;&gt; mChangesList = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</div><div class=\"line\">ArrayList&lt;ViewHolder&gt; mChangeAnimations = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</div></pre></td></tr></table></figure>\n<p>DefaultItemAnimator实现了SimpleItemAnimator的<code>animateAdd()</code>方法，该方法只是将该item添加到mPendingAdditions中，等到<code>runPendingAnimations()</code>中执行。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">animateAdd</span><span class=\"params\">(<span class=\"keyword\">final</span> ViewHolder holder)</span> </span>&#123;</div><div class=\"line\">    resetAnimation(holder);  <span class=\"comment\">//重置清空所有动画</span></div><div class=\"line\">    ViewCompat.setAlpha(holder.itemView, <span class=\"number\">0</span>); <span class=\"comment\">//将要做动画的View先变成透明</span></div><div class=\"line\">    mPendingAdditions.add(holder);</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>接着看<code>runPendingAnimations()</code>的实现，该方法是执行remove,move,change,add动画，执行顺序为：remove动画最先执行，随后move和change并行执行，最后是add动画。为了简化，我们将remove,move,change动画执行过程省略，只看执行add动画的过程，如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">runPendingAnimations</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t<span class=\"comment\">//1、判断是否有动画要执行，即各个动画的成员变量里是否有值。</span></div><div class=\"line\">    <span class=\"comment\">//2、执行remove动画</span></div><div class=\"line\">    <span class=\"comment\">//3、执行move动画</span></div><div class=\"line\">    <span class=\"comment\">//4、执行change动画，与move动画并行执行</span></div><div class=\"line\">    <span class=\"comment\">//5、执行add动画</span></div><div class=\"line\">    <span class=\"keyword\">if</span> (additionsPending) &#123;</div><div class=\"line\">        <span class=\"keyword\">final</span> ArrayList&lt;ViewHolder&gt; additions = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</div><div class=\"line\">        additions.addAll(mPendingAdditions);</div><div class=\"line\">        mAdditionsList.add(additions);</div><div class=\"line\">        mPendingAdditions.clear();</div><div class=\"line\">        Runnable adder = <span class=\"keyword\">new</span> Runnable() &#123;</div><div class=\"line\">            <span class=\"meta\">@Override</span></div><div class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">                <span class=\"keyword\">for</span> (ViewHolder holder : additions) &#123;</div><div class=\"line\">                    animateAddImpl(holder);  <span class=\"comment\">/***** 执行动画的方法 *****/</span></div><div class=\"line\">                &#125;</div><div class=\"line\">                additions.clear();</div><div class=\"line\">                mAdditionsList.remove(additions);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;;</div><div class=\"line\">        <span class=\"keyword\">if</span> (removalsPending || movesPending || changesPending) &#123;</div><div class=\"line\">            <span class=\"keyword\">long</span> removeDuration = removalsPending ? getRemoveDuration() : <span class=\"number\">0</span>;</div><div class=\"line\">            <span class=\"keyword\">long</span> moveDuration = movesPending ? getMoveDuration() : <span class=\"number\">0</span>;</div><div class=\"line\">            <span class=\"keyword\">long</span> changeDuration = changesPending ? getChangeDuration() : <span class=\"number\">0</span>;</div><div class=\"line\">            <span class=\"keyword\">long</span> totalDelay = removeDuration + Math.max(moveDuration, changeDuration);</div><div class=\"line\">            View view = additions.get(<span class=\"number\">0</span>).itemView;</div><div class=\"line\">            ViewCompat.postOnAnimationDelayed(view, adder, totalDelay); <span class=\"comment\">//等remove，move，change动画全部做完后，开始执行add动画</span></div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>为了防止在执行add动画时外面有新的add动画添加到mPendingAdditions中，从而导致执行add动画错乱，这里将mPendingAdditions的内容移动到局部变量additions中，然后遍历additions执行动画。</p>\n<p>在<code>runPendingAnimations()</code>中，<code>animateAddImpl()</code>是执行add动画的具体方法，其实就是将itemView的透明度从0变到1（在<code>animateAdd()</code>中已经将view的透明度变为0），实现如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">animateAddImpl</span><span class=\"params\">(<span class=\"keyword\">final</span> ViewHolder holder)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">final</span> View view = holder.itemView;</div><div class=\"line\">    <span class=\"keyword\">final</span> ViewPropertyAnimatorCompat animation = ViewCompat.animate(view);</div><div class=\"line\">    mAddAnimations.add(holder);</div><div class=\"line\">    animation.alpha(<span class=\"number\">1</span>).setDuration(getAddDuration()).</div><div class=\"line\">            setListener(<span class=\"keyword\">new</span> VpaListenerAdapter() &#123;</div><div class=\"line\">                <span class=\"meta\">@Override</span></div><div class=\"line\">                <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onAnimationStart</span><span class=\"params\">(View view)</span> </span>&#123;</div><div class=\"line\">                    dispatchAddStarting(holder);  <span class=\"comment\">//在开始add动画前调用</span></div><div class=\"line\">                &#125;</div><div class=\"line\">                <span class=\"meta\">@Override</span></div><div class=\"line\">                <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onAnimationCancel</span><span class=\"params\">(View view)</span> </span>&#123;</div><div class=\"line\">                    ViewCompat.setAlpha(view, <span class=\"number\">1</span>);</div><div class=\"line\">                &#125;</div><div class=\"line\"></div><div class=\"line\">                <span class=\"meta\">@Override</span></div><div class=\"line\">                <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onAnimationEnd</span><span class=\"params\">(View view)</span> </span>&#123;</div><div class=\"line\">                    animation.setListener(<span class=\"keyword\">null</span>);</div><div class=\"line\">                    dispatchAddFinished(holder); <span class=\"comment\">//在结束add动画后调用</span></div><div class=\"line\">                    mAddAnimations.remove(holder);</div><div class=\"line\">                    <span class=\"keyword\">if</span> (!isRunning()) &#123;</div><div class=\"line\">        \t\t\t\tdispatchAnimationsFinished(); <span class=\"comment\">//结束所有动画后调用</span></div><div class=\"line\">    \t\t\t\t&#125;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;).start();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>从DefaultItemAnimator类的实现来看，发现自定义Item Animator好麻烦，需要继承SimpleItemAnimator类，然后实现一堆方法。别急，<a href=\"https://github.com/wasabeef/recyclerview-animators\" target=\"_blank\" rel=\"external\">recyclerview-animators</a>解救你，原因如下：</p>\n<p>首先，<a href=\"https://github.com/wasabeef/recyclerview-animators\" target=\"_blank\" rel=\"external\">recyclerview-animators</a>提供了一系列的Animator，比如FadeInAnimator,ScaleInAnimator。其次，如果该库中没有你满意的动画，该库提供了BaseItemAnimator类，该类继承自SimpleItemAnimator，进一步封装了自定义Item Animator的代码，使得自定义Item Animator更方便，你只需要关注动画本身。如果要实现DefaultItemAnimator的代码，只需要以下实现：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DefaultItemAnimator</span> <span class=\"keyword\">extends</span> <span class=\"title\">BaseItemAnimator</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">DefaultItemAnimator</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">DefaultItemAnimator</span><span class=\"params\">(Interpolator interpolator)</span> </span>&#123;</div><div class=\"line\">    mInterpolator = interpolator;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"meta\">@Override</span> <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">animateRemoveImpl</span><span class=\"params\">(<span class=\"keyword\">final</span> RecyclerView.ViewHolder holder)</span> </span>&#123;</div><div class=\"line\">    ViewCompat.animate(holder.itemView)</div><div class=\"line\">        .alpha(<span class=\"number\">0</span>)</div><div class=\"line\">        .setDuration(getRemoveDuration())</div><div class=\"line\">        .setListener(<span class=\"keyword\">new</span> DefaultRemoveVpaListener(holder))</div><div class=\"line\">        .setStartDelay(getRemoveDelay(holder))</div><div class=\"line\">        .start();</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"meta\">@Override</span> <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">preAnimateAddImpl</span><span class=\"params\">(RecyclerView.ViewHolder holder)</span> </span>&#123;</div><div class=\"line\">    ViewCompat.setAlpha(holder.itemView, <span class=\"number\">0</span>); <span class=\"comment\">//透明度先变为0</span></div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"meta\">@Override</span> <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">animateAddImpl</span><span class=\"params\">(<span class=\"keyword\">final</span> RecyclerView.ViewHolder holder)</span> </span>&#123;</div><div class=\"line\">    ViewCompat.animate(holder.itemView)</div><div class=\"line\">        .alpha(<span class=\"number\">1</span>)</div><div class=\"line\">        .setDuration(getAddDuration())</div><div class=\"line\">        .setListener(<span class=\"keyword\">new</span> DefaultAddVpaListener(holder))</div><div class=\"line\">        .setStartDelay(getAddDelay(holder))</div><div class=\"line\">        .start();</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>是不是比继承SimpleItemAnimator方便多了。</p>\n<p>对于RecyclerView的Item Animator，有一个常见的坑就是”闪屏问题”。这个问题的描述是：当Item视图中有图片和文字，当更新文字并调用<code>notifyItemChanged()</code>时，文字改变的同时图片会闪一下。这个问题的原因是当调用<code>notifyItemChanged()</code>时，会调用DefaultItemAnimator的<code>animateChangeImpl()</code>执行change动画，该动画会使得Item的透明度从0变为1，从而造成闪屏。</p>\n<p>解决办法很简单，在<code>rv.setAdapter()</code>之前调用<code>((SimpleItemAnimator)rv.getItemAnimator()).setSupportsChangeAnimations(false)</code>禁用change动画。</p>\n<h2 id=\"拓展RecyclerView\"><a href=\"#拓展RecyclerView\" class=\"headerlink\" title=\"拓展RecyclerView\"></a>拓展RecyclerView</h2><h3 id=\"添加setOnItemClickListener接口\"><a href=\"#添加setOnItemClickListener接口\" class=\"headerlink\" title=\"添加setOnItemClickListener接口\"></a>添加setOnItemClickListener接口</h3><p>RecyclerView默认没有像ListView一样提供<code>setOnItemClickListener()</code>接口，而<a href=\"http://blog.csdn.net/liaoinstan/article/details/51200600\" target=\"_blank\" rel=\"external\">RecyclerView无法添加onItemClickListener最佳的高效解决方案</a>这篇文章给出了通过<code>recyclerView.addOnItemTouchListener(...)</code>添加点击事件的方法，但我认为根本没有必要费这么大劲对外暴露这个接口，因为我们完全可以把点击事件的实现写在Adapter的<code>onBindViewHolder()</code>中，不暴露出来。具体方法就是通过：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onBindViewHolder</span><span class=\"params\">(VH holder, <span class=\"keyword\">int</span> position)</span> </span>&#123;</div><div class=\"line\">    holder.itemView.setOnClickListener(...);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"添加HeaderView和FooterView\"><a href=\"#添加HeaderView和FooterView\" class=\"headerlink\" title=\"添加HeaderView和FooterView\"></a>添加HeaderView和FooterView</h3><p>RecyclerView默认没有提供类似<code>addHeaderView()</code>和<code>addFooterView()</code>的API，因此这里介绍如何优雅地实现这两个接口。</p>\n<p>如果你已经实现了一个Adapter，现在想为这个Adapter添加<code>addHeaderView()</code>和<code>addFooterView()</code>接口，则需要在Adapter中添加几个Item Type，然后修改<code>getItemViewType()</code>,<code>onCreateViewHolder()</code>,<code>onBindViewHolder()</code>,<code>getItemCount()</code>等方法，并添加switch语句进行判断。那么如何在不破坏原有Adapter实现的情况下完成呢？</p>\n<p>这里引入装饰器（Decorator）设计模式，该设计模式通过组合的方式，在不破话原有类代码的情况下，对原有类的功能进行扩展。</p>\n<p>这恰恰满足了我们的需求。我们只需要通过以下方式为原有的Adapter（这里命名为NormalAdapter）添加<code>addHeaderView()</code>和<code>addFooterView()</code>接口：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">NormalAdapter adapter = <span class=\"keyword\">new</span> NormalAdapter(data);</div><div class=\"line\">NormalAdapterWrapper newAdapter = <span class=\"keyword\">new</span> NormalAdapterWrapper(adapter);</div><div class=\"line\">View headerView = LayoutInflater.from(<span class=\"keyword\">this</span>).inflate(R.layout.item_header, mRecyclerView, <span class=\"keyword\">false</span>);</div><div class=\"line\">View footerView = LayoutInflater.from(<span class=\"keyword\">this</span>).inflate(R.layout.item_footer, mRecyclerView, <span class=\"keyword\">false</span>);</div><div class=\"line\">newAdapter.addFooterView(footerView);</div><div class=\"line\">newAdapter.addHeaderView(headerView);</div><div class=\"line\">mRecyclerView.setAdapter(newAdapter);</div></pre></td></tr></table></figure>\n<p>是不是看起来特别优雅。具体实现思路其实很简单，创建一个继承<code>RecyclerView.Adapter&lt;RecyclerView.ViewHolder&gt;</code>的类，并重写常见的方法，然后通过引入ITEM TYPE的方式实现：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">NormalAdapterWrapper</span> <span class=\"keyword\">extends</span> <span class=\"title\">RecyclerView</span>.<span class=\"title\">Adapter</span>&lt;<span class=\"title\">RecyclerView</span>.<span class=\"title\">ViewHolder</span>&gt;</span>&#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">enum</span> ITEM_TYPE&#123;</div><div class=\"line\">        HEADER,</div><div class=\"line\">        FOOTER,</div><div class=\"line\">        NORMAL</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">private</span> NormalAdapter mAdapter;</div><div class=\"line\">    <span class=\"keyword\">private</span> View mHeaderView;</div><div class=\"line\">    <span class=\"keyword\">private</span> View mFooterView;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">NormalAdapterWrapper</span><span class=\"params\">(NormalAdapter adapter)</span></span>&#123;</div><div class=\"line\">        mAdapter = adapter;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getItemViewType</span><span class=\"params\">(<span class=\"keyword\">int</span> position)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">if</span>(position == <span class=\"number\">0</span>)&#123;</div><div class=\"line\">            <span class=\"keyword\">return</span> ITEM_TYPE.HEADER.ordinal();</div><div class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(position == mAdapter.getItemCount() + <span class=\"number\">1</span>)&#123;</div><div class=\"line\">            <span class=\"keyword\">return</span> ITEM_TYPE.FOOTER.ordinal();</div><div class=\"line\">        &#125; <span class=\"keyword\">else</span>&#123;</div><div class=\"line\">            <span class=\"keyword\">return</span> ITEM_TYPE.NORMAL.ordinal();</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getItemCount</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> mAdapter.getItemCount() + <span class=\"number\">2</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onBindViewHolder</span><span class=\"params\">(RecyclerView.ViewHolder holder, <span class=\"keyword\">int</span> position)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">if</span>(position == <span class=\"number\">0</span>)&#123;</div><div class=\"line\">            <span class=\"keyword\">return</span>;</div><div class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(position == mAdapter.getItemCount() + <span class=\"number\">1</span>)&#123;</div><div class=\"line\">            <span class=\"keyword\">return</span>;</div><div class=\"line\">        &#125; <span class=\"keyword\">else</span>&#123;</div><div class=\"line\">            mAdapter.onBindViewHolder(((NormalAdapter.VH)holder), position - <span class=\"number\">1</span>);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"keyword\">public</span> RecyclerView.<span class=\"function\">ViewHolder <span class=\"title\">onCreateViewHolder</span><span class=\"params\">(ViewGroup parent, <span class=\"keyword\">int</span> viewType)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">if</span>(viewType == ITEM_TYPE.HEADER.ordinal())&#123;</div><div class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> RecyclerView.ViewHolder(mHeaderView) &#123;&#125;;</div><div class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(viewType == ITEM_TYPE.FOOTER.ordinal())&#123;</div><div class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> RecyclerView.ViewHolder(mFooterView) &#123;&#125;;</div><div class=\"line\">        &#125; <span class=\"keyword\">else</span>&#123;</div><div class=\"line\">            <span class=\"keyword\">return</span> mAdapter.onCreateViewHolder(parent,viewType);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">addHeaderView</span><span class=\"params\">(View view)</span></span>&#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.mHeaderView = view;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">addFooterView</span><span class=\"params\">(View view)</span></span>&#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.mFooterView = view;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"添加setEmptyView\"><a href=\"#添加setEmptyView\" class=\"headerlink\" title=\"添加setEmptyView\"></a>添加setEmptyView</h3><p>ListView提供了<code>setEmptyView()</code>设置Adapter数据为空时的View视图。RecyclerView虽然没提供直接的API，但是也可以很简单地实现。</p>\n<ul>\n<li>创建一个继承RecyclerView的类，记为EmptyRecyclerView。</li>\n<li>通过<code>getRootView().addView(emptyView)</code>将空数据时显示的View添加到当前View的层次结构中。</li>\n<li>通过AdapterDataObserver监听RecyclerView的数据变化，如果adapter为空，那么隐藏RecyclerView，显示EmptyView。</li>\n</ul>\n<p>具体实现如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">EmptyRecyclerView</span> <span class=\"keyword\">extends</span> <span class=\"title\">RecyclerView</span></span>&#123;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"keyword\">private</span> View mEmptyView;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"keyword\">private</span> AdapterDataObserver mObserver = <span class=\"keyword\">new</span> AdapterDataObserver() &#123;</div><div class=\"line\">    \t<span class=\"meta\">@Override</span></div><div class=\"line\">    \t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onChanged</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">            Adapter adapter = getAdapter();</div><div class=\"line\">            <span class=\"keyword\">if</span>(adapter.getItemCount() == <span class=\"number\">0</span>)&#123;</div><div class=\"line\">                mEmptyView.setVisibility(VISIBLE);</div><div class=\"line\">                EmptyRecyclerView.<span class=\"keyword\">this</span>.setVisibility(GONE);</div><div class=\"line\">            &#125; <span class=\"keyword\">else</span>&#123;</div><div class=\"line\">                mEmptyView.setVisibility(GONE);</div><div class=\"line\">                EmptyRecyclerView.<span class=\"keyword\">this</span>.setVisibility(VISIBLE);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onItemRangeChanged</span><span class=\"params\">(<span class=\"keyword\">int</span> positionStart, <span class=\"keyword\">int</span> itemCount)</span> </span>&#123;onChanged();&#125;</div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onItemRangeMoved</span><span class=\"params\">(<span class=\"keyword\">int</span> fromPosition, <span class=\"keyword\">int</span> toPosition, <span class=\"keyword\">int</span> itemCount)</span> </span>&#123;onChanged();&#125;</div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onItemRangeRemoved</span><span class=\"params\">(<span class=\"keyword\">int</span> positionStart, <span class=\"keyword\">int</span> itemCount)</span> </span>&#123;onChanged();&#125;</div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onItemRangeInserted</span><span class=\"params\">(<span class=\"keyword\">int</span> positionStart, <span class=\"keyword\">int</span> itemCount)</span> </span>&#123;onChanged();&#125;</div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onItemRangeChanged</span><span class=\"params\">(<span class=\"keyword\">int</span> positionStart, <span class=\"keyword\">int</span> itemCount, Object payload)</span> </span>&#123;onChanged();&#125;</div><div class=\"line\">    &#125;;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">EmptyRecyclerView</span><span class=\"params\">(Context context, @Nullable AttributeSet attrs)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">super</span>(context, attrs);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setEmptyView</span><span class=\"params\">(View view)</span></span>&#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.mEmptyView = view;</div><div class=\"line\">        ((ViewGroup)<span class=\"keyword\">this</span>.getRootView()).addView(mEmptyView); <span class=\"comment\">//加入主界面布局</span></div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setAdapter</span><span class=\"params\">(RecyclerView.Adapter adapter)</span></span>&#123;</div><div class=\"line\">        <span class=\"keyword\">super</span>.setAdapter(adapter);</div><div class=\"line\">        adapter.registerAdapterDataObserver(mObserver);</div><div class=\"line\">        mObserver.onChanged();</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"拖拽、侧滑删除\"><a href=\"#拖拽、侧滑删除\" class=\"headerlink\" title=\"拖拽、侧滑删除\"></a>拖拽、侧滑删除</h3><p>Android提供了ItemTouchHelper类，使得RecyclerView能够轻易地实现滑动和拖拽，此处我们要实现上下拖拽和侧滑删除。首先创建一个继承自<code>ItemTouchHelper.Callback</code>的类，并重写以下方法：</p>\n<ul>\n<li><code>getMovementFlags()</code>: 设置支持的拖拽和滑动的方向，此处我们支持的拖拽方向为上下，滑动方向为从左到右和从右到左，内部通过<code>makeMovementFlags()</code>设置。</li>\n<li><code>onMove()</code>: 拖拽时回调。</li>\n<li><code>onSwiped()</code>: 滑动时回调。</li>\n<li><code>onSelectedChanged()</code>: 状态变化时回调，一共有三个状态，分别是ACTION_STATE_IDLE(空闲状态)，ACTION_STATE_SWIPE(滑动状态)，ACTION_STATE_DRAG(拖拽状态)。此方法中可以做一些状态变化时的处理，比如拖拽的时候修改背景色。</li>\n<li><code>clearView()</code>: 用户交互结束时回调。此方法可以做一些状态的清空，比如拖拽结束后还原背景色。</li>\n<li><code>isLongPressDragEnabled()</code>: 是否支持长按拖拽，默认为true。如果不想支持长按拖拽，则重写并返回false。</li>\n</ul>\n<p>具体实现如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SimpleItemTouchCallback</span> <span class=\"keyword\">extends</span> <span class=\"title\">ItemTouchHelper</span>.<span class=\"title\">Callback</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">private</span> NormalAdapter mAdapter;</div><div class=\"line\">    <span class=\"keyword\">private</span> List&lt;ObjectModel&gt; mData;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">SimpleItemTouchCallback</span><span class=\"params\">(NormalAdapter adapter, List&lt;ObjectModel&gt; data)</span></span>&#123;</div><div class=\"line\">        mAdapter = adapter;</div><div class=\"line\">        mData = data;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getMovementFlags</span><span class=\"params\">(RecyclerView recyclerView, RecyclerView.ViewHolder viewHolder)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">int</span> dragFlag = ItemTouchHelper.UP | ItemTouchHelper.DOWN; <span class=\"comment\">//s上下拖拽</span></div><div class=\"line\">        <span class=\"keyword\">int</span> swipeFlag = ItemTouchHelper.START | ItemTouchHelper.END; <span class=\"comment\">//左-&gt;右和右-&gt;左滑动</span></div><div class=\"line\">        <span class=\"keyword\">return</span> makeMovementFlags(dragFlag,swipeFlag);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">onMove</span><span class=\"params\">(RecyclerView recyclerView, RecyclerView.ViewHolder viewHolder, RecyclerView.ViewHolder target)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">int</span> from = viewHolder.getAdapterPosition();</div><div class=\"line\">        <span class=\"keyword\">int</span> to = target.getAdapterPosition();</div><div class=\"line\">        Collections.swap(mData, from, to);</div><div class=\"line\">        mAdapter.notifyItemMoved(from, to);</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onSwiped</span><span class=\"params\">(RecyclerView.ViewHolder viewHolder, <span class=\"keyword\">int</span> direction)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">int</span> pos = viewHolder.getAdapterPosition();</div><div class=\"line\">        mData.remove(pos);</div><div class=\"line\">        mAdapter.notifyItemRemoved(pos);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onSelectedChanged</span><span class=\"params\">(RecyclerView.ViewHolder viewHolder, <span class=\"keyword\">int</span> actionState)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">super</span>.onSelectedChanged(viewHolder, actionState);</div><div class=\"line\">        <span class=\"keyword\">if</span>(actionState != ItemTouchHelper.ACTION_STATE_IDLE)&#123;</div><div class=\"line\">            NormalAdapter.VH holder = (NormalAdapter.VH)viewHolder;</div><div class=\"line\">            holder.itemView.setBackgroundColor(<span class=\"number\">0xffbcbcbc</span>); <span class=\"comment\">//设置拖拽和侧滑时的背景色</span></div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">clearView</span><span class=\"params\">(RecyclerView recyclerView, RecyclerView.ViewHolder viewHolder)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">super</span>.clearView(recyclerView, viewHolder);</div><div class=\"line\">        NormalAdapter.VH holder = (NormalAdapter.VH)viewHolder;</div><div class=\"line\">        holder.itemView.setBackgroundColor(<span class=\"number\">0xffeeeeee</span>); <span class=\"comment\">//背景色还原</span></div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>然后通过以下代码为RecyclerView设置该滑动、拖拽功能：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">ItemTouchHelper helper = <span class=\"keyword\">new</span> ItemTouchHelper(<span class=\"keyword\">new</span> SimpleItemTouchCallback(adapter, data));</div><div class=\"line\">helper.attachToRecyclerView(recyclerview);</div></pre></td></tr></table></figure>\n<p>前面拖拽的触发方式只有长按，如果想支持触摸Item中的某个View实现拖拽，则核心方法为<code>helper.startDrag(holder)</code>。首先定义接口：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">OnStartDragListener</span></span>&#123;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">startDrag</span><span class=\"params\">(RecyclerView.ViewHolder holder)</span></span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>然后让Activity实现该接口：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> MainActivity extends Activity implements OnStartDragListener&#123;</div><div class=\"line\">    ...</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">startDrag</span><span class=\"params\">(RecyclerView.ViewHolder holder)</span> </span>&#123;</div><div class=\"line\">        mHelper.startDrag(holder);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>如果要对ViewHolder的text对象支持触摸拖拽，则在Adapter中的<code>onBindViewHolder()</code>中添加：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">holder.text.setOnTouchListener(<span class=\"keyword\">new</span> View.OnTouchListener() &#123;</div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">onTouch</span><span class=\"params\">(View v, MotionEvent event)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">if</span>(event.getAction() == MotionEvent.ACTION_DOWN)&#123;</div><div class=\"line\">            mListener.startDrag(holder);</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>其中mListener是在创建Adapter时将实现OnStartDragListener接口的Activity对象作为参数传进来。</p>\n<h2 id=\"回收机制\"><a href=\"#回收机制\" class=\"headerlink\" title=\"回收机制\"></a>回收机制</h2><h3 id=\"ListView回收机制\"><a href=\"#ListView回收机制\" class=\"headerlink\" title=\"ListView回收机制\"></a>ListView回收机制</h3><p>ListView为了保证Item View的复用，实现了一套回收机制，该回收机制的实现类是RecycleBin，他实现了两级缓存：</p>\n<ul>\n<li><code>View[] mActiveViews</code>: 缓存屏幕上的View，在该缓存里的View不需要调用<code>getView()</code>。</li>\n<li><code>ArrayList&lt;View&gt;[] mScrapViews;</code>: 每个Item Type对应一个列表作为回收站，缓存由于滚动而消失的View，此处的View如果被复用，会以参数的形式传给<code>getView()</code>。</li>\n</ul>\n<p>接下来我们通过源码分析ListView是如何与RecycleBin交互的。其实ListView和RecyclerView的layout过程大同小异，ListView的布局函数是<code>layoutChildren()</code>，实现如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">layoutChildren</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">    <span class=\"comment\">//1. 如果数据被改变了，则将所有Item View回收至scrapView（而RecyclerView会根据情况放入Scrap Heap或RecyclePool）；否则回收至mActiveViews</span></div><div class=\"line\">    <span class=\"keyword\">if</span> (dataChanged) &#123;</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; childCount; i++) &#123;</div><div class=\"line\">            recycleBin.addScrapView(getChildAt(i), firstPosition+i);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">        recycleBin.fillActiveViews(childCount, firstPosition);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"comment\">//2. 填充</span></div><div class=\"line\">    <span class=\"keyword\">switch</span>()&#123;</div><div class=\"line\">        <span class=\"keyword\">case</span> LAYOUT_XXX:</div><div class=\"line\">            fillXxx();</div><div class=\"line\">            <span class=\"keyword\">break</span>;</div><div class=\"line\">        <span class=\"keyword\">case</span> LAYOUT_XXX:</div><div class=\"line\">            fillXxx();</div><div class=\"line\">            <span class=\"keyword\">break</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"comment\">//3. 回收多余的activeView</span></div><div class=\"line\">    mRecycler.scrapActiveViews();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>其中<code>fillXxx()</code>实现了对Item View进行填充，该方法内部调用了<code>makeAndAddView()</code>，实现如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\">View <span class=\"title\">makeAndAddView</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (!mDataChanged) &#123;</div><div class=\"line\">        child = mRecycler.getActiveView(position);</div><div class=\"line\">        <span class=\"keyword\">if</span> (child != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">            <span class=\"keyword\">return</span> child;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    child = obtainView(position, mIsScrap);</div><div class=\"line\">    <span class=\"keyword\">return</span> child;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>其中，<code>getActiveView()</code>是从mActiveViews中获取合适的View，如果获取到了，则直接返回，而不调用<code>obtainView()</code>，这也印证了如果从mActiveViews获取到了可复用的View，则不需要调用<code>getView()</code>。</p>\n<p><code>obtainView()</code>是从mScrapViews中获取合适的View，然后以参数形式传给了<code>getView()</code>，实现如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\">View <span class=\"title\">obtainView</span><span class=\"params\">(<span class=\"keyword\">int</span> position)</span></span>&#123;</div><div class=\"line\">    <span class=\"keyword\">final</span> View scrapView = mRecycler.getScrapView(position);  <span class=\"comment\">//从RecycleBin中获取复用的View</span></div><div class=\"line\">    <span class=\"keyword\">final</span> View child = mAdapter.getView(position, scrapView, <span class=\"keyword\">this</span>);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>接下去我们介绍<code>getScrapView(position)</code>的实现，该方法通过position得到Item Type，然后根据Item Type从mScrapViews获取可复用的View，如果获取不到，则返回null，具体实现如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RecycleBin</span></span>&#123;</div><div class=\"line\">    <span class=\"keyword\">private</span> View[] mActiveViews;    <span class=\"comment\">//存储屏幕上的View</span></div><div class=\"line\">    <span class=\"keyword\">private</span> ArrayList&lt;View&gt;[] mScrapViews;  <span class=\"comment\">//每个item type对应一个ArrayList</span></div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> mViewTypeCount;            <span class=\"comment\">//item type的个数</span></div><div class=\"line\">    <span class=\"keyword\">private</span> ArrayList&lt;View&gt; mCurrentScrap;  <span class=\"comment\">//mScrapViews[0]</span></div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\">View <span class=\"title\">getScrapView</span><span class=\"params\">(<span class=\"keyword\">int</span> position)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> whichScrap = mAdapter.getItemViewType(position);</div><div class=\"line\">        <span class=\"keyword\">if</span> (whichScrap &lt; <span class=\"number\">0</span>) &#123;</div><div class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">if</span> (mViewTypeCount == <span class=\"number\">1</span>) &#123;</div><div class=\"line\">            <span class=\"keyword\">return</span> retrieveFromScrap(mCurrentScrap, position);</div><div class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (whichScrap &lt; mScrapViews.length) &#123;</div><div class=\"line\">            <span class=\"keyword\">return</span> retrieveFromScrap(mScrapViews[whichScrap], position);</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> View <span class=\"title\">retrieveFromScrap</span><span class=\"params\">(ArrayList&lt;View&gt; scrapViews, <span class=\"keyword\">int</span> position)</span></span>&#123;</div><div class=\"line\">        <span class=\"keyword\">int</span> size = scrapViews.size();</div><div class=\"line\">        <span class=\"keyword\">if</span>(size &gt; <span class=\"number\">0</span>)&#123;</div><div class=\"line\">            <span class=\"keyword\">return</span> scrapView.remove(scrapViews.size() - <span class=\"number\">1</span>);  <span class=\"comment\">//从回收列表中取出最后一个元素复用</span></div><div class=\"line\">        &#125; <span class=\"keyword\">else</span>&#123;</div><div class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"RecyclerView回收机制\"><a href=\"#RecyclerView回收机制\" class=\"headerlink\" title=\"RecyclerView回收机制\"></a>RecyclerView回收机制</h3><p>RecyclerView和ListView的回收机制非常相似，但是ListView是以View作为单位进行回收，RecyclerView是以ViewHolder作为单位进行回收。Recycler是RecyclerView回收机制的实现类，他实现了四级缓存：</p>\n<ul>\n<li>mAttachedScrap: 缓存在屏幕上的ViewHolder。</li>\n<li>mCachedViews: 缓存屏幕外的ViewHolder，默认为2个。ListView对于屏幕外的缓存都会调用<code>getView()</code>。</li>\n<li>mViewCacheExtensions: 需要用户定制，默认不实现。</li>\n<li>mRecyclerPool: 缓存池，多个RecyclerView共用。</li>\n</ul>\n<p>在上文Layout Manager中已经介绍了RecyclerView的layout过程，但是一笔带过了<code>getViewForPosition()</code>，因此此处介绍该方法的实现。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\">View <span class=\"title\">getViewForPosition</span><span class=\"params\">(<span class=\"keyword\">int</span> position, <span class=\"keyword\">boolean</span> dryRun)</span></span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span>(holder == <span class=\"keyword\">null</span>)&#123;</div><div class=\"line\">        <span class=\"comment\">//从mAttachedScrap,mCachedViews获取ViewHolder</span></div><div class=\"line\">        holder = getScrapViewForPosition(position,INVALID,dryRun); <span class=\"comment\">//此处获得的View不需要bind</span></div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> type = mAdapter.getItemViewType(offsetPosition);</div><div class=\"line\">    <span class=\"keyword\">if</span> (mAdapter.hasStableIds()) &#123; <span class=\"comment\">//默认为false</span></div><div class=\"line\">        holder = getScrapViewForId(mAdapter.getItemId(offsetPosition), type, dryRun);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">if</span>(holder == <span class=\"keyword\">null</span> &amp;&amp; mViewCacheExtension != <span class=\"keyword\">null</span>)&#123;</div><div class=\"line\">        <span class=\"keyword\">final</span> View view = mViewCacheExtension.getViewForPositionAndType(<span class=\"keyword\">this</span>, position, type); <span class=\"comment\">//从</span></div><div class=\"line\">        <span class=\"keyword\">if</span>(view != <span class=\"keyword\">null</span>)&#123;</div><div class=\"line\">            holder = getChildViewHolder(view);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">if</span>(holder == <span class=\"keyword\">null</span>)&#123;</div><div class=\"line\">        holder = getRecycledViewPool().getRecycledView(type);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">if</span>(holder == <span class=\"keyword\">null</span>)&#123;  <span class=\"comment\">//没有缓存，则创建</span></div><div class=\"line\">        holder = mAdapter.createViewHolder(RecyclerView.<span class=\"keyword\">this</span>, type); <span class=\"comment\">//调用onCreateViewHolder()</span></div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">if</span>(!holder.isBound() || holder.needsUpdate() || holder.isInvalid())&#123;</div><div class=\"line\">    \tmAdapter.bindViewHolder(holder, offsetPosition);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> holder.itemView;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>从上述实现可以看出，依次从mAttachedScrap, mCachedViews, mViewCacheExtension, mRecyclerPool寻找可复用的ViewHolder，如果是从mAttachedScrap或mCachedViews中获取的ViewHolder，则不会调用<code>onBindViewHolder()</code>，mAttachedScrap和mCachedViews也就是我们所说的Scrap Heap；而如果从mViewCacheExtension或mRecyclerPool中获取的ViewHolder，则会调用<code>onBindViewHolder()</code>。</p>\n<p>RecyclerView局部刷新的实现原理也是基于RecyclerView的回收机制，即能直接复用的ViewHolder就不调用<code>onBindViewHolder()</code>。</p>\n<h2 id=\"嵌套滑动机制\"><a href=\"#嵌套滑动机制\" class=\"headerlink\" title=\"嵌套滑动机制\"></a>嵌套滑动机制</h2><p>Android 5.0推出了嵌套滑动机制，在之前，一旦子View处理了触摸事件，父View就没有机会再处理这次的触摸事件，而嵌套滑动机制解决了这个问题，能够实现如下效果：</p>\n<p><img src=\"https://github.com/xiazdong/RecyclerViewDemo/blob/master/app/src/main/res/assets/demo6.gif?raw=true\" height=\"400px\"></p>\n<p>为了支持嵌套滑动，子View必须实现NestedScrollingChild接口，父View必须实现NestedScrollingParent接口，而RecyclerView实现了NestedScrollingChild接口，而CoordinatorLayout实现了NestedScrollingParent接口，上图是实现CoordinatorLayout嵌套RecyclerView的效果。</p>\n<p>为了实现上图的效果，需要用到的组件有：</p>\n<ul>\n<li>CoordinatorLayout: 布局根元素。</li>\n<li>AppBarLayout: 包裹的内容作为应用的Bar。</li>\n<li>CollapsingToolbarLayout: 实现可折叠的ToolBar。</li>\n<li>ToolBar: 代替ActionBar。</li>\n</ul>\n<p>实现中需要注意的点有：</p>\n<ul>\n<li>我们为ToolBar的<code>app:layout_collapseMode</code>设置为pin，表示折叠之后固定在顶端，而为ImageView的<code>app:layout_collapseMode</code>设置为parallax，表示视差模式，即渐变的效果。</li>\n<li>为了让RecyclerView支持嵌套滑动，还需要为它设置<code>app:layout_behavior=&quot;@string/appbar_scrolling_view_behavior&quot;</code>。</li>\n<li>为CollapsingToolbarLayout设置<code>app:layout_scrollFlags=&quot;scroll|exitUntilCollapsed&quot;</code>，其中scroll表示滚动出屏幕，exitUntilCollapsed表示退出后折叠。</li>\n</ul>\n<p>具体实现参见Demo6。</p>\n<h2 id=\"回顾\"><a href=\"#回顾\" class=\"headerlink\" title=\"回顾\"></a>回顾</h2><p>回顾整篇文章，发现我们已经实现了RecyclerView的很多扩展功能，包括：打造万能适配器、添加Item事件、添加头视图和尾视图、设置空布局、侧滑拖拽。<a href=\"http://www.recyclerview.org/\" target=\"_blank\" rel=\"external\">BaseRecyclerViewAdapterHelper</a>是一个比较火的RecyclerView扩展库，仔细一看发现，这里面80%的功能在我们这篇文章中都实现了。</p>\n<h2 id=\"扩展阅读\"><a href=\"#扩展阅读\" class=\"headerlink\" title=\"扩展阅读\"></a>扩展阅读</h2><ul>\n<li><a href=\"http://v.youku.com/v_show/id_XMTU4MTQ1ODg2NA==.html?f=27314446\" target=\"_blank\" rel=\"external\">Google I/O 2016: RecyclerView Ins and Outs</a></li>\n<li><a href=\"https://github.com/CymChad/CymChad.github.io\" target=\"_blank\" rel=\"external\">RecyclerView优秀文章集</a></li>\n</ul>\n","categories":[],"tags":["Android"]},{"title":"自定义Dialog","url":"http://xiazdong.github.io/2016/09/29/自定义Dialog/","content":"<h2 id=\"基本框架\"><a href=\"#基本框架\" class=\"headerlink\" title=\"基本框架\"></a>基本框架</h2><p>这里假设要构造的Dialog的布局为R.layout.dialog_common，布局中只有一个TextView。</p>\n<h3 id=\"错误的框架\"><a href=\"#错误的框架\" class=\"headerlink\" title=\"错误的框架\"></a>错误的框架</h3><p>刚开始实现时，想当然的把导入布局并且setContentView()放在onCreate()中。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CommonDialog</span> <span class=\"keyword\">extends</span> <span class=\"title\">Dialog</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">private</span> TextView mTextView;</div><div class=\"line\">    <span class=\"keyword\">private</span> String mText;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">CommonDialog</span><span class=\"params\">(Context context)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>(context, R.style.StyleableDialogTheme);     <span class=\"comment\">//设置style</span></div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">CommonDialog</span><span class=\"params\">(Context context, <span class=\"keyword\">int</span> themeResId)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">super</span>(context, themeResId);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreate</span><span class=\"params\">(Bundle savedInstanceState)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">super</span>.onCreate(savedInstanceState);</div><div class=\"line\">        View rootView = LayoutInflater.from(mContext).inflate(R.layout.dialog_common, <span class=\"keyword\">null</span>);</div><div class=\"line\">        mTextView = (TextView) rootView.findViewById(R.id.text);</div><div class=\"line\">        setContentView(rootView);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setText</span><span class=\"params\">(String text)</span></span>&#123;</div><div class=\"line\">\t\t\tmTextView.setText(text)。<span class=\"comment\">//错误</span></div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">show</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">        <span class=\"keyword\">super</span>.show();</div><div class=\"line\">\t\t\t  getWindow().setLayout(WindowManager.LayoutParams.WRAP_CONTENT, WindowManager.LayoutParams.WRAP_CONTENT);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>然后很正常的使用它：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">CommonDialog dialog = <span class=\"keyword\">new</span> CommonDialog(<span class=\"keyword\">this</span>);</div><div class=\"line\">dialog.setText(<span class=\"string\">\"hello\"</span>);</div><div class=\"line\">dilaog.show();</div></pre></td></tr></table></figure>\n<p>但是运行后，<code>dialog.setText(&quot;hello&quot;)</code>报空指针异常。经过研究发现Dialog直到show()中才调用了onCreate()，因此调用<code>dialog.setText(&quot;hello&quot;)</code>时还没有拿到UI组件。show()的内部实现如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">public void show() &#123;</div><div class=\"line\">    ...</div><div class=\"line\">    if (!mCreated) &#123;</div><div class=\"line\">        dispatchOnCreate(null);      //调用了onCreate()方法</div><div class=\"line\">    &#125;</div><div class=\"line\">    onStart();</div><div class=\"line\">    mDecor = mWindow.getDecorView();</div><div class=\"line\"></div><div class=\"line\">    WindowManager.LayoutParams l = mWindow.getAttributes();</div><div class=\"line\">    if ((l.softInputMode</div><div class=\"line\">            &amp; WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION) == 0) &#123;</div><div class=\"line\">        WindowManager.LayoutParams nl = new WindowManager.LayoutParams();   //创建一个新的LayoutParams，width和height默认值为-1，即MATCH_PARENT</div><div class=\"line\">        nl.copyFrom(l);</div><div class=\"line\">        l = nl;</div><div class=\"line\">    &#125;</div><div class=\"line\">    ...</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>可以看出：默认情况下，show()过程中会调用onCreate()方法，因此在show()之前是获得不到Dialog的布局的。</p>\n<h3 id=\"最终框架\"><a href=\"#最终框架\" class=\"headerlink\" title=\"最终框架\"></a>最终框架</h3><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CommonDialog</span> <span class=\"keyword\">extends</span> <span class=\"title\">Dialog</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">private</span> TextView mTextView;</div><div class=\"line\">    <span class=\"keyword\">private</span> View mContentView;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">CommonDialog</span><span class=\"params\">(Context context)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>(context, R.style.StyleableDialogTheme);     <span class=\"comment\">//设置style</span></div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">CommonDialog</span><span class=\"params\">(Context context, <span class=\"keyword\">int</span> themeResId)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">super</span>(context, themeResId);</div><div class=\"line\">        mContentView = LayoutInflater.from(mContext).inflate(R.layout.dialog_common, <span class=\"keyword\">null</span>);</div><div class=\"line\">        mTextView = (TextView) mContentView.findViewById(R.id.text);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreate</span><span class=\"params\">(Bundle savedInstanceState)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">super</span>.onCreate(savedInstanceState);</div><div class=\"line\">        setContentView(mContentView);</div><div class=\"line\">        getWindow().setLayout(WindowManager.LayoutParams.WRAP_CONTENT, WindowManager.LayoutParams.WRAP_CONTENT);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setText</span><span class=\"params\">(String text)</span></span>&#123;</div><div class=\"line\">        mTextView.setText(text);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>特点：在构造函数中提前映射布局。</p>\n<p>这种实现方式能够通过如下方式使用：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">CommonDialog dialog = <span class=\"keyword\">new</span> CommonDialog(<span class=\"keyword\">this</span>);</div><div class=\"line\">dialog.setText(<span class=\"string\">\"hello\"</span>);</div><div class=\"line\">dilaog.show();</div></pre></td></tr></table></figure>\n<h2 id=\"其他的注意点\"><a href=\"#其他的注意点\" class=\"headerlink\" title=\"其他的注意点\"></a>其他的注意点</h2><p>这里还需要提一下R.style.StyleableDialogTheme，该值如下：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">style</span> <span class=\"attr\">name</span>=<span class=\"string\">\"StyleableDialogTheme\"</span>&gt;</span><span class=\"xml\"></span></div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">item</span> <span class=\"attr\">name</span>=<span class=\"string\">\"android:windowBackground\"</span>&gt;</span>@android:color/transparent<span class=\"tag\">&lt;/<span class=\"name\">item</span>&gt;</span> <span class=\"comment\">&lt;!-- 设置dialog的背景，如果不设置为透明，那么圆角就显示不出来 --&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">item</span> <span class=\"attr\">name</span>=<span class=\"string\">\"android:colorBackgroundCacheHint\"</span>&gt;</span>@null<span class=\"tag\">&lt;/<span class=\"name\">item</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">item</span> <span class=\"attr\">name</span>=<span class=\"string\">\"android:windowNoTitle\"</span>&gt;</span>true<span class=\"tag\">&lt;/<span class=\"name\">item</span>&gt;</span>            <span class=\"comment\">&lt;!-- 如果不设置此句，部分机型会出现对话框标题栏还存在 --&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">item</span> <span class=\"attr\">name</span>=<span class=\"string\">\"android:backgroundDimEnabled\"</span>&gt;</span>true<span class=\"tag\">&lt;/<span class=\"name\">item</span>&gt;</span> <span class=\"comment\">&lt;!-- 背景是灰的 --&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">item</span> <span class=\"attr\">name</span>=<span class=\"string\">\"android:windowAnimationStyle\"</span>&gt;</span>@null<span class=\"tag\">&lt;/<span class=\"name\">item</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">item</span> <span class=\"attr\">name</span>=<span class=\"string\">\"android:windowFullscreen\"</span>&gt;</span>false<span class=\"tag\">&lt;/<span class=\"name\">item</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">item</span> <span class=\"attr\">name</span>=<span class=\"string\">\"android:windowContentOverlay\"</span>&gt;</span>@null<span class=\"tag\">&lt;/<span class=\"name\">item</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">item</span> <span class=\"attr\">name</span>=<span class=\"string\">\"android:windowIsTranslucent\"</span>&gt;</span>true<span class=\"tag\">&lt;/<span class=\"name\">item</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">item</span> <span class=\"attr\">name</span>=<span class=\"string\">\"android:windowFrame\"</span>&gt;</span>@null<span class=\"tag\">&lt;/<span class=\"name\">item</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">item</span> <span class=\"attr\">name</span>=<span class=\"string\">\"android:windowIsFloating\"</span>&gt;</span>true<span class=\"tag\">&lt;/<span class=\"name\">item</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">item</span> <span class=\"attr\">name</span>=<span class=\"string\">\"android:windowSoftInputMode\"</span>&gt;</span>stateAlwaysHidden<span class=\"tag\">&lt;/<span class=\"name\">item</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">style</span>&gt;</span></div></pre></td></tr></table></figure>\n","categories":[],"tags":["Android"]},{"title":"程序员教你健身","url":"http://xiazdong.github.io/2016/05/16/程序员教你健身/","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>健身行业在2014年开始火起来，进入”全民健身”时代，马甲线、人鱼线、反手摸肚脐、A4腰等词汇频频进入人的视野，拥有一个穿衣显瘦、脱衣有肉的身材是男生的梦想，拥有一个苗条、紧致的身材是女生的梦想。健身需要有对的方法+坚持，很多人这两项都没做到。</p>\n<p>本人男生，天生身材瘦弱，在2016年初，趁着毕业论文写完，打算请个私教，系统地进行健身，为了身体花点钱还是值得的，虽然没有锻炼成很优秀，但是还是有些经验分享。</p>\n<h2 id=\"健身很难吗？\"><a href=\"#健身很难吗？\" class=\"headerlink\" title=\"健身很难吗？\"></a>健身很难吗？</h2><p>健身其实并没有那么难。</p>\n<p>下面我举个女生减肥的例子：每天节食（比如晚饭只吃一个苹果，早饭只喝杯豆浆），但是却喜欢吃垃圾食品（比如炸鸡、披萨、蛋糕），她们每个星期只跑跑步，2个星期之后发现体重没轻，然后就抱怨：怎么锻炼了还是瘦不下来，然后就到处说：我锻炼了但是瘦不下来啊。</p>\n<p>上面的例子可以发现，这种方式有几个问题：</p>\n<ul>\n<li>节食：减脂并不是不吃东西，而是吃健康的东西，要讲究营养均衡。比如早餐可以吃：一杯牛奶、一个蛋、3片全麦面包、5个坚果、一些蔬菜、牛肉。中饭可以吃：糙米饭、2种水煮蔬菜、鸡胸肉。晚饭可以吃：紫米饭、2种水煮蔬菜、虾、鱼。</li>\n<li>垃圾食品：不管是减脂还是增肌，垃圾食品尽量别吃。</li>\n<li>只跑步：器械锻炼能更好地减脂，因为增加肌肉会增加基础代谢，而且能更有线条。应该先做1小时器械，然后跑45分钟步。</li>\n<li>只锻炼2个星期：健身需要坚持，是一辈子的事，2个星期没效果太正常了，坚持半年肯定会有效果。</li>\n</ul>\n<p>甩脂机、左旋肉碱、减脂粉都是不靠谱的。健身也没什么捷径，只要有了对的方法，慢慢练，一定会成功，记住：没有捷径，慢慢练比较快。</p>\n<h2 id=\"初学者的常见困惑\"><a href=\"#初学者的常见困惑\" class=\"headerlink\" title=\"初学者的常见困惑\"></a>初学者的常见困惑</h2><ul>\n<li>我不想去健身房，能不能在家里锻炼：能，但是要买基本的设备：瑜伽垫、哑铃、哑铃凳、一字拉力绳。但是效果肯定没健身房好，因此建议去健身房。</li>\n<li>去健身房一点头绪都没有，健身器材都不会用：这个问题的解决方法是请私教课，或者让旁边厉害的人教你。</li>\n<li>是否有必要请私教：如果是男生，零基础，目标增肌，而且没有一起锻炼的朋友，那么很有必要，并且请男私教。如果是女生，减脂其实并不需要请私教，但是如果要请，就请女私教。</li>\n<li>怎么选择私教：(1)看教练体型(2)考了什么证书(3)男生找男私教，女生找女私教(4)是否体校等专业(5)语言表达是否清晰(6)态度是否亲和(6)上一节体验课试试。</li>\n<li>私教好贵，心疼钱：一节私教课一般需要200+元，30节课至少6000元，但是6000元能让你在最短时间学习到健身相关的知识，等学会了就自己练，因此还是值得的。</li>\n<li>怎么选健身房：(1)近(2)设施是否够用。</li>\n<li>俯卧撑能锻炼好看的胸肌吗：不能，因为自重训练刺激不够大，只能练肌耐力，不能增长维度，因此还是去健身房做胸部的器械动作，比如卧推、飞鸟。</li>\n<li>每次锻炼完好酸，怎么办：多拉伸缓解肌肉酸痛。</li>\n<li>脂肪能变成肌肉吗：不能，肌肉只能通过撕裂-&gt;补充蛋白质-&gt;修复变大。</li>\n<li>人瘦肚子大怎么办：多练肌肉，提高代谢，一周3-4次器械训练，一周2-3次有氧，一天隔一天腹部锻炼，同时注意饮食。</li>\n<li>减脂只做有氧行吗：行，但是最好配合无氧，因为增加肌肉含量能提高代谢，使得不容易发胖。</li>\n<li>我想增肌，但是不想练的太壮，有什么办法：一开始练就对了，别想太多，你不会练太壮的。</li>\n<li>先做无氧还是先做有氧：先无氧，后有氧。</li>\n<li>锻炼完发现关节不适，怎么办：停止锻炼，搞清楚原因，比如动作问题、自身问题，并解决。</li>\n<li>感冒要不要坚持：休息，先养好身体，来日方长。</li>\n</ul>\n<h2 id=\"请私教请多久？\"><a href=\"#请私教请多久？\" class=\"headerlink\" title=\"请私教请多久？\"></a>请私教请多久？</h2><p>如果要系统性地进行锻炼（私教或自己规划），一般分为三个阶段：</p>\n<ul>\n<li>基础期：1个月，以增加体能为主，并初步适应健身动作。</li>\n<li>提高期：至少2个月，以增加肌肉为主。提高了体能之后，就能更好的增加肌肉。</li>\n<li>巩固期：至少1个月，此时身体肌肉都已经锻炼出来，接下去就是维持肌肉。</li>\n</ul>\n<p>因此：</p>\n<ul>\n<li>如果你的目标是学会动作，那么只需要1个月（12节课左右），并且让教练每次锻炼都给你介绍不同的动作。我上了12次课基本已经学会了常见的动作。</li>\n<li>如果你的目标是塑造成目标体型，那么至少需要3个月（至少36节课）。</li>\n</ul>\n<p>私教课要每次课学完做总结，上私教课的目标是以后能脱离私教自己训练，因此一边上私教课，一边要想着未来自己怎么训练。我见过有些不上心的学员，都练了1个多月了，教练让他练划船，他还要让教练示范怎么做。</p>\n<p>健身房都有测体质的机器，每个月都可以测一次，需要关注：体重、体脂比（女生控制在20%以内即可，男生控制在12%以内即可）、骨骼肌含量。</p>\n<h2 id=\"基本建议\"><a href=\"#基本建议\" class=\"headerlink\" title=\"基本建议\"></a>基本建议</h2><ul>\n<li>每次锻炼的顺序：热身-&gt;拉伸-&gt;无氧-&gt;拉伸-&gt;有氧。</li>\n<li>器械锻炼重要性排列：姿势标准&gt;动作幅度&gt;动作速度&gt;意念控制&gt;重量。</li>\n<li>不要刻意追求重量的提升，而是要追求每个动作的标准，是否真的刺激到了目标肌群（判断是否刺激到目标肌肉的方法是看肌肉是否充血）。</li>\n<li>做健身动作时别憋气，要有吸气、呼气，否则大重量会出现头痛，而且一旦头痛就需要修养一阵子。</li>\n<li>姿势正确：每个人健身都是为了身体更健康，如果姿势不正确，器械很容易弄伤人，比如卧推肩膀不锁死，则伤肩膀。如果是小白，建议请私教。</li>\n<li>坚持：保证一个礼拜3-4次器械，2-3次有氧，坚持1年。</li>\n<li>睡眠：至少7-8小时睡眠。</li>\n<li>饮食：按照减脂还是增肌有所区别，减脂遵循”高蛋白、低碳水、适当脂肪”，增肌遵循”高蛋白、高碳水、适当脂肪”。</li>\n<li>规划：每次锻炼之前要有规划，做哪几个动作，每个动作做几组。</li>\n<li>强度：健身只要和自己比。健身强度因人而异，一套动作，有的人累死，有的人没感觉。但是也不能强度太低。</li>\n<li>如果要减脂，别一直跑步，也要结合器械，否则以后容易反弹。</li>\n<li>训练前1小时吃低GI值碳水；训练后15分钟吃高GI值碳水（比如面包、馒头、饼干）+易吸收蛋白质（比如蛋白粉、牛奶、鸡蛋）。</li>\n<li>平常多喝水能提高新陈代谢，有助减肥。</li>\n<li>大肌群：胸、肩、背、腿；小肌群：肱三、肱二、腹肌。一天锻炼一个大肌群+一个小肌群，一般：胸+肱三，背+肱二，肩+腿，腹肌可以天天练。</li>\n<li>意念非常重要，比如锻炼背部，就要意念用背部发力。</li>\n<li>女生锻炼器械时建议带健身手套，防止手有老茧。</li>\n</ul>\n<p>除了普通的训练方法，还有其他的方法，用来突破瓶颈期：</p>\n<ul>\n<li>超级组：将两个起相反效果的动作（肱二和肱三，胸和背）连起来当做一组做。</li>\n<li>递减组：第一组的重量最重，随后依次递减。</li>\n<li>巨人组：将练同一个肌肉的3个动作连起来为一组，比如三角肌中束的巨人组：3kg哑铃侧平举12个，4kg哑铃侧平举10个，5kg哑铃侧平举8个。</li>\n</ul>\n<h2 id=\"常见补剂\"><a href=\"#常见补剂\" class=\"headerlink\" title=\"常见补剂\"></a>常见补剂</h2><p>相比补剂，日常饮食更为重要，如果基础饮食足够，不吃补剂也可以。</p>\n<p>补剂只是日常饮食营养不够的情况下作为补充的，每公斤体重建议补充1.5g蛋白质，比如你60kg，你一天需要90g蛋白质，你如果日常饮食吃了60g蛋白质，那么其余30g可以用蛋白粉补充；如果你日常饮食已经吃了90g蛋白质，那就不需要吃蛋白粉了。</p>\n<p>蛋白质摄入最好要均匀分配到各餐中，而不是一次性大量摄入。</p>\n<p>健身说的蛋白粉指的是乳清蛋白粉，而不是安利的植物蛋白粉。</p>\n<ul>\n<li>乳清蛋白粉（Whey Protein）：乳清蛋白是从牛奶中提取的易吸收蛋白质，100g牛奶中只有0.7g乳清蛋白，因此吃乳清蛋白粉为了更快更方便地补充蛋白质。品牌：欧普特蒙，肌肉科技白金，迪马泰斯，艾恩麦斯。</li>\n<li>分离乳清蛋白粉（Isolate Whey Protein）：乳清蛋白粉的升级版，降低了碳水和脂肪含量，相比乳清蛋白粉，有更好地吸收率。但是贵很多，就买普通乳清蛋白粉就可以了。</li>\n<li>蛋白棒：长得和士力架差不多，和乳清蛋白粉相比，优点是携带方便。</li>\n<li>增肌粉（Mass）：又称增重粉，乳清蛋白粉和碳水化合物按照一定比例混合，适用于瘦子增肌。推荐：肌肉科技Mass，斯特朗高热量增肌王。除非你特别瘦，否则还是买乳清蛋白粉。</li>\n<li>缓释蛋白粉：加入酪蛋白，吸收很慢，持续吸收。</li>\n<li>肌酸（Creatine）：提高体能，防止疲劳。</li>\n<li>氮泵：提高训练状态，增加肌肉充血。</li>\n<li>支链氨基酸（BCAA）：防止肌肉分解。</li>\n</ul>\n<p>使用摇摇杯喝”各种粉”的方法：在杯子里倒200毫升冷水（或低于40度温水），再倒入一勺粉，盖上盖子，使劲上下摇晃（不要横向摇晃）。</p>\n<p>吃补剂时间段：</p>\n<ul>\n<li>吃早饭时：增肌粉/乳清蛋白粉。</li>\n<li>训练前半小时：增肌粉/氮泵/中低GI值碳水（燕麦）。</li>\n<li>训练中半小时：支链氨基酸。</li>\n<li>训练后半小时内：增肌粉/乳清蛋白粉（和碳水，比如面包、馒头等一起吃）/肌酸/香蕉。</li>\n<li>睡觉前一小时：乳清蛋白粉/缓释蛋白粉。</li>\n</ul>\n<p>当然，如果钱有限，那么只需要买乳清蛋白粉，其他都不是必要的。</p>\n<p>补剂尽量在天猫官方旗舰店或iherb上买。</p>\n<h2 id=\"练哪些肌肉穿衣服好看\"><a href=\"#练哪些肌肉穿衣服好看\" class=\"headerlink\" title=\"练哪些肌肉穿衣服好看\"></a>练哪些肌肉穿衣服好看</h2><p>在介绍具体动作之前，必须要注意这点，因为大部分人练肌肉都不是为了练出健美运动员样子的身材，而是穿衣显瘦、脱衣有肉。</p>\n<ul>\n<li>着重练：胸肌、三角肌前束、三角肌中束、腹直肌。</li>\n<li>适当练：背阔肌、肱二头肌、肱三头肌、股四头肌、腹斜肌。</li>\n<li>少练：股二头肌。</li>\n<li>不练：斜方肌。</li>\n</ul>\n<p>在器械锻炼的基础上，加入有氧训练，控制体脂。</p>\n<p>具体参见<a href=\"https://www.zhihu.com/question/26072319\" target=\"_blank\" rel=\"external\">要想穿衣服好看，男生需要练好哪几块肌肉？</a></p>\n<h2 id=\"热身\"><a href=\"#热身\" class=\"headerlink\" title=\"热身\"></a>热身</h2><p>按照自己的身体做调整，只要热身完身体发热即可，不用满头大汗。因此可以在跑步机上快走6-10分钟，或者慢跑6分钟。</p>\n<h2 id=\"拉伸\"><a href=\"#拉伸\" class=\"headerlink\" title=\"拉伸\"></a>拉伸</h2><p>训练前拉伸为了让肌肉活动开，防止运动时损伤；训练后拉伸为了放松肌肉。</p>\n<p>训练前拉伸非常重要，比如做正式卧推之前，先拉伸胸、肩，再做两组空杠卧推热身。</p>\n<h2 id=\"胸\"><a href=\"#胸\" class=\"headerlink\" title=\"胸\"></a>胸</h2><p><img src=\"http://www.wildhorde.com/wp-content/uploads/2015/09/bc96032803bd8dbd03e0cc7c0390b1a1.jpg\" alt=\"\"></p>\n<p><a href=\"http://i.imgur.com/18s3xIJ.jpg\" target=\"_blank\" rel=\"external\">胸部拉伸</a>：右小臂与大臂垂直，小臂靠墙贴着，右脚向前，左脚向后，身体旋转感觉到胸部紧绷，保持15秒。</p>\n<p>胸部动作之前还需要做肩部拉伸。</p>\n<ul>\n<li>(仰卧/上斜/下斜)杠铃卧推：使用史密斯架或自由杠。躺下，挺胸收腹沉肩，双手握距略宽于肩，（仰卧：杠铃位于乳头上方1cm处；上斜：凳子夹角40度，杠铃位于锁骨处；下斜：杠铃位于下胸处）。下来时吸气，小臂保持与地面垂直，肩部始终下沉往后夹，直到杠铃贴到胸部停止；上来时呼气，胸部发力，肩部始终锁死。普通人能推自身重量即可，别太追求重量，没意义。具体细节请看:<a href=\"https://www.zhihu.com/question/26379252/answer/86802532\" target=\"_blank\" rel=\"external\">如何做标准的卧推？</a>。补充资料：<a href=\"https://www.zhihu.com/question/23398328/answer/45086251\" target=\"_blank\" rel=\"external\">卧推时肩部关节疼痛，为什么？</a>。</li>\n<li><a href=\"http://i.imgur.com/5Ph0SpF.gif\" target=\"_blank\" rel=\"external\">(仰卧/上斜/下斜)哑铃卧推</a>：挺胸收腹沉肩，两只手伸直垂直于地面，两只手腕稍微倾斜一点角度（为了不让手肘向外）。下来时，控制好大臂和小臂的角度，小臂别太向外，小臂直到与大臂垂直时停止；上来时，胸部发力，直到两个哑铃碰到一起时停止。</li>\n<li>(仰卧/上斜/下斜)哑铃飞鸟：挺胸收腹沉肩，手伸直朝上，整个手臂与身体垂直，靠太近会让胸内侧肌肉放松。下去时，控制大臂角度，感觉胸部有拉伸感停止；上来时，用胸部发力，直到手臂与身体垂直即可停止。</li>\n<li><a href=\"http://v.youku.com/v_show/id_XODU3NzQ4NTU2.html?from=y1.6-85.3.1.8aa540c8c87211e4b432\" target=\"_blank\" rel=\"external\">俯卧撑</a>：初始时，两手宽度略宽于肩（小臂与地面垂直），双手垂直于地面（差不多在胸前），挺胸收腹沉肩，两只脚并拢；下去时，肘关节向后45度弯曲，到胸部贴近地面为止；上来时，胸部发力。</li>\n<li>蝴蝶夹胸：胸中缝。</li>\n<li>龙门十字夹胸：胸下沿，胸中缝。</li>\n<li>双杠臂屈伸：胸下沿。</li>\n</ul>\n<h2 id=\"肱三头肌\"><a href=\"#肱三头肌\" class=\"headerlink\" title=\"肱三头肌\"></a>肱三头肌</h2><p><a href=\"http://i.imgur.com/Th46o7n.jpg\" target=\"_blank\" rel=\"external\">肱三头肌拉伸</a>：双脚并拢站立，一侧手臂屈肘向后，另一侧手臂抓住屈肘手臂向自己一侧拉，以拉伸手臂肱三头肌，保持15秒。</p>\n<ul>\n<li><a href=\"http://www.jianshen8.com/uploads/allimg/130722/2_130722111500_5.gif\" target=\"_blank\" rel=\"external\">俯姿单臂哑铃臂屈伸</a>：左手抓着墙，腰背挺直，身体向前，两脚微屈，右手大臂夹紧身体，方向与身体一致，肩不要动。小臂举起放下。</li>\n<li><a href=\"http://i.imgur.com/5zulmw9.gif\" target=\"_blank\" rel=\"external\">坐姿臂屈伸</a>：双手距离和臀部宽度差不多，双脚微屈，全脚掌着地，身板靠近凳子，挺直，与地面垂直。下去时，身体直下，直到大臂与地面平行停止；上来时，胸部发力顶起。</li>\n<li><a href=\"http://imgsrc.baidu.com/forum/w%3D580/sign=625a2bc3c995d143da76e42b43f28296/166beb24b899a9016cf59cf61c950a7b0008f58d.jpg\" target=\"_blank\" rel=\"external\">哑铃颈后臂屈伸</a>：双手拿着哑铃，举在头顶，两手肘向内收。下来时，手肘始终向内收，等哑铃全部位于头顶之下时停止；上来时，手肘也是向内收。</li>\n<li><a href=\"http://ww2.sinaimg.cn/large/7d1f04a3jw1ehsqczid8ug208w04wdt6.gif\" target=\"_blank\" rel=\"external\">杠铃仰卧臂屈伸/法式弯举</a>：双手握距差一只手距离（或更多一些），两个手的肘关节朝内收。下来时，大臂不要动，小臂弯曲时肘关节不要向外。（做完之后马上再做窄距卧推）</li>\n<li><a href=\"http://b.hiphotos.baidu.com/zhidao/wh%3D450%2C600/sign=a8d35b9370094b36dbc713e996fc50ef/63d0f703918fa0ec9184c141209759ee3d6ddb3f.jpg\" target=\"_blank\" rel=\"external\">哑铃仰卧臂屈伸</a>。</li>\n<li><a href=\"http://www.jianshen8.com/uploads/allimg/130722/2_130722122439_2.gif\" target=\"_blank\" rel=\"external\">窄距俯卧撑</a>：两只手握距比肩窄，手肘向内收。下去时，肘关节向后弯曲。</li>\n<li><a href=\"http://www.cn-boxing.com/upFiles/infoImg/coll/20140802/OT20140802195014542.jpg\" target=\"_blank\" rel=\"external\">窄距杠铃卧推</a>：握距小于肩宽，杠铃位于乳头下方。</li>\n<li><a href=\"http://s8.sinaimg.cn/mw690/001UiZqQgy6JnBzQGJpd7&amp;690\" target=\"_blank\" rel=\"external\">站姿哑铃单手臂屈伸</a>。</li>\n</ul>\n<h2 id=\"背\"><a href=\"#背\" class=\"headerlink\" title=\"背\"></a>背</h2><p><img src=\"http://i3.hoopchina.com.cn/blogfile/201108/13/131320252566927.jpg\" alt=\"\"></p>\n<p><a href=\"http://img4.imgtn.bdimg.com/it/u=3264610090,1152896002&amp;fm=21&amp;gp=0.jpg\" target=\"_blank\" rel=\"external\">下背部拉伸</a>：双脚轻松盘坐，上半身往前靠近小腿。</p>\n<ul>\n<li><a href=\"http://img5.imgtn.bdimg.com/it/u=3493089361,1812617030&amp;fm=21&amp;gp=0.jpg\" target=\"_blank\" rel=\"external\">单臂哑铃划船</a>(One Arm Dumbbell Bent-over Row)：锻炼一侧背阔肌。左手和左脚放在平板凳上做支撑，左脚朝向正前方，不要歪，背部挺直，身体朝前，左手轻放在平板凳平衡，右脚稍弯，右手持哑铃垂直向下，头目视前方，背部发力，手臂紧贴身体，保持小臂和大臂保持90度以上；上来时，用背部用力，拉到小臂与身体平行停止。</li>\n<li><a href=\"http://i.imgur.com/13c0mgw.gif\" target=\"_blank\" rel=\"external\">杠铃划船</a>(Barbell Row)：分为正手（练背内侧）和反手（练背外侧）。双脚与肩同宽，膝盖微微弯曲（150度），别弯的太过，背挺直(背差不多与身体垂直)，杠铃沿着大腿拉到小腹位置，拉起时呼气，放下时吸气。</li>\n<li><a href=\"http://i.imgur.com/3EU0Nt6.gif\" target=\"_blank\" rel=\"external\">杠铃屈腿硬拉</a>(deadlift)：下背部。起始时，双脚宽度和肩宽差不多，双手握距贴着小腿，小腿贴着杠铃，<a href=\"https://pic4.zhimg.com/0ebd71d21afe3bb7c2322736a05bea4f_b.jpg\" target=\"_blank\" rel=\"external\">肩部略探出杠铃</a>，双手握住杠铃不用力，背挺直；上来时，杠铃始终贴着身体，最后挺胸，不能骨盆前倾；下去时，先挺屁股，再屈膝盖。具体请看<a href=\"https://www.zhihu.com/question/20770313/answer/38469326\" target=\"_blank\" rel=\"external\">如何完成标准的硬拉</a>。</li>\n<li><a href=\"http://img2.imgtn.bdimg.com/it/u=1044998908,3536940926&amp;fm=21&amp;gp=0.jpg\" target=\"_blank\" rel=\"external\">T杠俯身划船</a>：提胸沉肩，整个过程背部挺直。</li>\n<li><a href=\"http://img2.ph.126.net/1lVrE0uMLuV2uLf8-pXfmg==/2548192964179590947.jpg\" target=\"_blank\" rel=\"external\">高位下拉</a>。</li>\n<li><a href=\"http://www.jianshenjiaolian.com.cn/wp-content/uploads/2015/01/640.webp-2.jpg\" target=\"_blank\" rel=\"external\">TRX背部训练</a>：如果引体向上不行可以先做这个。两手抓住绳子，身体倾斜向上，手臂别用力，用背部力量拉起。</li>\n<li><a href=\"http://www.buildbody.net/wp-content/uploads/2014/07/33.png\" target=\"_blank\" rel=\"external\">引体向上</a>。</li>\n</ul>\n<h2 id=\"臀、腿\"><a href=\"#臀、腿\" class=\"headerlink\" title=\"臀、腿\"></a>臀、腿</h2><p><a href=\"http://i.imgur.com/l3n8iTC.jpg\" target=\"_blank\" rel=\"external\">大腿前侧拉伸</a>：一只手抓住固定物保持身体平衡，另一只手抓住同侧的脚背，并缓慢用力向臀部拉伸，保持15秒。</p>\n<p><a href=\"http://i.imgur.com/TIo7CWO.jpg\" target=\"_blank\" rel=\"external\">大腿后侧拉伸</a>。</p>\n<p><a href=\"http://i.imgur.com/bDWYj1R.jpg\" target=\"_blank\" rel=\"external\">臀部拉伸</a>：平躺在瑜伽垫，一只脚伸直，另一只脚屈膝，用双手抱住屈膝腿的膝盖以下部位，然后慢慢向身体侧用力压以拉伸臀部肌肉。拉伸的过程中要求伸直腿不要离开地面或者瑜伽垫，保持15秒。</p>\n<ul>\n<li><a href=\"http://i.imgur.com/hOQLcvz.gif\" target=\"_blank\" rel=\"external\">深蹲</a>(Squat)：双脚距离略宽与肩，但不要太宽，脚尖稍稍向外，腰背挺直，收腹；蹲下时，膝盖方向和脚尖方向一致，膝盖尽量不能超过脚尖，要有往后坐下的感觉，至大腿水平时停止，停顿2秒；起来时，臀部发力。</li>\n<li><a href=\"http://s7.sinaimg.cn/mw690/5113c62dgx6BxWiK5PEc6&amp;690\" target=\"_blank\" rel=\"external\">哑铃深蹲</a>(Dumbbell squat)：双手拿一个哑铃（或两个哑铃），具体拿法有很多种，其他和深蹲一样。</li>\n<li><a href=\"http://i.imgur.com/zOwj81N.gif\" target=\"_blank\" rel=\"external\">杠铃深蹲</a>：双手握距比肩宽很多，脚站在杠铃靠前，整个过程挺胸腰绷紧，沉肩，杠铃靠在斜方肌上（别靠在颈椎骨上）。蹲下时，膝盖不要超过脚尖；上来时，保持腰部臀部绷紧，身体别扭，腿臀发力。</li>\n<li><a href=\"http://s15.sinaimg.cn/mw690/af6eb839gd90f838a048e&amp;690\" target=\"_blank\" rel=\"external\">哈克深蹲</a>：有两种方法。第一种是用史密斯架，相比杠铃深蹲，双脚往前站，背部靠在杠铃上。第二种是专门的哈克深蹲机器。</li>\n<li><a href=\"http://wenwen.soso.com/p/20110218/20110218162126-749868155.jpg\" target=\"_blank\" rel=\"external\">原地哑铃箭步蹲</a>(Dumbbell lunge)：两手拿哑铃放在两边，眼睛直视前方，背挺直，别前倾。蹲下时，右脚膝盖别碰地；起来时，臀部发力。</li>\n<li><a href=\"http://v.youku.com/v_show/id_XODU3NzUyMDUy.html?from=y1.6-85.3.1.8aa540c8c87211e4b432\" target=\"_blank\" rel=\"external\">行走箭步蹲</a>(Walking Lunge)：双手抱头，眼睛直视前方，腰背始终挺直，左脚跨出一大步（步子大于走路的步子），左脚脚跟先落地；蹲下时，直到左大腿与地面平行，左脚膝盖不超过脚尖，停留2秒；起来时，注意臀部发力。</li>\n<li><a href=\"http://s3.sinaimg.cn/mw690/5113c62dgx6BxPbmJQ6b2&amp;690\" target=\"_blank\" rel=\"external\">保加利亚深蹲</a>(Bulgarian squat)：提高身体稳定性。右脚放于板凳上，蹲下直到左大腿与地面平行。</li>\n<li><a href=\"http://cdn.neonan.com/uploads/081d0575-5b9e-4089-beba-23b8191471c1.jpg\" target=\"_blank\" rel=\"external\">俯卧腿弯举</a>：股二头肌。</li>\n<li><a href=\"http://i.imgur.com/jA9wQJN.gif\" target=\"_blank\" rel=\"external\">开合跳</a>：增加腿部力量。</li>\n<li><a href=\"http://statics.sportq.com/sqles/20151112/1447310539335087104.gif\" target=\"_blank\" rel=\"external\">深蹲跳</a>：提高肌耐力。</li>\n<li><a href=\"站姿提踵\">(杠铃/哑铃)站姿提踵</a>：小腿。</li>\n</ul>\n<p>小资料：</p>\n<ul>\n<li><a href=\"http://v.youku.com/v_show/id_XODMxMjYyMzY4.html?from=y1.6-85.3.1.8aa540c8c87211e4b432\" target=\"_blank\" rel=\"external\">如何瘦腿</a></li>\n</ul>\n<h2 id=\"肩\"><a href=\"#肩\" class=\"headerlink\" title=\"肩\"></a>肩</h2><p><a href=\"http://i.imgur.com/TY3J60x.jpg\" target=\"_blank\" rel=\"external\">肩拉伸</a>：双脚开立，一侧手臂屈肘从体前放于另一侧的肩膀后，另一只手按压屈肘手臂，以拉伸肩部肌肉，保持15秒。</p>\n<p>肩分为三角肌和斜方肌。</p>\n<p><img src=\"http://img0.imgtn.bdimg.com/it/u=1547971573,2261838022&amp;fm=11&amp;gp=0.jpg\" alt=\"\"></p>\n<ul>\n<li><a href=\"http://i.imgur.com/Y3MXJhz.gif\" target=\"_blank\" rel=\"external\">颈前杠铃肩上推举</a>：三角肌前束。可以用史密斯架或自由杠。</li>\n<li><a href=\"http://img0.imgtn.bdimg.com/it/u=911782007,2082802447&amp;fm=21&amp;gp=0.jpg\" target=\"_blank\" rel=\"external\">站姿/坐姿哑铃前平举</a>：三角肌前束。双手握住哑铃，放在大腿前方，保持手臂稍微弯曲，让手掌面对大腿。</li>\n<li><a href=\"http://www.nzjsw.com/wp-content/uploads/auto_save_image/2012/04/201558IjA.jpg\" target=\"_blank\" rel=\"external\">站姿杠铃前平举</a>：三角肌前束。双手宽握。</li>\n<li><a href=\"http://img5.imgtn.bdimg.com/it/u=317261622,47465381&amp;fm=21&amp;gp=0.jpg\" target=\"_blank\" rel=\"external\">坐姿哑铃推举</a>：三角肌中束。初始时，整个背紧靠在凳背，坐实，挺胸，收腹，双手大臂与地面平行，小臂与大臂垂直，小臂别往外。向上推举时手不要向前倾，最后哑铃举到头顶上方结束。</li>\n<li><a href=\"http://i.imgur.com/OpC1dhy.gif\" target=\"_blank\" rel=\"external\">直立杠铃提拉</a>：三角肌中束。</li>\n<li><a href=\"http://ww3.sinaimg.cn/large/a02cee3bjw1f22y9qlk6uj20i40ncwhv.jpg\" target=\"_blank\" rel=\"external\">哑铃侧平举</a>：三角肌中束。斜方肌、手臂别用力，光用三角肌发力。</li>\n<li><a href=\"http://www.jianshen8.com/uploads/allimg/141202/2_141202010305_1.jpg\" target=\"_blank\" rel=\"external\">哑铃俯身飞鸟</a>：三角肌后束。双脚与肩同宽，背挺直，背弯到几乎与地面平行。上来时，整个背不要动，到手臂与地面平行停止。</li>\n<li><a href=\"http://img2.imgtn.bdimg.com/it/u=854817596,2160368178&amp;fm=21&amp;gp=0.jpg\" target=\"_blank\" rel=\"external\">哑铃耸肩</a>：斜方肌。</li>\n</ul>\n<h2 id=\"肱二头肌\"><a href=\"#肱二头肌\" class=\"headerlink\" title=\"肱二头肌\"></a>肱二头肌</h2><p><a href=\"http://i.imgur.com/lpvm6RZ.jpg\" target=\"_blank\" rel=\"external\">肱二头肌拉伸</a>：靠墙的腿直立，另一只腿稍弯，在后面。重心在直立腿上，手抓着固定物，缓慢向前，15秒。</p>\n<ul>\n<li><a href=\"http://img5.imgtn.bdimg.com/it/u=3646966921,2848918640&amp;fm=21&amp;gp=0.jpg\" target=\"_blank\" rel=\"external\">哑铃交替弯举</a>：初始时，两脚与肩同宽，挺胸沉肩收腹，大臂夹紧身体，拿着哑铃手心向身体，手腕放松，和小臂成一条直线；动作缓慢，顶峰收缩。</li>\n<li><a href=\"http://img1.imgtn.bdimg.com/it/u=2802196776,1289866423&amp;fm=21&amp;gp=0.jpg\" target=\"_blank\" rel=\"external\">哑铃锤式弯举</a>：锻炼肱二头肌外侧。</li>\n<li><a href=\"http://i.imgur.com/rdhBGYa.jpg\" target=\"_blank\" rel=\"external\">单臂哑铃弯举</a>：初始时，右手手肘靠着大腿，小臂与大腿垂直，左手撑着保持平衡。</li>\n<li><a href=\"http://img.39yst.com/uploads/allimg/130917/151454G26-6.jpg\" target=\"_blank\" rel=\"external\">杠铃弯举</a>：初始时，两脚与肩同宽，双手握距与肩同宽，挺胸收腹，背挺直，大臂夹紧身体；上去时，手腕小臂别发力，感受肱二头肌发力，1秒；下去时，3秒，最后别伸直手臂，到小臂与竖直还有30度就停止。窄握杠铃练肱二外侧；宽握杠铃练肱二内侧。Tips:一开始可以身体贴墙，防止借力。</li>\n<li><a href=\"http://www.nzjsw.com/wp-content/uploads/2014/04/mu-shi-deng-zheng-fan-wo-xuan-zhuan-ya-ling-wan-ju.gif\" target=\"_blank\" rel=\"external\">单臂牧师凳哑铃弯举</a>：初始时，将整个手臂放在哑铃凳，另一只手抓哑铃凳平衡身体；慢上慢下。</li>\n<li><a href=\"http://img.ph.126.net/Xloh0Ef_5XvQDlkK38G6sg==/3356589097274871160.gif\" target=\"_blank\" rel=\"external\">两臂杠铃斜板弯举</a>。</li>\n<li><a href=\"http://img2.imgtn.bdimg.com/it/u=1807059083,3384958045&amp;fm=21&amp;gp=0.jpg\" target=\"_blank\" rel=\"external\">反手引体向上</a>。</li>\n</ul>\n<p>感受肱二头肌的挤压，注意用肱二头肌发力，小臂别发力，顶峰收缩。</p>\n<p>如果两只手的肱二头肌力量不一样，那么(1)平时多用弱势手，比如拎东西(2)多练弱势手，给弱势手多加几组练习(3)弱势手先发力，比如杠铃弯举，先意念用左手先发力。</p>\n<h2 id=\"腹\"><a href=\"#腹\" class=\"headerlink\" title=\"腹\"></a>腹</h2><p>腹肌是耐受肌，每天都能锻炼。而且由于腹部脂肪堆积多，因此要看得出马甲线、人鱼线，减脂是关键。</p>\n<p><img src=\"http://www.jirou.com/uploads/allimg/150520/1-150520092512101.jpg\" alt=\"\"></p>\n<p>腹肌锻炼需要注意腹部发力。一般的训练方法是分别挑选一个上腹、下腹、侧腹的动作，每个动作做4组，每组20-30个，但是要注意宁缺毋滥，宁可标准的动作做5个，也不要随便做30个。</p>\n<p>常见的腹肌动作大全：<a href=\"http://weibo.com/3782696734/BfQ56eaQ0\" target=\"_blank\" rel=\"external\">这里</a>和<a href=\"http://mp.weixin.qq.com/s?__biz=MzAxNzMxMDA2MA==&amp;mid=405913696&amp;idx=1&amp;sn=dc030619ff7d5246945cf98e778b892d&amp;scene=0#wechat_redirect\" target=\"_blank\" rel=\"external\">这里</a>。</p>\n<p>当然，著名的腹肌训练有：<a href=\"http://v.youku.com/v_show/id_XNDU2NTU0NTcy.html\" target=\"_blank\" rel=\"external\">6分钟腹肌急速锻炼</a>。但是新人要跟上节奏比较难。</p>\n<blockquote>\n<p>卷腹动作要领：<a href=\"http://ww2.sinaimg.cn/bmiddle/6af1ea26jw1epjejbuu6vj20yig79u0z.jpg\" target=\"_blank\" rel=\"external\">这里</a>。</p>\n</blockquote>\n<p>锻炼完挤压腹部肌肉。</p>\n<p>锻炼完<a href=\"https://pic3.zhimg.com/34250f10d7b0c6a49b523dc5bdfdacbe_b.jpg\" target=\"_blank\" rel=\"external\">腹部拉伸</a>：平躺伸展身体即可。可以参见<a href=\"https://www.zhihu.com/question/36825467\" target=\"_blank\" rel=\"external\">如何腹部拉伸</a>。</p>\n<h2 id=\"腰\"><a href=\"#腰\" class=\"headerlink\" title=\"腰\"></a>腰</h2><ul>\n<li><a href=\"http://admin.120.net/pub/ueditor/php/upload/20130305/13624664727708.png\" target=\"_blank\" rel=\"external\">壶铃摆动</a>(kettlebell swing)：双脚稍宽于肩，按照深蹲姿势蹲下，双手拿壶铃，先往后甩一些，起来时用腰部发力，将壶铃摆起至与地面平行，反复不停顿。</li>\n<li><a href=\"http://www.iqiyi.com/w_19rslbd8mh.html\" target=\"_blank\" rel=\"external\">罗马椅挺身</a>。</li>\n</ul>\n<h2 id=\"小臂\"><a href=\"#小臂\" class=\"headerlink\" title=\"小臂\"></a>小臂</h2><p>小臂一般不会特地练，因为很多动作都会用到小臂，但是平常也可以自己练练。</p>\n<ul>\n<li><a href=\"http://www.jirou.com/html/yljs/2011/1109/4266.html\" target=\"_blank\" rel=\"external\">反握哑铃腕弯举</a>。</li>\n<li><a href=\"http://www.nzjsw.com/wp-content/uploads/2014/07/zhan-zi-fan-wo-gang-ling-wan-ju.gif\" target=\"_blank\" rel=\"external\">站姿反握杠铃弯举</a>。</li>\n<li><a href=\"http://www.nzjsw.com/wp-content/uploads/2014/07/ya-ling-wan-fan-zhuan.gif\" target=\"_blank\" rel=\"external\">哑铃腕翻转</a>。</li>\n</ul>\n<h2 id=\"肌肉图\"><a href=\"#肌肉图\" class=\"headerlink\" title=\"肌肉图\"></a>肌肉图</h2><div><br><br><img src=\"http://i.imgur.com/abtip8c.jpg\" width=\"400px\"><br><br><img src=\"http://i.imgur.com/SudgwjU.jpg\" width=\"400px\"><br><br></div>\n\n<h2 id=\"减脂\"><a href=\"#减脂\" class=\"headerlink\" title=\"减脂\"></a>减脂</h2><p>多做有氧运动，最简单就是跑步，通常安排在无氧运动之后，跑45分钟。</p>\n<p><a href=\"http://i.imgur.com/CHVRpOZ.jpg\" target=\"_blank\" rel=\"external\">新手8周跑步计划</a>。</p>\n<p>如果没太多时间跑步或者在增肌期，由于长时间跑步会消耗肌肉，因此可以做HIIT(High-Intensity Interval Training，高强度间歇性训练)，这是一个训练方法，并没有指定具体的训练动作，任何高强度动作都能加入其中。可以通过网络或APP（Keep，FitTime）查找具体HIIT方案，跟着视频练。</p>\n<p>HIIT常见动作有：深蹲、开合跳、波比跳、俯卧撑、登山跑等。</p>\n<p>腿部拉伸：<a href=\"http://bbs.running8.com/thread-273296-1-1.html\" target=\"_blank\" rel=\"external\">这里</a>。</p>\n<h2 id=\"心率\"><a href=\"#心率\" class=\"headerlink\" title=\"心率\"></a>心率</h2><p>这里提心率（Heart Rate）是因为减脂需要让心率到达一定范围，不然起不到很好的减脂效果；热身也有一定的心率范围。</p>\n<p>这里我们用”心率储备法”来建立目标心率。</p>\n<p>储备心率=220-年龄-静态心率。</p>\n<p><img src=\"http://img3.douban.com/view/group_topic/large/public/20687944-1.jpg\" alt=\"\"></p>\n<p>上图中，50% 表示 “储备心率*50%+静态心率”。</p>\n<p>因此从图中可以看出：</p>\n<ul>\n<li>热身：储备心率的50%-60%。</li>\n<li>减脂：储备心率的60%-70%。</li>\n<li>提高心肺：储备心率的70%-80%。</li>\n<li>无氧：储备心率的80%-90%。</li>\n</ul>\n<h2 id=\"吃\"><a href=\"#吃\" class=\"headerlink\" title=\"吃\"></a>吃</h2><p>健身爱好者流行的一句话：三分练，七分吃。如果光练不吃，那么事倍功半。对于减脂的人，也不用饿肚子，而是要科学地吃。</p>\n<p>如果增肌，一天至少6餐（加餐时间：早饭中饭之间，中饭晚饭之间，睡觉前2小时），当然其他时间也可以吃东西；如果减脂，也可以少食多餐，把三餐的量分成六餐吃。</p>\n<p>问：鸡胸肉能用鸡腿肉代替吗？答：能，不要吃鸡皮，两个蛋白质差不多。</p>\n<p>这里的饮食主要针对减脂人群，因为增肌人群不需要限制太多，比如减脂人群不建议吃白米饭，而增肌人群可以吃。</p>\n<h3 id=\"基础营养理论\"><a href=\"#基础营养理论\" class=\"headerlink\" title=\"基础营养理论\"></a>基础营养理论</h3><ul>\n<li>蛋白质：促进组织修复，长肌肉。因此训练完要补充足够的蛋白质（当然同时也要补充碳水）。鸡蛋、鸡胸肉、牛肉、牛奶都很不错。</li>\n<li>碳水化合物：提供能量。分为简单碳水（高GI值，比如白米饭、白面包、蛋糕、披萨）和复杂碳水（低GI值，比如糙米饭、全麦面包、紫薯、燕麦），GI值越高表示升糖速度越快，越容易饿，导致多余的糖分变成脂肪。因此减脂人群建议吃低GI值碳水，高GI值碳水只能在训练后吃。</li>\n<li>脂肪：分为饱和脂肪（动物脂肪）和不饱和脂肪（坚果、橄榄油），推荐吃不饱和脂肪。</li>\n</ul>\n<h3 id=\"每天推荐摄入量\"><a href=\"#每天推荐摄入量\" class=\"headerlink\" title=\"每天推荐摄入量\"></a>每天推荐摄入量</h3><ul>\n<li>蛋白质：普通1g/kg，健身的人要1.5-2g/kg。</li>\n<li>碳水化合物：普通4g/kg，减脂2g/kg，增肌5g/kg。</li>\n<li>脂肪：0.45g/kg。</li>\n<li>胆固醇：小于300mg。而蛋黄是高胆固醇食物，一天正常吃1个蛋黄，最多2个。</li>\n</ul>\n<p>Tips:</p>\n<ul>\n<li>一个蛋（50g）中蛋白质有7g，其中蛋白的蛋白质有3g。</li>\n<li>一满勺燕麦10g。</li>\n<li>一片吐司25g。</li>\n</ul>\n<p>食物的营养可通过<a href=\"http://www.boohee.com/\" target=\"_blank\" rel=\"external\"><strong>薄荷网</strong></a>查询。</p>\n<h3 id=\"训练前后饮食\"><a href=\"#训练前后饮食\" class=\"headerlink\" title=\"训练前后饮食\"></a>训练前后饮食</h3><p>训练前：</p>\n<ul>\n<li>不能空腹。因为训练需要消耗能量，而糖是主要的能量来源，空腹会导致能量供应不足，从而分解蛋白质（肌肉）作为能量，不利于增肌。</li>\n<li>在训练前1小时要吃中低GI值碳水（全麦面包、燕麦片、苹果、番茄、腰果、花生等），以便在训练时能持续提供能量。</li>\n</ul>\n<p>训练后：肌肉吸收糖和蛋白质的黄金时期，需要马上吃高GI值的碳水（面包、馒头、土豆、三明治）+易吸收蛋白质（蛋白粉、鸡蛋、牛奶）+少脂肪（脂肪会抑制生长激素，所以训练后吃巧克力，虽然有碳水，但是也有脂肪）。</p>\n<h3 id=\"早餐\"><a href=\"#早餐\" class=\"headerlink\" title=\"早餐\"></a>早餐</h3><p>早餐遵循”高蛋白，低碳水，适当脂肪”原则。</p>\n<ul>\n<li>主食类：紫薯半个；玉米半个；全麦面包；燕麦片（如果觉得单吃燕麦很单调，可以试试<a href=\"http://v.youku.com/v_show/id_XMTI5NDg3Nzk5Mg==.html?from=y1.7-2\" target=\"_blank\" rel=\"external\">烤燕麦</a>）。</li>\n<li>蛋白质类：蛋白2个，蛋黄1个；虾肉；鱼肉；牛肉。</li>\n<li>蔬菜类：黄瓜；番茄；西兰花；生菜；卷心菜。</li>\n<li>水果类：苹果；柚子；橙子。</li>\n<li>奶豆类：牛奶；豆浆。</li>\n<li>坚果类：开心果5个。</li>\n</ul>\n<p>主食类补充碳水化合物；蛋白质类，奶豆类补充蛋白质；蔬菜水果类补充维生素，膳食纤维。</p>\n<p>范例：<a href=\"http://photo.weibo.com/1794629863/wbphotos/large/mid/3838133437230280/pid/6af7e0e7jw1erq4mvm6dej20hs4ayas6\" target=\"_blank\" rel=\"external\">1</a>，<a href=\"http://ww2.sinaimg.cn/bmiddle/e1775f1egw1erc2ykky92j20le2xutv4.jpg\" target=\"_blank\" rel=\"external\">2</a>，<a href=\"http://mmbiz.qpic.cn/mmbiz/hFdY52oozXjNqkNBJBF9DyX60yzVQxEGorVVkbXscz1Za9DGPs7aB0uQ3Xo9J5AbDD1fUCEibCrlgr2EJTLU5xA/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1\" target=\"_blank\" rel=\"external\">3</a>。</p>\n<h3 id=\"午餐，晚餐\"><a href=\"#午餐，晚餐\" class=\"headerlink\" title=\"午餐，晚餐\"></a>午餐，晚餐</h3><ul>\n<li>主食类：紫薯；玉米；杂粮饭；糙米饭；荞麦面。</li>\n<li>蔬菜类：2种。</li>\n<li>肉类：牛肉；鸡胸肉；鱼肉（龙利鱼，金枪鱼罐头，煎三文鱼）；虾肉；花蛤。</li>\n</ul>\n<p>范例：<a href=\"http://photo.weibo.com/1794629863/wbphotos/large/mid/3838133437230280/pid/6af7e0e7jw1erq4mzz2hcj20hs4ay1hx\" target=\"_blank\" rel=\"external\">1</a>，<a href=\"http://photo.weibo.com/1794629863/wbphotos/large/mid/3838133437230280/pid/6af7e0e7jw1erq4n3bsfqj20hs4ayaup\" target=\"_blank\" rel=\"external\">2</a>，<a href=\"http://ww4.sinaimg.cn/bmiddle/e1775f1egw1erc2yjzc0cj20ic2ikwwm.jpg\" target=\"_blank\" rel=\"external\">3</a>，<a href=\"http://photo.weibo.com/3782696734/wbphotos/large/mid/3833732354461022/pid/e1775f1egw1erc2yj7741j20le2xuqtz\" target=\"_blank\" rel=\"external\">4</a>，<a href=\"http://mmbiz.qpic.cn/mmbiz/hFdY52oozXjNqkNBJBF9DyX60yzVQxEGorVVkbXscz1Za9DGPs7aB0uQ3Xo9J5AbDD1fUCEibCrlgr2EJTLU5xA/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1\" target=\"_blank\" rel=\"external\">5</a>。</p>\n<h2 id=\"具体训练计划\"><a href=\"#具体训练计划\" class=\"headerlink\" title=\"具体训练计划\"></a>具体训练计划</h2><p>初学者常见的困惑是：有没有特别详细的训练计划，只要跟着做就可以的那种。这里给出几个非常具体的训练计划，都是从其他网站找到的。</p>\n<ul>\n<li><a href=\"http://i.imgur.com/u98weRJ.png\" target=\"_blank\" rel=\"external\">男性减脂增肌计划</a>，附<a href=\"http://i.imgur.com/eGsoxH4.png\" target=\"_blank\" rel=\"external\">训练动作详解表</a>。</li>\n<li><a href=\"http://i.imgur.com/MNFqqJY.png\" target=\"_blank\" rel=\"external\">男性瘦体型增肌计划</a>，附<a href=\"http://i.imgur.com/eGsoxH4.png\" target=\"_blank\" rel=\"external\">训练动作详解表</a>。</li>\n<li><a href=\"http://i.imgur.com/Egi2zr6.jpg\" target=\"_blank\" rel=\"external\">哑铃锻炼计划</a>。</li>\n<li><a href=\"http://i.imgur.com/ZsS6FTb.jpg\" target=\"_blank\" rel=\"external\">瘦的人初步训练增肌计划</a>。</li>\n<li><a href=\"http://i.imgur.com/ffd88Rj.png\" target=\"_blank\" rel=\"external\">瘦子增肌计划</a>。</li>\n</ul>\n<p>常规的训练方法：</p>\n<ul>\n<li>1234训练法：1天练2个部位（1个大肌群+1个小肌群），每个部位3个动作，每个动作4组。</li>\n<li>常见搭配：胸+三头；背+二头；肩+腿臀。</li>\n</ul>\n<p>新手一般承受不了上面的训练方法，可以使用我私教的训练安排：</p>\n<ul>\n<li>胸+肩+三头：每个部位2-3个动作，每个动作4组。</li>\n<li>腿+背+二头：每个部位2-3个动作，每个动作4组。</li>\n</ul>\n<h2 id=\"补充资料\"><a href=\"#补充资料\" class=\"headerlink\" title=\"补充资料\"></a>补充资料</h2><ul>\n<li><a href=\"http://www.youku.com/show_page/id_z8aa540c8c87211e4b432.html\" target=\"_blank\" rel=\"external\">视频：MiklingFitness</a></li>\n<li><a href=\"http://tieba.baidu.com/p/2488373797\" target=\"_blank\" rel=\"external\">视频：牛男健身教程</a></li>\n<li><a href=\"http://www.youku.com/playlist_show/id_17885933.html\" target=\"_blank\" rel=\"external\">视频：Six Pack Shortcuts</a></li>\n<li><a href=\"http://pan.baidu.com/s/1miRHTdm\" target=\"_blank\" rel=\"external\">书籍：Bigger Leaner Stronger</a></li>\n</ul>\n","categories":[],"tags":["生活"]},{"title":"Git基本使用指南","url":"http://xiazdong.github.io/2016/01/28/Git基本使用指南/","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>本人接触 Git 也有两年了，但是之前只是草草学习，没有很好的掌握他，主要原因是没有工作需要(在学校里面哪用的到Git…)。我觉得 Git 这个工具在学校里很难充分了解到他，只有在公司里十几个人一起开发项目时才会感觉到他的优越性。</p>\n<p>作为一个程序员，学习 Git 的原因有两个：</p>\n<ol>\n<li>在工作中一个项目肯定要多人完成，多人协作开发再正常不过了。</li>\n<li>Github 越来越火，要用 Github 就必须要会 Git。</li>\n</ol>\n<p>因此 Git 目前已经是一个软件开发人员默认的必会技能。</p>\n<p>在工作中一般首选是用 Git 的 GUI 工具来操作 Git(这里推荐 Tower，用起来特别顺手；Github Desktop 也不错， Sourcetree 用的人也非常多，而且跨平台)，因为在工作中一个项目一天的提交量超过200是很正常的，如果你要看今天哪些人提交了、提交了哪些内容，用命令行 <code>git log</code> 就很费劲，图形化界面的展示就看起来舒服很多。</p>\n<p>很多人说：用命令行看起来多帅啊。但是解决问题是第一位，你只要了解了 Git 的操作原理，用图形化界面能够更清晰地完成你的工作。</p>\n<blockquote>\n<p>我一般为了让自己不忘记 git 命令，都用命令行。</p>\n</blockquote>\n<p>本文会按照以下顺序介绍：</p>\n<ul>\n<li>Git 基本概念。</li>\n<li>Git 基本命令、分支命令、撤销命令、合并命令、patch命令、远程仓库命令。</li>\n<li>Github, Github Flow, Gist, Tig, Gitter。</li>\n</ul>\n<p>本文所用的软件或平台包括：</p>\n<ol>\n<li>MAC </li>\n<li>Git + Github</li>\n<li>Tower 2.1.0</li>\n<li>Beyond Compare 4</li>\n</ol>\n<blockquote>\n<p>Git 是 Global Information Tracker 的缩写，即对全局信息进行跟踪。</p>\n</blockquote>\n<p>等到阅读完本文，可以通过 <a href=\"http://pcottle.github.io/learnGitBranching/\" target=\"_blank\" rel=\"external\">Learn Git Branching</a> 验证下自己是不是真的学会了 Git。</p>\n<h2 id=\"Git-基本概念\"><a href=\"#Git-基本概念\" class=\"headerlink\" title=\"Git 基本概念\"></a>Git 基本概念</h2><blockquote>\n<p>Linus Torvalds 在 Google Talk 上做的关于 Git 的演讲：<a href=\"https://www.youtube.com/watch?v=4XpnKHJAok8\" target=\"_blank\" rel=\"external\">这里</a>，笔记见<a href=\"http://blog.tizgrape.com/linus-torvalds%E5%9C%A8google-talk%E4%B8%8A%E5%81%9A%E7%9A%84git%E6%BC%94%E8%AE%B2/\" target=\"_blank\" rel=\"external\">这里</a>。</p>\n</blockquote>\n<h3 id=\"Git-配置\"><a href=\"#Git-配置\" class=\"headerlink\" title=\"Git 配置\"></a>Git 配置</h3><p>在使用 Git 之前需要做2件事：</p>\n<ol>\n<li>配置 UserName(<code>git config --global user.name &quot;&lt;name&gt;&quot;</code>), Email(<code>git config --global user.email &lt;email&gt;</code>)。</li>\n<li>如果要连接远程代码托管网站(如 Github)，则需要生成 SSH 协议的 RSA 密钥和公钥。</li>\n</ol>\n<h4 id=\"命令自动补全\"><a href=\"#命令自动补全\" class=\"headerlink\" title=\"命令自动补全\"></a>命令自动补全</h4><p>为了让 Git 在 bash 中拥有类似 bash 的提示功能，比如输入 <code>git co</code>，再按两下 tab，则会提示可用命令有 <code>commit, config</code>，我们可以如下配置：</p>\n<ul>\n<li>下载 <a href=\"https://github.com/git/git/blob/master/contrib/completion/git-completion.bash\" target=\"_blank\" rel=\"external\">git-completion.bash</a> 文件放到用户主目录。</li>\n<li>在 <code>.bash_profile</code> 中添加 <code>source ~/git-completion.bash</code>。</li>\n</ul>\n<h4 id=\"修改默认编辑器\"><a href=\"#修改默认编辑器\" class=\"headerlink\" title=\"修改默认编辑器\"></a>修改默认编辑器</h4><p>默认 git 使用的编辑器是vim，如果想改成 sublime text，则步骤如下：</p>\n<ul>\n<li>在用户的工作目录创建 bin 目录。 </li>\n<li>命令行执行 <code>ln -s &quot;/Applications/Sublime Text.app/Contents/SharedSupport/bin/subl&quot; ~/bin/subl</code></li>\n<li>将 <code>~/bin/subl</code> 添加到环境变量 PATH 中(.zshrc 或 .bashrc 中)。</li>\n<li>命令行执行 <code>git config --global core.editor &quot;subl -n -w&quot;</code>。</li>\n</ul>\n<p>但是个人使用下来还是用 vim 作为默认编辑器体验最好，因为一直在命令行里面操作比较流畅。</p>\n<h4 id=\"HTTP-访问-Git-Server-免输入密码\"><a href=\"#HTTP-访问-Git-Server-免输入密码\" class=\"headerlink\" title=\"HTTP 访问 Git Server 免输入密码\"></a>HTTP 访问 Git Server 免输入密码</h4><p>本小节参考：</p>\n<ul>\n<li>安装 wget: 从 “<a href=\"http://ftp.gnu.org/gnu/wget/\" target=\"_blank\" rel=\"external\">http://ftp.gnu.org/gnu/wget/</a>“ 下载解压文件，并依次执行：<code>./configure --with-ssl=openssl</code>, <code>make</code>, <code>sudo make install</code>。</li>\n<li>下载 git-credential-netrc 脚本：<code>wget https://raw.githubusercontent.com/git/git/master/contrib/credential/netrc/git-credential-netrc</code></li>\n<li>git-credential-netrc 脚本拥有执行权限：<code>chmod +x git-credential-netrc</code></li>\n<li>将该脚本拷贝到 bin 目录(即放入 PATH 环境变量中)：<code>cp git-credential-netrc ~/bin/</code>。</li>\n<li>在用户目录下创建 .netrc 文件，内容为：</li>\n</ul>\n<p>模板如下：</p>\n<pre><code>machine &lt;git-server-host&gt;  # 比如 github.com\nlogin &lt;account&gt;\npassword &lt;your-password&gt;\nprotocol http\n</code></pre><ul>\n<li>对 .netrc 文件控制权限，因为里面有密码：<code>sudo chmod 0600 .netrc</code></li>\n<li>git 配置：<code>git config --global credential.helper &quot;~/bin/git-credential-netrc&quot;</code>。</li>\n<li>安装 GPG 命令：<code>sudo port install gnupg gnupg2</code>。</li>\n<li>生成 GPG key：<code>gpg --gen-key</code>。</li>\n<li>查看你的 GPG key: <code>gpg --list-keys</code></li>\n<li>用 GPG 密钥加密 .netrc 文件：<code>gpg -e -r &lt;你的gpg key&gt; .netrc</code><br><a href=\"http://www.sunzhongwei.com/http-git-server-without-password.html\" target=\"_blank\" rel=\"external\">http://www.sunzhongwei.com/http-git-server-without-password.html</a></li>\n</ul>\n<h3 id=\"Git-的基本组成部分\"><a href=\"#Git-的基本组成部分\" class=\"headerlink\" title=\"Git 的基本组成部分\"></a>Git 的基本组成部分</h3><ul>\n<li><strong>工作目录</strong>(working directory): 你在文件管理器中看得到的目录就是工作目录。 </li>\n<li><strong>暂存区</strong>(Stage Area or Index)。</li>\n<li><strong>本地仓库</strong>(Local Repository): Git 是分布式的版本控制系统，本地仓库就是本地的一个备份仓库。</li>\n<li><strong>远程仓库</strong>(Remote Repository): Github 中托管的(不是在本地的)仓库。</li>\n</ul>\n<blockquote>\n<p>目前有很多 Git 仓库的托管网站，国外有 Github, Bitbucket，国内有 Gitcafe, Coding.net，功能或许有些许区别，但是建议使用 Github，因为 Github 的知名度最高，而且著名的开源项目都会放在这托管，况且目前 Github 还没被封，即使被封了，最好也不要用国内的，原因1是指不定哪一天公司倒闭了，还要转移项目，多麻烦；原因2是 Github 生态圈已经构成，就像微信和来往功能可能差不多，但是你朋友全在用微信，你会用来往的概率大吗？当然为了熟悉 Git 的基本使用，用 Gitcafe, Coding.net 也是不错的选择，因为毕竟速度更快。</p>\n<p>Github 提供<a href=\"https://education.github.com/\" target=\"_blank\" rel=\"external\">学生特权</a>，包括免费 <code>.me</code> 的域名(小伙伴再也不用担心没有个人域名了)、让你的 Github 账号拥有5个私有仓库等。</p>\n</blockquote>\n<h3 id=\"文件的状态\"><a href=\"#文件的状态\" class=\"headerlink\" title=\"文件的状态\"></a>文件的状态</h3><p>工作目录中的文件共有几种常见状态：</p>\n<ul>\n<li><strong>Untracked</strong>: 未跟踪的，表示该文件没有被 Git 管理。</li>\n<li><strong>Unmodified</strong>: 被 Git 跟踪但工作目录中该文件没有被修改过。</li>\n<li><strong>Modified</strong>: 在工作目录中，该文件被改过了，但还没被加入暂存区。</li>\n<li><strong>Staged</strong>: 工作目录中文件被修改，并且已被加入暂存区。</li>\n<li><strong>Deleted</strong>: 工作目录中某个文件被删除，但是把这个删除操作还没提交到本地仓库。</li>\n<li><strong>Unmerged</strong>: 当文件处于冲突时的状态。</li>\n</ul>\n<h3 id=\"Git-提交历史\"><a href=\"#Git-提交历史\" class=\"headerlink\" title=\"Git 提交历史\"></a>Git 提交历史</h3><p>Git 提交的历史构成了一个有向无环图，每个节点是一个提交对象(Commit Object,其中包含SHA-1码、提交人的名字、提交人的邮箱、日期等)，每条边表示提交的顺序，比如 <code>u--&gt;v</code>，表示 <code>v</code> 是父节点，<code>u</code> 是子节点，即 <code>u</code> 是 <code>v</code> 的后一次提交，如下图：</p>\n<p><img src=\"http://i.imgur.com/OitUnUF.png\" width=\"700\"></p>\n<p>上图中可以看出：</p>\n<ul>\n<li>红色的如 <code>master</code>, <code>testing</code> 是</li>\n<li>分支名，我们可以在 <code>.git/refs/heads</code> 下看到有 <code>master</code> 和 <code>testing</code> 两个文件名(这是分支的实现方式，下文还会讲到)。</li>\n<li>HEAD 是一个指针，一般指向一个分支名(从图中也可以看出)，表示的是最后一次提交，实现方法是在 <code>.git/</code> 目录下有个 <code>HEAD</code> 文件，里面包含了他指向的分支名，比如 <code>ref: refs/heads/master</code>，但是 HEAD 指针也可以指向一个提交(<code>.git/HEAD</code> 文件的内容是一次提交的 HASH 值)，称为”detached HEAD”(分离式 HEAD)。</li>\n</ul>\n<blockquote>\n<p><a href=\"https://github.com/esc/git-big-picture\" target=\"_blank\" rel=\"external\">Git Big Picture</a> 是拓展命令，可以以图片格式输出整个 Git 树。</p>\n<p>Git 中 author 与 commitor 的区别：对于一个开源项目，如果你要贡献一段代码，你就是 author，帮你提交进项目的人就是 commitor。</p>\n</blockquote>\n<p>在公司中，如果要提交到公司内的 gitlab，需要使用公司邮箱，如果在提交中带有私人邮箱的提交，则会 push 不上去。经常遇到的问题是你在开发公司的项目，但是用的是私人邮箱提交，等到发现的时候已经来不及了。那怎么对过去的提交批量修改邮箱配置呢？在命令行执行下面命令即可：</p>\n<pre><code>git filter-branch -f --env-filter &quot;GIT_AUTHOR_NAME=&apos;&lt;new_name&gt;&apos;; GIT_AUTHOR_EMAIL=&apos;&lt;new_email&gt;&apos;;&quot; HEAD\n</code></pre><h2 id=\"Git-命令\"><a href=\"#Git-命令\" class=\"headerlink\" title=\"Git 命令\"></a>Git 命令</h2><p>下面介绍的命令都是在 Git 中很常用的，这些命令的含义也是必须要搞清楚的，当然这些命令在 Tower 中也能实现，所以平时工作可以使用 Tower 完成，没必要再用命令行。</p>\n<h3 id=\"基本命令\"><a href=\"#基本命令\" class=\"headerlink\" title=\"基本命令\"></a>基本命令</h3><ul>\n<li><code>git status</code>: 查看当前状态，包括当前处于哪个分支、有哪些修改的文件没加入暂存区、哪些修改的文件加入了暂存区但没提交。</li>\n<li><code>git add &lt;file&gt;</code>: 将 <code>&lt;file&gt;</code> 加入跟踪或将修改添加到暂存区。</li>\n<li><code>git add -A &lt;file&gt;</code>: 如果 <code>&lt;file&gt;</code> 被删除了，想把这个删除的改变提交上去，那么用上面的命令添加会失败，因此加 <code>-A</code>，表示将工作区对 <code>&lt;file&gt;</code> 的所有修改都提交到暂存区。因此删除文件建议使用 <code>git rm</code>，而不是从文件管理器直接删除。</li>\n<li><code>git add -p &lt;file&gt;</code>: 交互式地对 <code>&lt;file&gt;</code> 文件的部分内容进行暂存，而不是一起暂存。具体参见 <a href=\"http://www.oschina.net/translate/10-tips-git-next-level?cmp\" target=\"_blank\" rel=\"external\">这里</a></li>\n<li><code>git commit -m &lt;message&gt;</code>: 将暂存区的内容提交到本地仓库。</li>\n<li><code>git commit --amend</code>: 当你对上次提交不满意(比如漏了提交2个文件，或者多提交了文件，或者对提交输入的 message 不满意)，想重新提交，则使用 <code>--amend</code> 参数，效果是将暂存区的内容提交，并覆盖上次的提交。</li>\n<li><code>git commit -am &lt;message&gt;</code>: 多了 <code>-a</code> 参数，跳过 <code>git add</code> 命令直接提交。</li>\n<li><code>git commit --fixup &lt;SHA-1&gt;</code>: 创建一个新的提交，专门修复较早期 <code>&lt;SHA-1&gt;</code> 提交(比如有个文件忘提交了)，新提交的 commit message 和 <code>&lt;SHA-1&gt;</code> 的一样。</li>\n<li><code>git commit --squash &lt;SHA-1&gt;</code>: 和 <code>git commit --fixup &lt;SHA-1&gt;</code> 作用一样，只是新提交的 commit message 不是 <code>&lt;SHA-1&gt;</code> 的 commit message，而是自定义 commit message，默认是 <code>!squash &lt;eariler commit message&gt;</code>。</li>\n<li><code>git mv &lt;old&gt; &lt;new&gt;</code>: 将文件重命名(这里注意，不能手动直接改文件名哦！)，但是在本地仓库中还没生效，直到 <code>git commit</code> 之后才生效。  </li>\n<li><code>git diff &lt;file&gt;</code>: 查看工作目录和暂存区中 <code>&lt;file&gt;</code> 的区别。</li>\n<li><code>git diff --cached &lt;file&gt;</code>: 查看暂存区和本地仓库中 <code>&lt;file&gt;</code> 的区别。</li>\n<li><code>git diff &lt;SHA1&gt; &lt;SHA2&gt;</code>: 比较两次提交(<code>&lt;SHA1&gt;</code> 和 <code>&lt;SHA2&gt;</code>)的区别。</li>\n<li><code>git diff &lt;branch&gt; &lt;file&gt;</code>: 查看分支 <code>&lt;branch&gt;</code> 中的 <code>&lt;file&gt;</code> 和工作目录的 <code>&lt;file&gt;</code> 的区别。</li>\n<li><code>git log</code>: 查看提交的历史，包括提交的 SHA-1 码、谁提交了、什么时候提交的。</li>\n<li><code>git log --pretty=oneline</code>: 更简洁地显示提交历史，每个提交都只有一行，只显示 SHA-1 和 commit message。</li>\n<li><code>git blame &lt;file&gt;</code>: 查看 <code>&lt;file&gt;</code> 文件的每行是谁修改的，blame是责怪的意思，因此这个命令用来找罪魁祸首用。</li>\n<li><code>git show &lt;commit-id&gt;</code>: 显示 <code>&lt;commit-id&gt;</code> 的具体修改。</li>\n</ul>\n<blockquote>\n<p><code>.git/ORIG_HEAD</code> 文件的内容是一次提交的HASH值，他也是一个指针，指针名叫 “ORIG_HEAD”，当git进行一些危险操作比如merge，reset等时，git就会把进行危险操作之前的HEAD指针指向的提交保存到ORIG_HEAD中，以便用户后悔了，想恢复。</p>\n</blockquote>\n<p>一般在公司开发项目，tag 肯定会使用，比如在2015年8月12日要发 1.0 版本，那么到了那个时候，就会在某个提交处打上 v1.0 的 tag。</p>\n<p>tag 分为 lightweight tag(轻量级标签，只是指向一个提交，并不带任何 message)和annotated tag(带注释标签，标签带有注释)。所有标签都存放在 <code>.git/refs/tags</code> 目录中，每个标签是一个文件，如果是轻量级标签，则内容是提交的 HASH 值；如果是带注释标签，则内容是 Object 值。</p>\n<ul>\n<li><code>git tag</code>: 显示所有标签。</li>\n<li><code>git tag &lt;name&gt;</code>: 创建一个轻量级标签 <code>&lt;name&gt;</code>，并指向 HEAD。</li>\n<li><code>git tag &lt;name&gt; &lt;commit-id&gt;</code>: 创建一个轻量级标签 <code>&lt;name&gt;</code>，并指向 <code>&lt;commit-id&gt;</code>。</li>\n<li><code>git tag -a &lt;name&gt; -m &lt;message&gt;</code>: 创建一个带注释标签 <code>&lt;name&gt;</code>，他有注释 <code>&lt;message&gt;</code>。</li>\n<li><code>git show &lt;tag-name&gt;</code>: 查看 <code>&lt;tag-name&gt;</code> 标签的详细信息。</li>\n<li><code>git push --tags</code>: 将所有 tag 提交到远程仓库，因为默认的 <code>git push</code> 并不会提交 tag。</li>\n<li><code>git tag -d &lt;name&gt;</code>: 删除本地 tag。</li>\n<li><code>git push origin :refs/tags/&lt;name&gt;</code>: 将本地删除的名为 <code>&lt;name&gt;</code> 的 tag 推送到远程仓库。</li>\n</ul>\n<p>接下来介绍一个不太常用的命令：<code>git bisect</code> 相关命令，该命令主要用来排查某个未知时段出现的问题，假设你现在的代码是编译不过的(提交树为 <code>c1-&gt;c2-&gt;c3-&gt;c4-&gt;c5-&gt;c6</code>，当前提交是 c6)，你又不知道什么时候引入错误的，你唯一确定的是在 c1 提交的时候代码还是编译通过的，此时可以使用 <code>git bisect</code>，该命令的主要思想是通过二分查找的方法在提交树上确定问题发生在哪个提交上，并联系提交者。以前面的例子为例，我们执行下列命令：</p>\n<pre><code>git bisect start   # 开始二分查找问题\ngit bisect good c1 # c1 提交的时候代码还是好的\ngit bisect bad c6  # c6 提交的时候代码有问题\n</code></pre><p>运行完上面命令后，git 会进入 c1 到 c6 的中间提交状态，这里是 c4，当你发现 c4 提交代码还是好的，则执行 <code>git bisect good</code>，那么可以确定问题一定发生在 c5 到 c6 之间；如果 c4 提交代码是坏的，则执行 <code>git bisect bad</code>，那么可以确定问题一定发生在 c2 到 c4 之间；以此类推，通过二分查找的方法，能够更快的定位问题。</p>\n<p>定位完问题后，执行 <code>git bisect reset</code> 可以恢复执行 <code>git bisect start</code> 之前的状态。</p>\n<blockquote>\n<p><a href=\"http://gitbook.liuhui998.com/5_4.html\" target=\"_blank\" rel=\"external\">查找问题的利器 - Git Bisect</a></p>\n</blockquote>\n<h3 id=\"版本撤销或回退\"><a href=\"#版本撤销或回退\" class=\"headerlink\" title=\"版本撤销或回退\"></a>版本撤销或回退</h3><ul>\n<li><code>git checkout &lt;file&gt;</code>: 丢弃工作目录对 <code>&lt;file&gt;</code> 的修改，并用暂存区的 <code>&lt;file&gt;</code> 替换。</li>\n<li><code>git checkout HEAD &lt;file&gt;</code>: 将工作目录和暂存区的 <code>&lt;file&gt;</code> 用 HEAD 指针指向的 <code>&lt;file&gt;</code> 替换。</li>\n<li><code>git checkout &lt;branch&gt; &lt;file&gt;</code>: 用分支 <code>&lt;branch&gt;</code> 中的 <code>&lt;file&gt;</code> 替换工作目录和暂存区的 <code>&lt;file&gt;</code>。</li>\n<li><code>git rm &lt;file&gt;</code>: 删除工作目录和暂存区的 <code>&lt;file&gt;</code>，但是本地仓库没有影响，只有 <code>git commit</code> 才会从本地仓库中删除 <code>&lt;file&gt;</code>。因此如果你想删除一个文件，不要在文件管理器里删除，而要用 <code>git rm</code>。</li>\n<li><code>git rm --cached &lt;file&gt;</code>: 取消对 <code>&lt;file&gt;</code> 的跟踪，但是对于工作目录、本地仓库中和远程仓库中 <code>&lt;file&gt;</code> 的状态不会变化，只是在暂存区中删除 <code>&lt;file&gt;</code>。</li>\n<li><code>git reset HEAD &lt;file&gt;</code>: 将暂存区中的 <code>&lt;file&gt;</code> 用本地仓库的 HEAD 指针中 <code>&lt;file&gt;</code> 的状态替换，并将原本在暂存区中 <code>&lt;file&gt;</code> 的修改变为未暂存状态。 </li>\n<li><code>git reset --hard &lt;SHA-1&gt;</code>: 将工作目录和暂存区的状态回到 <code>&lt;SHA-1&gt;</code>。</li>\n<li><code>git reset --soft &lt;SHA-1&gt;</code>: 工作目录和暂存区内容不变，仅仅将 HEAD 指向 <code>&lt;SHA-1&gt;</code>。这个命令的使用场景：我在公司里面使用内部的 Gitlab，你如果要 push，则必须 <code>git config</code> 的邮箱配成公司邮箱才行，但是我一开始用我的私人邮箱进行了一次提交，就后悔了，因为一旦包含这次提交，我就不能把代码 push 到公司 Gitlab 上了。这时候想要丢弃这次提交，但是又想要工作目录仍然保存我最新修改的代码，这时候可以用 <code>git reset --soft</code>。</li>\n<li><code>git revert HEAD</code>: 生成新的提交，新的提交中撤销 HEAD 指向提交的修改内容。revert 表示”恢复”的意思，但是 “git revert” 和 “git reset” 的区别是：”git reset” 只是修改 HEAD 指针，而 “git revert” 是生成一个新的提交，比如 HEAD 指向的提交中添加了一行，那么在 “git revert” 生成的新的提交中删除该行，即 revert 某个提交实际上就是将原本添加的变成删除，将原本删除的变成添加。</li>\n<li><code>git revert &lt;commit-id&gt;</code>: 生成新的提交，新的提交中撤销 <code>&lt;commit-id&gt;</code> 提交的内容，撤销方法和上面一样，即 <code>&lt;commit-id&gt;</code> 提交中添加的，在新的提交中就删除。</li>\n<li><code>git reflog</code>: 显示 HEAD 指针曾经指向的所有提交，在<code>.git/logs/HEAD</code>文件中保存了HEAD这个列表。使用场景：找回丢失的提交(比如 <code>git reset --hard</code> 后悔了，但你又通过 <code>git log</code> 找不到原来的提交了，那么就可以使用 <code>git reflog</code>)。</li>\n</ul>\n<blockquote>\n<p>如果理解不了 <code>git checkout</code> 和 <code>git reset</code> 命令，可以看<a href=\"http://marklodato.github.io/visual-git-guide/\" target=\"_blank\" rel=\"external\">图解Git</a>，里面讲的非常清楚，讲清楚了很多教程中忽略的问题。</p>\n</blockquote>\n<p><code>git checkout</code> 适用于文件级别的撤销，<code>git reset --hard</code> 适用于仓库级别的撤销。</p>\n<h3 id=\"分支\"><a href=\"#分支\" class=\"headerlink\" title=\"分支\"></a>分支</h3><p>Git 的分支非常轻量级，实现方法是每个分支对应 <code>.git/refs/heads/</code> 目录下的一个文件，每个文件只包含一个 SHA-1 码，表示提交ID，比如文件<code>testing</code> 的内容是 <code>6c35ebf175daff89f32b9123529fe22d93d1d8d9</code>，因此一个分支名指向一个提交对象。</p>\n<blockquote>\n<p>因此鼓励 <strong>早点建分支，经常建分支</strong>。</p>\n</blockquote>\n<p>分支的合并主要采用<strong>三方合并</strong>：比如当前分支是 <code>master</code>，执行 <code>git merge testing</code>，表示将 <code>master</code>，<code>testing</code> 以及这两个分支的公共祖先进行三方合并。</p>\n<p>特性分支(Topic Branch): 用于实现某个单一功能而存在的分支。比如有一个项目，他有3个功能，我们就开3个特性分支。</p>\n<p>分支的合并主要有两种方法：merge 和 rebase，各有特色，rebase 能够形成更加线性的提交历史。</p>\n<blockquote>\n<p>使用 rebase 要遵循一个规则：永远不要衍合那些已经推送到远程仓库的提交，即比如你现在在本地完成了一个功能，最新的提交为01234，你把它推送到远程仓库之后，那么你就不能再衍合01234这个提交了，因为这会导致其他人的混乱。</p>\n</blockquote>\n<ul>\n<li><code>git branch &lt;name&gt;</code>: 保留本地目录、暂存区的修改，并创建名为 <code>&lt;name&gt;</code> 的分支（即创建一个指针，指向 HEAD 指针指向的分支对应的提交）。</li>\n<li><code>git checkout &lt;branch&gt;</code>: 将 HEAD 指针指向 <code>&lt;branch&gt;</code> 分支名，即当前分支为 <code>&lt;branch&gt;</code>。</li>\n<li><code>git checkout &lt;commit-id&gt;</code>: 将 HEAD 指针指向 <code>&lt;commit-id&gt;</code> 提交(一般 HEAD 指针都是指向分支名的)，形成 detached HEAD。</li>\n<li><code>git checkout -b &lt;name&gt;</code>: 创建分支 <code>&lt;name&gt;</code>，并将 HEAD 指针指向 <code>&lt;name&gt;</code> 分支，等价于(1)<code>git branch &lt;name&gt;</code>(2)<code>git checkout &lt;name&gt;</code>。</li>\n<li><code>git branch -d &lt;name&gt;</code>: 删除分支 <code>&lt;name&gt;</code>(其实只是删除分支文件而已)。</li>\n<li><code>git branch -D &lt;name&gt;</code>: 强力删除分支 <code>&lt;name&gt;</code>(Git 会自己判断是不是可以删除分支，和 <code>-d</code> 的区别是如果 Git 判断不能删除分支，则用 <code>-D</code> 可以强制删除)。</li>\n<li><code>git branch -a</code>: 列出全部的分支。</li>\n<li><code>git branch -r</code>: 列出远程分支。</li>\n<li><code>git branch</code>: 列出本地分支。</li>\n<li><code>git branch --merged</code>: 列出已经与当前分支合并的分支，通常列出的那些分支除了当前分支之外都可以删掉，因为已经没有任何作用了。</li>\n<li><code>git branch --no-merged</code>: 列出尚未和当前分支合并的分支。</li>\n<li><code>git stash</code>: 贮藏(stash)当前的状态，git专门有一个”stash栈”用来存放贮藏的多个状态。这个命令的使用场景是：你正在基于 dev 分支写代码，突然Boss说在 master 分支上出了个bug，快去修复。那么你写代码写到一半，怎么办？你想要像游戏一样先将当前状态存档，修复完了bug之后，再读档恢复到先前的状态。</li>\n<li><code>git stash pop</code>: 从”stash栈”弹出一个状态，并恢复该状态。具体的 stash 实现原理请看<a href=\"http://www.cnblogs.com/hustskyking/p/git-improve.html\" target=\"_blank\" rel=\"external\">这里</a>。</li>\n<li><code>git stash apply</code>: 和 <code>git stash pop</code> 不同，这个命令并不会从”stash栈”弹出状态，只是纯粹将栈顶的状态恢复。</li>\n<li><code>git merge &lt;name&gt;</code>: 将分支 <code>&lt;name&gt;</code> 合并入当前分支。</li>\n<li><code>git cherry-pick &lt;commit-1&gt; &lt;commit-2&gt; ... &lt;commit-n&gt;</code>: 将提交 <code>&lt;commit-1&gt; ... &lt;commit-n&gt;</code> 的提交内容在 HEAD 指针上按顺序重演一遍。比如有一系列提交：b1-&gt;b2-&gt;b3，HEAD 指向 b3，执行 <code>git cherry-pick b1 b2</code> 后，变成了 b1-&gt;b2-&gt;b3-&gt;b1-&gt;b2，HEAD 指向后一个 b2。这个命令的使用场景：当在所有分支上都出现了一个共同的小bug，此时就可以通过在一个分支上修改该bug，并将该bug的提交应用在其他的分支上。</li>\n<li><code>git cherry-pick &lt;start-commit&gt;..&lt;end-commit&gt;</code>: 和上一个命令一样，只是将 <code>&lt;start-commit&gt;</code> 到 <code>&lt;end-commit&gt;</code> 的所有提交(不包括 <code>&lt;start-commit&gt;</code>) 在 HEAD 指针上按顺序重演一遍。</li>\n<li><code>git cherry-pick &lt;start-commit&gt;^..&lt;end-commit&gt;</code>: 和上一个命令一样，只是将 <code>&lt;start-commit&gt;</code> 到 <code>&lt;end-commit&gt;</code> 的所有提交(包括 <code>&lt;start-commit&gt;</code>) 在 HEAD 指针上按顺序重演一遍。</li>\n<li><code>git rebase &lt;name&gt;</code>: 将当前分支衍合到 <code>&lt;name&gt;</code> 分支。将当前分支与 <code>&lt;name&gt;</code> 分支的公共祖先开始到当前分支的改变在 <code>&lt;name&gt;</code> 分支重演一遍，然后将当前分支移到最新处，<code>&lt;name&gt;</code> 分支不动。<code>rebase</code> 命令可以说是自动一系列的 <code>cherry-pick</code> 命令。比如现在分支 <code>b1</code> 和 <code>b2</code> 的公共祖先是 <code>b</code>，<code>b</code> 到 <code>b1</code> 之间有4次提交(c1,c2,c3,c4)，如果当前分支是 <code>b1</code>，且运行 <code>git rebase b2</code>，则会将这四次提交(c1,c2,c3,c4)重新在 <code>b2</code> 分支上重演一遍(形成的Git树为：b2-&gt;c1-&gt;c2-&gt;c3-&gt;c4)，并且将 <code>b1</code> 分支指向最新的那个提交，而 <code>b2</code> 分支不动。</li>\n<li><code>git rebase --onto &lt;SHA-1&gt; &lt;name&gt;</code>: 和上一条命令的区别在于，这条命令是从 <code>&lt;SHA-1&gt;</code> 提交开始在 <code>&lt;name&gt;</code> 分支上衍合，比如上面的例子，假设 <code>git rebase --onto c2 b2</code>，则将 c3,c4 衍合到 <code>b2</code>，即形成 b2-&gt;c3-&gt;c4，<code>b1</code> 分支指向 <code>c4</code> 提交。</li>\n<li><code>git rebase &lt;name&gt; &lt;fname&gt;</code>: 将 <code>&lt;fname&gt;</code> 分支衍合到 <code>&lt;name&gt;</code> 分支。</li>\n<li><code>git rebase -i &lt;start-commit&gt;</code>: 重新提交从 <code>&lt;start-commit&gt;</code> (不包括该提交)开始的所有提交。<code>-i</code> 表示进入交互模式，即打开一个编辑器，你可以选择删除某些提交，或修改某些提交的commit message，或合并某些提交为一个提交。因为这个命令比较复杂，这里举了例子：</li>\n</ul>\n<p>我们创建了7次提交，如下：</p>\n<figure class=\"highlight\"><table><tr><td class=\"code\"><pre><div class=\"line\">git log --pretty=oneline  # 第一步</div><div class=\"line\"></div><div class=\"line\">cc21fc335bc61ee49bc325ee59250fe7fd84496a g</div><div class=\"line\">63fb59217d78100405867774a377bae2974718ef f</div><div class=\"line\">b61cece6c683809f0bfe4ddc7dc4a6672af714ac e</div><div class=\"line\">511e6959690aa76fbfa055c1154af925b7516571 d</div><div class=\"line\">a7388b246adfe7c82d402b4280b18b825528d9e4 c</div><div class=\"line\">eab9c3451745efdbadbcd78c49feb56ffa834ddc b</div><div class=\"line\">8950be78e1cc5f8d1693c418d0a23a9681bb8042 a</div><div class=\"line\"></div><div class=\"line\">git rebase -i 8950be7     # 第二步</div><div class=\"line\"></div><div class=\"line\"># 打开编辑器后显示如下：</div><div class=\"line\"></div><div class=\"line\">pick eab9c34 b</div><div class=\"line\">pick a7388b2 c</div><div class=\"line\">pick 511e695 d</div><div class=\"line\">pick b61cece e</div><div class=\"line\">pick 63fb592 f</div><div class=\"line\">pick cc21fc3 g</div></pre></td></tr></table></figure>\n<p>你可以对该内容进行修改。</p>\n<ul>\n<li>删除某行表示取消该提交。</li>\n<li>pick: 使用该提交。</li>\n<li>reword: 和 pick 含义一样，但是可以修改 commit message（但是并不是直接在每行最右边直接修改，而是后来保存退出编辑器后再修改）。</li>\n<li>fixup: 将该提交和上一个提交合并为一个”新”提交，新提交的 commit message 只会使用上一个提交的 commit message。</li>\n<li>squash: 和 fixup 一样合并提交，只是可以自定义新提交的 commit message。</li>\n<li>如果只是想删除全部的提交，那就别用 <code>git rebase -i</code> 了，直接用 <code>git reset --hard</code>。</li>\n</ul>\n<p>我们可以修改如下：</p>\n<figure class=\"highlight\"><table><tr><td class=\"code\"><pre><div class=\"line\">reword eab9c34 b # 修改 eab9c34 提交的 commit message，等到保存退出后git会自动弹出编辑器让你自定义 commit message</div><div class=\"line\">#pick a7388b2 c  # 删除 a7388b2 提交</div><div class=\"line\">pick 511e695 d   # 将 511e695, b61cece, 63fb592 合并为一个提交，并使用 511e695 的 commit message</div><div class=\"line\">fixup b61cece e</div><div class=\"line\">fixup 63fb592 f</div><div class=\"line\">pick cc21fc3 g</div></pre></td></tr></table></figure>\n<p>当保存并退出编辑器后，git会从上到下执行每行的命令。</p>\n<blockquote>\n<p>合并分支时会出现冲突，对于代码量很大的文件，相比手工一行一行解决冲突，使用 Beyond Compare 更加方便。</p>\n</blockquote>\n<h3 id=\"patch相关命令\"><a href=\"#patch相关命令\" class=\"headerlink\" title=\"patch相关命令\"></a>patch相关命令</h3><p>“git format-patch” 命令用于生成补丁文件(.patch)，将这些补丁文件给其他人可以通过 “git am \\<patch-file\\>“ 应用这些补丁。在 Git 中，一次提交对应一个 .patch 文件，补丁文件的命名方式为：<code>&lt;id&gt;-&lt;message&gt;.patch</code>，\\<id\\>从 1 开始计数，\\<message\\> 是这次提交的第一行 commit message。因此如果要对多个提交生成补丁，则会生成多个 .patch 文件。</message\\></id\\></patch-file\\></p>\n<ul>\n<li><code>git format-patch -n</code>: 生成 HEAD 前 n 个提交的补丁(包含 HEAD 的提交)。</li>\n<li><code>git format-patch -n &lt;commit-id&gt;</code>: 生成 <code>&lt;commit-id&gt;</code> 的前 n 次提交的补丁(包含 <code>&lt;commit-id&gt;</code>)。</li>\n<li><code>git format-patch -1 &lt;commit-id&gt;</code>: 仅生成 <code>&lt;commit-id&gt;</code> 一次提交的补丁。</li>\n<li><code>git format-patch &lt;start-commit-id&gt; &lt;end-commit-id&gt;</code>: 生成 <code>&lt;start-commit-id&gt;</code> 开始到 <code>&lt;end-cimmit-id&gt;</code> 提交的补丁(包含 <code>&lt;start-commit-id&gt;</code>, <code>end-commit-id</code>)。</li>\n<li><code>git format-patch &lt;commit-id&gt;</code>: 生成 <code>&lt;commit-id&gt;</code> 之后的所有提交的补丁(不包含 <code>&lt;commit-id&gt;</code>)。</li>\n<li><code>git format-patch --root &lt;commit-id&gt;</code>: 生成从树根到 <code>&lt;commit-id&gt;</code> 的所有提交的补丁(包含 <code>&lt;commit-id&gt;</code>)。</li>\n<li><code>git am bugfix.patch</code>: 应用 bugfix.patch 补丁文件。</li>\n</ul>\n<blockquote>\n<p>生成多个补丁文件给他人会让别人应用补丁比较麻烦，因为不得不一个一个应用，因此可以通过 <code>git format-patch -3 --stdout &gt; bugfix.patch</code> 将所有生成的补丁合成一个 <code>bugfix.patch</code> 文件。</p>\n</blockquote>\n<h3 id=\"远程仓库相关\"><a href=\"#远程仓库相关\" class=\"headerlink\" title=\"远程仓库相关\"></a>远程仓库相关</h3><p>远程仓库相关有两个概念：</p>\n<ol>\n<li><strong>远程分支</strong> ：对远程仓库状态的索引。引入远程仓库之后，分支就分为了本地分支和远程分支，本地分支名字以 <code>&lt;分支名&gt;</code> 形式存在，远程分支名字以 <code>&lt;远程主机名&gt;/&lt;分支名&gt;</code> 形式存在。比如在克隆远程仓库后，就会出现 <code>origin</code> 的远程主机名，对应的URL是 <code>https://..../xx.git</code>，而远程仓库的 master 分支是 <code>origin/master</code>。</li>\n<li><strong>追踪分支</strong> ：在引入远程仓库之后，本地分支和远程分支会有一种追踪(相关联)的关系，比如本地分支 <code>master</code> 和远程分支 <code>origin/master</code> 拥有追踪关系，这种追踪关系可以自定义，也可以由 Git 自动赋予。</li>\n</ol>\n<blockquote>\n<p>对远程分支的进一步解释：</p>\n<p>他只是对远程仓库状态的索引。比如别人在远程仓库新建了一个 <code>test</code> 分支，而这个分支在你本地是没有的，则当你 <code>git fetch</code> 之后，本地只会有远程分支 <code>origin/test</code>，而不会有本地分支 <code>test</code>，你需要通过 <code>git checkout -b test origin/test</code> 创建内容和远程分支 <code>origin/test</code> 一样的本地分支 <code>test</code>。</p>\n</blockquote>\n<ul>\n<li><code>git clone &lt;url&gt;</code>: 克隆远程仓库 <code>&lt;url&gt;</code>，并赋予远程主机名 <code>origin</code>，这是克隆所有分支。</li>\n<li><code>git clone -b &lt;branch_name&gt; &lt;url&gt;</code>: 克隆远程仓库 <code>&lt;url&gt;</code> 的 <code>&lt;branch_name&gt;</code> 分支到本地。</li>\n<li><code>git clone -o &lt;remote&gt; &lt;url&gt;</code>: 克隆远程仓库 <code>&lt;url&gt;</code>，并赋予远程主机名 <code>&lt;remote&gt;</code>。</li>\n<li><code>git push &lt;remote-name&gt; &lt;local-branch&gt;:&lt;remote-branch&gt;</code>: 将本地 <code>&lt;local-branch&gt;</code> 分支提交到远程主机名为 <code>&lt;remote-name&gt;</code> 的 <code>&lt;remote-branch&gt;</code> 分支。</li>\n<li><code>git push origin master:master dev_01:dev_01 dev_02:dev_02</code>: <code>git push</code> 命令支持同时做几个推送命令，这条命令是同时推送 master, dev_01, dev_02 分支到远程仓库。</li>\n<li><code>git push &lt;remote-name&gt; &lt;local-branch&gt;</code>: 将本地分支 <code>&lt;local-branch&gt;</code> 提交到远程主机名为 <code>&lt;remote-name&gt;</code> 的与本地分支有追踪关系的远程分支。</li>\n<li><code>git push &lt;remote-name&gt; --force &lt;local-branch&gt;:&lt;remote-branch&gt;</code>: 假设你改错了个东西，并且提交到了远程仓库，你想回到旧版本，并更新到远程仓库，那么你在本地 <code>git reset</code> 到旧的 commit 后，使用上面的 <code>git push</code> 命令是提交不上去的(报错：”Updates were rejected because your current branch is behind its remote counterpart”)，这时可以使用这条命令，即加 <code>--force</code>。</li>\n<li><code>git push &lt;remote-name&gt; :&lt;remote-branch&gt;</code>: 删除远程主机名为 <code>&lt;remote-name&gt;</code> 的 <code>&lt;remote-branch&gt;</code> 分支。</li>\n<li><code>git fetch &lt;remote-name&gt;</code>: 从远程主机 <code>&lt;remote-name&gt;</code> 中取回所有更新，远程主机的分支在本地会用 <code>&lt;remote-name&gt;/&lt;branch&gt;</code> 表示，其实这也是个分支名而已(这种形式的分支称为“远程分支”)。如果你想合并入本地的 <code>&lt;branch&gt;</code> 分支，则可以用 <code>git checkout &lt;branch&gt;</code> 和 <code>git merge &lt;remote-name&gt;/&lt;branch&gt;</code> 合并；也可以用 <code>git pull &lt;remote-name&gt; &lt;branch&gt;</code> 直接完成。</li>\n<li><code>git fetch &lt;remote-name&gt; &lt;branch&gt;</code>: 取回远程主机 <code>&lt;remote-name&gt;</code> 中的分支 <code>&lt;branch&gt;</code> 的更新。</li>\n<li><code>git remote add &lt;name&gt; &lt;url&gt;</code>: 添加远程主机名 <code>&lt;name&gt;</code>，并用他代表 <code>&lt;url&gt;</code>。</li>\n<li><code>git remote rm &lt;name&gt;</code>: 删除远程主机名 <code>&lt;name&gt;</code>，并不是真的删除远程仓库内容。</li>\n<li><code>git remote -v</code>: 列出可用的远程主机名。</li>\n<li><code>git remote set-url &lt;name&gt; &lt;url&gt;</code>: 重新将远程主机名 <code>&lt;name&gt;</code> 对应的地址是 <code>&lt;url&gt;</code>。</li>\n<li><code>git remote rename &lt;old&gt; &lt;new&gt;</code>: 重命名远程主机 <code>&lt;old&gt;</code> 为 <code>&lt;new&gt;</code>。</li>\n<li><code>git pull &lt;remote-name&gt; &lt;remote-branch&gt;:&lt;local-branch&gt;</code>: 取回远程主机 <code>&lt;remote-name&gt;</code> 的分支 <code>&lt;remote-branch&gt;</code> 更新，并将他与本地分支 <code>&lt;local-branch&gt;</code> 合并。</li>\n<li><code>git pull &lt;remote-name&gt; &lt;remote-branch&gt;</code>: 取回远程主机 <code>&lt;remote-name&gt;</code> 的分支 <code>&lt;remote-branch&gt;</code> 更新，并将他与当前分支合并。</li>\n</ul>\n<h2 id=\"Github-相关\"><a href=\"#Github-相关\" class=\"headerlink\" title=\"Github 相关\"></a>Github 相关</h2><p>Github 是 Git 仓库的托管平台(又被称为”全球最大的同性交友网站”)，但是发展到现在，他其实已经变成了一个团队协作的平台(Github 的口号是”Build Software better, together”)，Google Code 也因为他关闭了，Google 将他的仓库都搬到 Github 上了。</p>\n<p>Github 又多了 Social 的概念，比如 Follow People, Watch Repositories，你也可以通过 Explore 找到更多的 Projects 或 People。</p>\n<blockquote>\n<p><a href=\"https://mac.github.com/index.html\" target=\"_blank\" rel=\"external\">Github for Mac</a> 是 Github 官方推出的客户端，非常好用，他弱化了 Git 的概念，比如 push,pull 等，而用 Sync 代替了 pull+push。在2015年8月12日又推出了新版，新增功能有：</p>\n<ul>\n<li>提出了”Start contributing, natively”，即在本地客户端就可以完成 Pull Request，而不需要到 Github 网站上。</li>\n<li>按行提交，而不是将整个文件的改变一起提交。</li>\n<li>仅仅通过单击分支的方式就切换分支。</li>\n</ul>\n</blockquote>\n<h3 id=\"1-Github-基本概念\"><a href=\"#1-Github-基本概念\" class=\"headerlink\" title=\"1. Github 基本概念\"></a>1. Github 基本概念</h3><ul>\n<li><strong>Star</strong>: 收藏项目，类似于浏览器当中的加入书签功能。</li>\n<li><strong>Watch</strong>: 除了收藏，当该项目收到 Pull Request 时，都会通知你。</li>\n<li><strong>Fork</strong>: 只有你想贡献代码给该项目，才用 Fork，一般都用 Star，因此流传着一句话：不贡献代码的 Fork 就是耍流氓！</li>\n</ul>\n<blockquote>\n<p>有一个很普遍的问题，就是 Fork 之后，如果原作者的代码更新了，在你自己 Fork 的项目中是看不出更新的。最简单的解决方法是重新 Fork；复杂一点的是 merge。</p>\n</blockquote>\n<ul>\n<li>Issues: Github 每个项目都有一个 Issues 模块，官方定义：”Issues are used to track todos, bugs, feature requests, and more.”，简单地说就是项目的小型论坛，你可以在里面提任何的问题，可以回复别的Issue，但是 Issues 的最终命运是要被关闭的，即问题解决了就关闭。</li>\n</ul>\n<h3 id=\"2-给开源项目贡献代码\"><a href=\"#2-给开源项目贡献代码\" class=\"headerlink\" title=\"2. 给开源项目贡献代码\"></a>2. 给开源项目贡献代码</h3><p>作为一个有上进心的程序员，为开源世界做贡献是很常见的愿景。</p>\n<p>假设这次要贡献的是 JQuery，地址是：<a href=\"https://github.com/jquery/jquery\" target=\"_blank\" rel=\"external\">https://github.com/jquery/jquery</a>。方法如下：</p>\n<ol>\n<li>Fork 别人的项目成为自己的项目，地址是 <a href=\"https://github.com/xiazdong/jquery\" target=\"_blank\" rel=\"external\">https://github.com/xiazdong/jquery</a>。</li>\n<li>将 <a href=\"https://github.com/xiazdong/jquery\" target=\"_blank\" rel=\"external\">https://github.com/xiazdong/jquery</a> Clone 到本地。</li>\n<li>修改代码。</li>\n<li>提交到远程仓库 <a href=\"https://github.com/xiazdong/jquery\" target=\"_blank\" rel=\"external\">https://github.com/xiazdong/jquery</a>。</li>\n<li>New Pull Request 等待原作者的审批。</li>\n</ol>\n<h3 id=\"3-Github-Flow\"><a href=\"#3-Github-Flow\" class=\"headerlink\" title=\"3. Github Flow\"></a>3. Github Flow</h3><p><a href=\"http://gitbeijing.com/flow/\" target=\"_blank\" rel=\"external\">Github Flow</a> 是由 Github 人员总结的一套使用 Git 的工作流程如下图：</p>\n<p><img src=\"http://i.imgur.com/bKD9cri.png\" width=\"600px\"></p>\n<p>上图中的编号解释：</p>\n<ol>\n<li>将队友加入项目的 Collaborator。</li>\n<li>每个功能都新建一个特性分支。</li>\n<li>在特性分支上做开发。</li>\n<li>开发完之后提交 Pull Request。</li>\n<li>提交完后可以在所在的 Pull Request 讨论留言，作为 Code Review。</li>\n<li>当达成一致时，Merge Pull Request 到 master 分支，其中 master 分支的代码都是可以直接部署运行的，即最稳定的，不能直接在 master 上改代码。</li>\n</ol>\n<blockquote>\n<p><a href=\"http://gitbeijing.com/github_flow.html\" target=\"_blank\" rel=\"external\">团队合作流程</a> 有对 Github Flow 进行详细介绍。</p>\n</blockquote>\n<p>一般在公司里的开发习惯是：如果2015年8月12日要发一个版本，那么新建一个 dev_20150812 分支，但是不要再该分支上修改，而是每次都新建一个分支(比如 dev_20150812_feature1)，修改完了之后再发一个 merge request 到 dev_20150812。</p>\n<h3 id=\"4-Github-支持-Git-LFS\"><a href=\"#4-Github-支持-Git-LFS\" class=\"headerlink\" title=\"4. Github 支持 Git LFS\"></a>4. Github 支持 Git LFS</h3><p>原来，根据 <a href=\"https://help.github.com/articles/what-is-my-disk-quota/\" target=\"_blank\" rel=\"external\">官方说明</a>，Github 对于每个仓库的大小限制在 1G，仓库中每个文件的大小限制 100M，如果文件大小大于 50M，那么 push 时会出现 warning。</p>\n<p>但是在2015年4月8日，Github官方宣布支持 <a href=\"https://github.com/blog/1986-announcing-git-large-file-storage-lfs\" target=\"_blank\" rel=\"external\">Git LFS</a> 扩展，每个仓库默认有 1G 的大文件存储空间，每个月带宽也是 1G。Git LFS(Large File Storage) 的官方定义是”command line extension for managing large files in Git”，即 Git LFS 是为了让 Git 更好地支持大文件管理而实现的一个命令行的扩展，即你只要安装好了之后，就能够使用类似 <code>git lfs</code> 使用 LFS，即将 LFS 集成到 Git 中。</p>\n<p><img src=\"https://cloud.githubusercontent.com/assets/1319791/7051226/c4570828-ddf4-11e4-87eb-8fc165e5ece4.gif\" width=\"600px\"></p>\n<p><a href=\"https://github.com/github/git-lfs\" target=\"_blank\" rel=\"external\">Git LFS</a> 的实现思路可以从上面的图中看出：有一个 Git Large File Storage Server(位于右上角)专门存储大文件，而 Git 仓库只是使用一个”text pointer”(仅仅是一段文本，作为指针)来记录大文件的位置。原来 Git 对大文件管理支持的不好是因为加入大文件之后，Git 仓库就会变得非常大，管理起来就速度很慢，而现在有了这种方法之后，Git 仓库不会因为大文件的加入而体积变大。</p>\n<p>在 Github 中，Github 既充当 Git 仓库的角色，也充当 LFS Server 的角色(地址是：”<a href=\"https://media.githubusercontent.com/media/xiazdong/...&quot;)。\" target=\"_blank\" rel=\"external\">https://media.githubusercontent.com/media/xiazdong/...&quot;)。</a></p>\n<p>Git LFS 的安装教程见<a href=\"https://git-lfs.github.com/\" target=\"_blank\" rel=\"external\">这里</a>，官方文档见<a href=\"https://github.com/github/git-lfs/tree/master/docs\" target=\"_blank\" rel=\"external\">这里</a>。</p>\n<blockquote>\n<p>目前我已经收到 Github 的邮件，说已经正式公开支持 LFS 特性。</p>\n</blockquote>\n<p>这里列举几个常用的命令：</p>\n<ul>\n<li><code>git lfs --h</code>: 查看帮助。</li>\n<li><code>git lfs track &lt;file&gt;</code>: LFS 开始跟踪 <code>&lt;file&gt;</code>。</li>\n<li><code>git lfs track</code>: 列出 LFS 跟踪的文件。 </li>\n<li><code>git lfs untrack &lt;file&gt;</code>: LFS 取消跟踪 <code>&lt;file&gt;</code>。</li>\n<li><code>git lfs push</code>: 将 LFS 跟踪的文件 push 到 LFS Server。</li>\n<li><code>git lfs status</code>: 查看 LFS 的状态。</li>\n</ul>\n<h3 id=\"Gist\"><a href=\"#Gist\" class=\"headerlink\" title=\"Gist\"></a>Gist</h3><ul>\n<li>英文定义：Gist is a simple way to share snippets and pastes with others. All gists are Git repositories, so they are automatically versioned, forkable and usable from Git.</li>\n<li>中文定义：Gist是一种分享小段代码给别人的简单的方式。每个 Gist 都是 Git 仓库，他被自动进行版本控制，他也能被 fork。</li>\n</ul>\n<h3 id=\"Gitter\"><a href=\"#Gitter\" class=\"headerlink\" title=\"Gitter\"></a>Gitter</h3><p><a href=\"http://gitter.im\" target=\"_blank\" rel=\"external\">Gitter</a> 是一款专门为 Github 打造的聊天应用(标语为”Chat, for GitHub.”)，你可以为某个你的项目新建一个聊天室，并且邀请一些人在里面讨论。目前支持 Web, Mac, IOS, Android。</p>\n<blockquote>\n<p>用下来感觉是不错，而且还跨平台，逼格特别高，但是其实直接建个QQ群也挺好使的。</p>\n</blockquote>\n<h3 id=\"Tig\"><a href=\"#Tig\" class=\"headerlink\" title=\"Tig\"></a>Tig</h3><p><a href=\"https://github.com/jonas/tig\" target=\"_blank\" rel=\"external\">Tig</a> 是一款字符模式的 Git 操作界面。不过不容易上手。</p>\n<ul>\n<li>输入 <code>tig</code> 进入 Main View。可以看到一系列提交 log。可以通过”上下键”上下选择具体某个提交。</li>\n<li>选中某个提交后，输入 “Enter” 查看提交的信息。输入 “s” 进入这次提交的 Status View，即查看这次提交修改了哪些文件。输入 “t” 查看这次提交的 Tree View。</li>\n<li>输入 “q” 回上一级。</li>\n<li>输入 “h” 进入帮助界面。</li>\n</ul>\n<blockquote>\n<p>我目前还没有适应这种使用 Git 的方式，还是比较推荐 Tower。</p>\n</blockquote>\n<h2 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h2><ul>\n<li><a href=\"http://git-scm.com/book/en/v2\" target=\"_blank\" rel=\"external\">Pro Git</a>: 这本书是 Github 的员工 Scott Chacon 写的，最好的 Git 学习书。</li>\n<li><a href=\"https://try.github.io/levels/1/challenges/1\" target=\"_blank\" rel=\"external\">Try Git</a>: Github 官方的 Git 入门实验教程。</li>\n<li><a href=\"http://marklodato.github.io/visual-git-guide/index-zh-cn.html\" target=\"_blank\" rel=\"external\">图解 Git</a>: 将一些其他书中不太清楚的概念用图的方式讲清楚了。</li>\n<li><a href=\"http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000\" target=\"_blank\" rel=\"external\">廖雪峰 Git教程</a></li>\n<li><a href=\"http://www.ruanyifeng.com/blog/2014/06/git_remote.html\" target=\"_blank\" rel=\"external\">Git远程操作详解</a></li>\n<li><a href=\"http://www.cnblogs.com/hustskyking/p/git-improve.html\" target=\"_blank\" rel=\"external\">git版本管理策略及相关技巧(A)</a></li>\n<li><a href=\"http://www.php-oa.com/2014/10/22/github-operation.html\" target=\"_blank\" rel=\"external\">Github 上 Fork 别人的项目后的常用的操作指南</a></li>\n<li><a href=\"http://blog.krdai.info/post/17485259496/github-flow\" target=\"_blank\" rel=\"external\">在 GitHub 當中使用的 work flow</a></li>\n<li><a href=\"http://happypeter.github.io/gitbeijing/\" target=\"_blank\" rel=\"external\">Git 北京</a>: 主要介绍Github相关内容。</li>\n<li><a href=\"http://blog.kidwm.net/388\" target=\"_blank\" rel=\"external\">Tig使用入门</a></li>\n<li><a href=\"https://github.com/blog/2019-how-to-undo-almost-anything-with-git\" target=\"_blank\" rel=\"external\">How to undo (almost) anything with Git</a></li>\n<li><a href=\"http://alblue.bandlem.com/2011/08/git-tip-of-week-detached-heads.html\" target=\"_blank\" rel=\"external\">Git Tip of the Week: Detached Heads</a></li>\n<li><a href=\"http://www.oschina.net/translate/10-tips-git-next-level?cmp\" target=\"_blank\" rel=\"external\">10 Tips to Push Your Git Skills to the Next Level</a></li>\n</ul>\n<h2 id=\"附：视频教程\"><a href=\"#附：视频教程\" class=\"headerlink\" title=\"附：视频教程\"></a>附：视频教程</h2><p>快过年了，附上点福利吧~</p>\n<ul>\n<li><a href=\"http://www.icoolxue.com/album/show/41\" target=\"_blank\" rel=\"external\">Git权威指南 视频</a></li>\n<li><a href=\"http://study.163.com/course/courseMain.htm?courseId=976002\" target=\"_blank\" rel=\"external\">李兴华 Git</a></li>\n<li><a href=\"https://www.udacity.com/course/ud775\" target=\"_blank\" rel=\"external\">Udacity: How to use Git and Github</a></li>\n</ul>\n","categories":[],"tags":["Git"]},{"title":"校招找工作小结","url":"http://xiazdong.github.io/2015/10/26/校招找工作小结/","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>今年校园招聘终于告一段落，从阿里实习回来一个月一直在找工作。由于阿里的拥抱变化政策，导致我找工作都没怎么准备，但最后结果幸好还不错。</p>\n<p>本人 offer 有：腾讯、蘑菇街 sp、技德科技、美团、爱奇艺、招行信用卡中心、触宝、游族网络。总体感觉虽然别人都说互联网寒冬来了，但是整体互联网的局势还是不错的，整体薪资水平在20万/年左右。</p>\n<h2 id=\"面试官最看重什么？\"><a href=\"#面试官最看重什么？\" class=\"headerlink\" title=\"面试官最看重什么？\"></a>面试官最看重什么？</h2><p>面试互联网公司，面试官最看重的因素按照重要性排列如下：</p>\n<ol>\n<li>大公司实习经历：我认为这是最最最重要的。学生之间的技术水平相差不大，就靠这个拉开差距。这里的大公司包括但不限于：BAT、微软、Google、美团、大众点评、蘑菇街、京东、小米、思科。这些公司的实习经验有几个优点：(1)内推简历不会被刷(2)有了实习经历，面试官会少问很多基础技术问题(3)增加霸面成功率(4)增加人脉，我在阿里实习时，四周全都是网络上响当当的技术大牛。</li>\n<li>ACM、算法：如果你没有实习经历，那么面试时做几道算法题是免不了的，如果你算法牛逼，那进好公司的概率大大提升。</li>\n<li>学校：BAT 几乎被这几个学校（北京邮电大学、西安电子科技大学、华中科技大学、上海交通大学、清华大学、南京大学、武汉大学、浙江大学）给承包了。</li>\n<li>岗位需求：我在阿里实习时，发现他们招人都是有针对性的，比如部门需要做一个关于语音识别的项目，那么领导就会找这方面优秀的人，可能会发生的情况是：某人其他方面都不怎么样，但是正好满足他们的需求，最后录用了。</li>\n<li>言谈举止：你如果和面试官气场不合，那么你再牛逼，他都可以把你拒了。</li>\n<li>基础知识：操作系统、数据库、网络、编程语言等。</li>\n<li>技术博客、Github：一个拿得出手的技术博客或 Github 绝对是找工作的加分项。</li>\n<li>简历：简历要给人一目了然的感觉，参见：<a href=\"http://xiazdong.github.io/2015/10/25/程序员简历制作建议/\">程序员简历制作建议</a>。</li>\n<li>成绩：这个是最不重要的。前5%最好，过得去就行。</li>\n</ol>\n<h2 id=\"如何准备？\"><a href=\"#如何准备？\" class=\"headerlink\" title=\"如何准备？\"></a>如何准备？</h2><ol>\n<li>选定方向：找工作很重要的是要有自己的技术方向，比如 Java后台、移动端开发、数据挖掘、前端等。</li>\n<li>基础知识积累：从我目前找工作的情况来看，不管你面什么公司，大多数技术面试题都重复。</li>\n<li>选公司：公司太多，你如果海投，会把自己搞的很累，每天就在接电话、面试，得不偿失。你需要对你想去的公司做一个排序。选公司时，注意几点：<ul>\n<li>看看你的技术和公司对不对口。比如后台开发，腾讯招C/C++偏多，阿里找Java偏多，百度招PHP偏多。</li>\n<li>选城市：拿阿里来说，应聘杭州总部岗位比应聘分公司岗位的难度低得多得多。</li>\n</ul>\n</li>\n<li>时间点：每个公司都有内推、校招的时间点，你已经选好你想去的公司后，只要按照他的时间点来，就ok了。错过时间点是最遗憾的事。按照我的面试经验，能内推就别参加校招，内推的特点是不用笔试、电话面试，很水。</li>\n<li>积极的心态：要用积极的心态面对投简历、笔试、面试。</li>\n<li>面试的时候有一些问题是常问的，比如：<ul>\n<li>自我介绍。</li>\n<li>你印象最深的项目是什么？难点在哪？</li>\n<li>你的优点、缺点是什么？</li>\n<li>你在XX公司实习都干了什么？</li>\n</ul>\n</li>\n</ol>\n","categories":[],"tags":["Android"]},{"title":"程序员简历制作建议","url":"http://xiazdong.github.io/2015/10/25/程序员简历制作建议/","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>本文针对应聘IT公司技术类岗位的应届毕业生。</p>\n<h3 id=\"简历的重要性\"><a href=\"#简历的重要性\" class=\"headerlink\" title=\"简历的重要性\"></a>简历的重要性</h3><p>一份优秀的简历对于一名应届毕业生来说是很重要的，制作一份优秀的简历其实和做一个项目一样，你对简历的随便侧面反映出你做事随便。 </p>\n<h3 id=\"简历的组成\"><a href=\"#简历的组成\" class=\"headerlink\" title=\"简历的组成\"></a>简历的组成</h3><p>简历无非有两部分组成：</p>\n<ul>\n<li>内容：无废话。</li>\n<li>排版：简洁。</li>\n</ul>\n<p>我建议写简历的流程也是先内容，后排版。本文将分成这两大部分给出一些自己的建议。</p>\n<h3 id=\"简历的作用\"><a href=\"#简历的作用\" class=\"headerlink\" title=\"简历的作用\"></a>简历的作用</h3><p>简历的目的是说服面试官，让他觉得你是一个很适合这个岗位的人，也就是说，如果面试官认为的和你希望他认为的一样，就成功了。</p>\n<h3 id=\"我制作过的简历\"><a href=\"#我制作过的简历\" class=\"headerlink\" title=\"我制作过的简历\"></a>我制作过的简历</h3><ul>\n<li>第一版：用 Word 制作。这个版本是大二时做的，现在看来不管是排版还是内容都略显稚嫩。</li>\n<li>第二版：用 LaTeX 的 moderncv 宏包制作。这个版本是大四时做的，虽然用 LaTeX 排版很专业并且模板也都比较简洁，但是能够选择的模板很少且略显单调，而且对于我们这种程序员要调出一个好看的排版太难了。</li>\n<li>第三版：用 PS 制作。这个版本是研一做的，因为当时看到很多设计师都用 PS 制作简历，而且都很好看，因此也想试试，后来发现不太合适。因为技术岗位根本不需要这么花哨。</li>\n<li>第四版：用 Word 制作，从零开始根据内容个人定制。</li>\n</ul>\n<h2 id=\"内容\"><a href=\"#内容\" class=\"headerlink\" title=\"内容\"></a>内容</h2><h3 id=\"不建议\"><a href=\"#不建议\" class=\"headerlink\" title=\"不建议\"></a>不建议</h3><ul>\n<li>不建议简历超过一页。</li>\n<li>不建议放个人头像，除非你长得非常非常帅。因为这是技术类岗位。</li>\n<li>不建议写兴趣爱好，除非你有很突出的兴趣爱好，比如钢琴十级。</li>\n<li>不建议写太多个人信息，比如家庭地址，政治面貌，身高，性别等。</li>\n<li>不建议写主修课程。因为简历只有一页，本来地方就少，你还罗里吧嗦写主修课程。</li>\n<li>不建议写自我评价。但是可以叫一个很有名的人给你写评价。</li>\n<li>不建议表格式的简历。</li>\n<li>不建议写一些小荣誉。比如“校运动会100m第一名”。</li>\n<li>不建议写”精通”某个技术，因为面试官看到你写精通，就问你超级难的问题想难倒你。</li>\n<li>不建议夸大事实。</li>\n<li>不建议写没有项目经历的技术。比如你写你熟悉C++，但是你却没有做过一个关于C++的项目。</li>\n</ul>\n<h3 id=\"建议\"><a href=\"#建议\" class=\"headerlink\" title=\"建议\"></a>建议</h3><ul>\n<li>建议放博客地址。</li>\n<li>建议放 Github 账号。</li>\n<li>建议放突出的实习经历，并写出你的工作内容，并量化你的工作，比如使得性能提升了1倍。</li>\n<li>建议提前去牛逼的公司实习，这样能极大帮助你以后找工作。</li>\n<li>建议将所投职位的技能放在skills的前面。</li>\n</ul>\n<h2 id=\"排版\"><a href=\"#排版\" class=\"headerlink\" title=\"排版\"></a>排版</h2><p>网上能找得到的模板都不是很好看。我建议写完内容之后，再到淘宝上去看看有没有适合自己内容的模板，然后花点钱买一个。用10块钱能买一个好的简历模板是非常划算的。</p>\n<h2 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h2><ul>\n<li><a href=\"http://coolshell.cn/articles/1695.html\" target=\"_blank\" rel=\"external\">别的程序员是怎么读你的简历的</a></li>\n<li><a href=\"http://www.cnblogs.com/Michael282694/p/3768461.html\" target=\"_blank\" rel=\"external\">校招信息渠道收集以及如何写好求职简历——仅限于互联网方向</a></li>\n<li><a href=\"http://zh.lucida.me/blog/lean-technical-resume/\" target=\"_blank\" rel=\"external\">精益技术简历之道——改善技术简历的47条原则</a></li>\n<li><a href=\"http://www.zhihu.com/question/19733182\" target=\"_blank\" rel=\"external\">什么样的简历不被 HR 看中？</a></li>\n<li><a href=\"http://www.tudou.com/programs/view/xlR2wzzJkSs/\" target=\"_blank\" rel=\"external\">程序员的跳槽方法论</a></li>\n<li><a href=\"http://www.zhihu.com/question/23631182\" target=\"_blank\" rel=\"external\">应聘互联网公司的简历应该是怎么样的？</a></li>\n</ul>\n","categories":[],"tags":["其他"]},{"title":"Touch 事件分发机制","url":"http://xiazdong.github.io/2015/09/19/android-touch-event-mechanism/","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>Touch 事件分发机制是面试中非常常见的问题，也是非常重要的问题。网上有很多关于这方面的文章，但是感觉写的不是特别清晰易懂。</p>\n<h2 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h2><p>Touch 事件分发机制分发的是 MotionEvent 对象，取值如下：</p>\n<ul>\n<li>ACTION_DOWN: 按下事件。</li>\n<li>ACTION_MOVE: 移动事件。</li>\n<li>ACTION_UP: 抬起事件。</li>\n</ul>\n<p>一个事件序列包含 <code>ACTION_DOWN-&gt;ACTION_MOVE-&gt;...-&gt;ACTION_MOVE-&gt;ACTION_UP</code>，即用户触摸屏幕，移动一些距离，然后抬起。</p>\n<blockquote>\n<ol>\n<li>下面说的 view “处理” 了某个事件，表示 view 调用了 onTouchEvent()。</li>\n<li>下面说的 view “消费” 了某个事件，表示 view 调用了 onTouchEvent() 并返回 true。因此某个 view 可以处理但不消费某个事件。</li>\n</ol>\n</blockquote>\n<p>Touch 事件分发机制涉及三个方法：</p>\n<ul>\n<li><code>dispatchTouchEvent(MotionEvent ev)</code>: 如果某个触摸事件传递给了某个 View 或 ViewGroup(设为 v)，则一定会调用 v.dispatchTouchEvent()，如果 v 是 ViewGroup，则内部会调用 onInterceptTouchEvent() 或 onTouchEvent()；如果 v 是 View，则内部会调用 onTouchEvent()。</li>\n<li><code>onInterceptTouchEvent(MotionEvent ev)</code>: 这个方法只有 ViewGroup 才有，判断是否要拦截该事件并且自己处理，如果返回 true，则拦截；如果返回 false，则不拦截。</li>\n<li><code>onTouchEvent(MotionEvent ev)</code>: 处理 Touch 事件的核心方法，如果返回 true，表示消费了事件；如果返回 false，则表示没消费该事件。</li>\n</ul>\n<p>ViewGroup 的 dispatchTouchEvent(), onInterceptTouchEvent(), onTouchEvent() 的基本关系如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">dispatchTouchEvent</span><span class=\"params\">(MotionEvent ev)</span></span>&#123;</div><div class=\"line\">    <span class=\"keyword\">boolean</span> consume = <span class=\"keyword\">false</span>;</div><div class=\"line\">    <span class=\"keyword\">if</span>(onInterceptTouchEvent(ev))&#123;  <span class=\"comment\">//是否拦截</span></div><div class=\"line\">        consume = onTouchEvent(ev); <span class=\"comment\">//如果拦截，则自己处理</span></div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">else</span>&#123;  <span class=\"comment\">//如果没拦截，则事件分发给孩子</span></div><div class=\"line\">        consume = child.dispatchTouchEvent(ev);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> consume;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>上面的代码只是基本概括了整个事件分发的核心流程，具体实现细节会在下面介绍。</p>\n<h2 id=\"总体分发流程\"><a href=\"#总体分发流程\" class=\"headerlink\" title=\"总体分发流程\"></a>总体分发流程</h2><p>当用户发起触摸事件后，首先触摸事件从 Activity 的 dispatchTouchEvent() 开始，该方法实现如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">dispatchTouchEvent</span><span class=\"params\">(MotionEvent ev)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (getWindow().superDispatchTouchEvent(ev)) &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> onTouchEvent(ev);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>解释：</p>\n<ul>\n<li>其中 getWindow().superDispatchTouchEvent() 会调用 DecorView 的 dispatchTouchEvent() 开始分发，接着 DecorView 会调用根 View 进行事件分发。</li>\n<li>如果 getWindow().superDispatchTouchEvent() 返回 true，表示有子 View 消费了该触摸事件；如果返回 false，表示没有任何子 View 消费该事件，会调用 Activity 的 onTouchEvent()，即 Activity 自己处理 Touch 事件，并返回 false。</li>\n</ul>\n<h2 id=\"View-Touch-事件分发\"><a href=\"#View-Touch-事件分发\" class=\"headerlink\" title=\"View Touch 事件分发\"></a>View Touch 事件分发</h2><p>因为 ViewGroup 也是继承自 View，因此此处分两种情况讨论。</p>\n<ul>\n<li>如果是最底层的 View，一旦将触摸事件分发给他，就会调用下面的 dispatchTouchEvent()；</li>\n<li>如果是 ViewGroup，则默认并不会调用下面的 dispatchTouchEvent()，而是会调用 ViewGroup 自己的 dispatchTouchEvent()，只有当 ViewGroup 在自己的 dispatchTouchEvent() 方法中经过判断，发现需要自己处理触摸事件时，才会通过 <code>super.dispatchTouchEvent(ev)</code> 的形式调用下面的 dispatchTouchEvent()。</li>\n</ul>\n<p>View 的 dispatchTouchEvent() 实现如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">dispatchTouchEvent</span><span class=\"params\">(MotionEvent event)</span> </span></div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (li != <span class=\"keyword\">null</span> &amp;&amp; li.mOnTouchListener != <span class=\"keyword\">null</span> &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED</div><div class=\"line\">            &amp;&amp; li.mOnTouchListener.onTouch(<span class=\"keyword\">this</span>, event)) </div><div class=\"line\">    &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">if</span> (onTouchEvent(event)) </div><div class=\"line\">    &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>从上面看出：</p>\n<ul>\n<li>onTouchEvent() 不一定会被调用。如果设置了 OnTouchListener， View 是 enabled，并且 OnTouchListener 的 onTouch() 返回 true，则不会调用 onTouchEvent()。</li>\n<li>如果 View 是 DISABLED，则 onTouch() 不会被调用。</li>\n<li>如果 OnTouchListener 的 onTouch() 或 View 的 onTouchEvent() 返回 true，则 dispatchTouchEvent() 返回 true；否则返回 false。</li>\n</ul>\n<p>接着我们看看 onTouchEvent() 的实现：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">onTouchEvent</span><span class=\"params\">(MotionEvent event)</span> </span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">if</span> (((viewFlags &amp; CLICKABLE) == CLICKABLE || (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE)) &#123;</div><div class=\"line\">    \t<span class=\"keyword\">switch</span> (event.getAction()) &#123;</div><div class=\"line\">        \t<span class=\"keyword\">case</span> MotionEvent.ACTION_UP:</div><div class=\"line\">        \t\tperformClick();   <span class=\"comment\">//执行 mClickListener.onClick() 方法</span></div><div class=\"line\">        \t\t<span class=\"keyword\">break</span>;</div><div class=\"line\">        \t<span class=\"keyword\">case</span> MotionEvent.ACTION_DOWN:</div><div class=\"line\">        \t\t...</div><div class=\"line\">        \t\t<span class=\"keyword\">break</span>;</div><div class=\"line\">        \t<span class=\"keyword\">case</span> MotionEvent.ACTION_MOVE:</div><div class=\"line\">        \t\t...</div><div class=\"line\">        \t\t<span class=\"keyword\">break</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>从上面可以看出：</p>\n<ul>\n<li>onTouchEvent() 内部在 ACTION_UP 事件中调用了 onClick()(即在一个事件序列中，只有在 ACTION_UP 才会调用 onClick()，但是 onTouch() 在每个事件都会被调用)，即如果同时注册了 OnTouchListener 和 OnClickListener，则 OnTouchListener 优先级高于 OnClickListener，如果 onTouch() 返回 true，则 onTouchEvent() 不会执行，也就意味着 onClick() 不会执行。</li>\n<li>在 onTouchEvent() 中，只有 View 是 Clickable 的，才能进入 if 语句，而且一旦进入 if 语句就返回 true。比如 Button 是 Clickable 的，因此 onTouchEvent() 一定返回 true，ImageView 是不可点击的，因此 onTouchEvent() 一定返回 false。</li>\n</ul>\n<h2 id=\"ViewGroup-Touch-事件分发\"><a href=\"#ViewGroup-Touch-事件分发\" class=\"headerlink\" title=\"ViewGroup Touch 事件分发\"></a>ViewGroup Touch 事件分发</h2><p>ViewGroup 的 dispatchTouchEvent() 比较复杂，下面我们分析一下。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">dispatchTouchEvent</span><span class=\"params\">(MotionEvent ev)</span> </span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">boolean</span> handled = <span class=\"keyword\">false</span>;</div><div class=\"line\">\t<span class=\"comment\">// 1、如果是 ACTION_DOWN 动作，则清除标志位。</span></div><div class=\"line\">    <span class=\"keyword\">if</span> (actionMasked == MotionEvent.ACTION_DOWN) &#123;</div><div class=\"line\">        cancelAndClearTouchTargets(ev);</div><div class=\"line\">        resetTouchState();\t<span class=\"comment\">// 清除 FLAG_DISALLOW_INTERCEPT 标记位</span></div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// 2、判断是否要拦截该事件</span></div><div class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> intercepted;</div><div class=\"line\">    <span class=\"keyword\">if</span>(actionMasked == MotionEvent.ACTION_DOWN || mFirstTouchTarget != <span class=\"keyword\">null</span>)&#123;</div><div class=\"line\">    \t<span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != <span class=\"number\">0</span>;</div><div class=\"line\">        <span class=\"keyword\">if</span> (!disallowIntercept) &#123;</div><div class=\"line\">            intercepted = onInterceptTouchEvent(ev);</div><div class=\"line\">            ev.setAction(action);</div><div class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">            intercepted = <span class=\"keyword\">false</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">else</span>&#123;</div><div class=\"line\">        intercepted = <span class=\"keyword\">true</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// 3、如果不拦截，则传给子 View</span></div><div class=\"line\">    TouchTarget newTouchTarget = <span class=\"keyword\">null</span>;</div><div class=\"line\">    <span class=\"keyword\">boolean</span> alreadyDispatchedToNewTouchTarget = <span class=\"keyword\">false</span>;</div><div class=\"line\">    <span class=\"keyword\">if</span> (!canceled &amp;&amp; !intercepted) &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (actionMasked == MotionEvent.ACTION_DOWN)&#123;</div><div class=\"line\">        \t  <span class=\"keyword\">final</span> View[] children = mChildren;</div><div class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = childrenCount - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; i--) &#123;</div><div class=\"line\">            \t<span class=\"keyword\">final</span> View child = children[childIndex];</div><div class=\"line\">            \t<span class=\"comment\">//如果该子 View 不在触摸范围内，则略过</span></div><div class=\"line\">            \t<span class=\"keyword\">if</span> (!canViewReceivePointerEvents(child) || !isTransformedTouchPointInView(x, y, child, <span class=\"keyword\">null</span>)) &#123;</div><div class=\"line\">                \t<span class=\"keyword\">continue</span>;</div><div class=\"line\">                &#125;</div><div class=\"line\">                <span class=\"comment\">//如果子 View 的 dispatchTouchEvent 返回 true，</span></div><div class=\"line\">                <span class=\"comment\">//\t则表示有子 View 处理了该事件，则设置 mFirstTouchTarget</span></div><div class=\"line\">                <span class=\"comment\">//如果子 View 的 dispatchTouchEvent 返回 false，</span></div><div class=\"line\">                <span class=\"comment\">//\t则表示没有子 View 处理了该事件，则不设置 mFirstTouchTarget</span></div><div class=\"line\">            \t<span class=\"keyword\">if</span> (dispatchTransformedTouchEvent(ev, <span class=\"keyword\">false</span>, child, idBitsToAssign)) &#123;</div><div class=\"line\">            \t\t<span class=\"comment\">//该方法中设置了 mFirstTouchTarget = child</span></div><div class=\"line\">                    newTouchTarget = addTouchTarget(child, idBitsToAssign);\t</div><div class=\"line\">                    alreadyDispatchedToNewTouchTarget = <span class=\"keyword\">true</span>;</div><div class=\"line\">                    <span class=\"keyword\">break</span>;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// 4、判断是否有子 View 处理了事件</span></div><div class=\"line\">    <span class=\"keyword\">if</span> (mFirstTouchTarget == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">        handled = dispatchTransformedTouchEvent(ev, canceled, <span class=\"keyword\">null</span>, TouchTarget.ALL_POINTER_IDS);</div><div class=\"line\">    &#125; </div><div class=\"line\">    <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (alreadyDispatchedToNewTouchTarget)&#123;</div><div class=\"line\">    \t     handled = <span class=\"keyword\">true</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">    \t<span class=\"keyword\">else</span>&#123;</div><div class=\"line\">        \t<span class=\"keyword\">if</span> (dispatchTransformedTouchEvent(ev, cancelChild, target.child, target.pointerIdBits)) &#123;</div><div class=\"line\">            \thandled = <span class=\"keyword\">true</span>;</div><div class=\"line\">            &#125;</div><div class=\"line\">    \t&#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// 5、如果是一个事件序列的最后一个操作(ACTION_UP 或 ACTION_CANCEL)，则把状态清空</span></div><div class=\"line\">\t<span class=\"keyword\">if</span> (canceled </div><div class=\"line\">\t\t\t|| actionMasked == MotionEvent.ACTION_UP</div><div class=\"line\">            || actionMasked == MotionEvent.ACTION_HOVER_MOVE) &#123;</div><div class=\"line\">    \tresetTouchState();</div><div class=\"line\">   \t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>上面的代码中多处调用了 dispatchTransformedTouchEvent()，其中第三个参数有 null(第 52 行) 或者 child(第 40 行、第 59 行)。这个方法的实现如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">dispatchTransformedTouchEvent</span><span class=\"params\">(MotionEvent event, <span class=\"keyword\">boolean</span> cancel, View child, <span class=\"keyword\">int</span> desiredPointerIdBits)</span></span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">boolean</span> handled = <span class=\"keyword\">false</span>;</div><div class=\"line\">\t<span class=\"keyword\">if</span> (child == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">    \thandled = <span class=\"keyword\">super</span>.dispatchTouchEvent(event);</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">    \thandled = child.dispatchTouchEvent(event);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> handled;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>从上面代码可以看出，如果第三个参数传入 null，则调用 View 的 dispatchTouchEvent() 即自己处理事件；如果第三个参数传入 child，则将事件分发下去，即调用 child.dispatchTouchEvent()。</p>\n<p>解释：</p>\n<ul>\n<li>第 2 行: handled 变量作为 dispatchTouchEvent() 的返回值。</li>\n<li>第 4-7 行: 如果是 ACTION_DOWN 操作，则将其状态清空，包括 FLAG_DISALLOW_INTERCEPT。我们可以通过 requestDisallowInterceptTouchEvent() 将 FLAG_DISALLOW_INTERCEPT 设置为 true，表示该 ViewGroup 禁止拦截操作(即直接将 intercepted 设为 false，不调用 onInterceptTouchEvent())，但是这个设置对于 ACTION_DOWN 无效，因为第 4-7 行会将该状态清除，即使设置了该状态，ACTION_DOWN 操作还是会调用 onInterceptTouchEvent()。</li>\n<li>第 10-22 行: 每个 ViewGroup 都会带有 mFirstTouchTarget 变量，这个变量只有在 ACTION_DOWN 事件时才能设置，这个能从第 28 行的 if 语句看出来，因为设置 mFirstTouchTarget 是在第 40-45 行(只有第 28 行的 if 语句为 true 才能执行第 40-45 行代码)，可以看出如果有某个子 View 消费了该事件(这里不一定是直接子 View 消费了该事件，比如有 View 关系: v1-&gt;v2-&gt;v3，当前调用了 v1.dispatchTouchEvent()，如果 v3 消费了该事件，则表示 v1 的某个子 View 消费了该事件，并将 v1 的 mFirstTouchTarget 设置为 v2，将 v2 的 mFirstTouchTarget 设置为 v3)，这样才能使第 40 行的 dispatchTransformedTouchEvent() 返回 true，并设置 mFirstTouchTarget。</li>\n<li>第 25-48 行: 如果当前是 ACTION_DOWN 事件(第 28 行)并且没有拦截(第 27 行，onInterceptTouchEvent() 返回 false)，则会将 ACTION_DOWN 事件分发给合适的在触摸点的直接子 View，在第 40 行的 dispatchTransformedTouchEvent(ev, false, child, idBitsToAssign) 中会调用 child 的 dispatchTouchEvent()。如果 child.dispatchTouchEvent() 返回 false，表示 child 或 child 的子 View 没有人消费 ACTION_DOWN 事件，这样并不会给当前 ViewGroup 设置 mFirstTouchTarget。如果 child.dispatchTouchEvent() 返回 true，即表示 child 或 child 的子 View 有人消费 ACTION_DOWN 事件，则为当前 ViewGroup 设置 mFirstTouchTarget = child，并设置 alreadyDispatchedToNewTouchTarget = true，这个变量在后面会用到，表示是不是在这个方法中刚刚设置了 mFirstTouchTarget，因为只有 ACTION_DOWN 操作才能设置 mFirstTouchTarget，如果 <code>alreadyDispatchedToNewTouchTarget == true &amp;&amp; mFirstTouchTarget != null</code>，则表示当前是 ACTION_DOWN 事件并且在该方法中刚刚设置了 mFirstTouchTarget；如果<code>alreadyDispatchedToNewTouchTarget == false &amp;&amp; mFirstTouchTarget != null</code>，则表示 mFirstTouchTarget 并不是该方法中刚刚设置的，即当前不是 ACTION_DOWN 事件。</li>\n<li>第 51-53 行: 有两种情况会进入第 51 行的 if 语句，(1)当前是 ACTION_DOWN 操作，并且没有子 View 处理该事件 (2)当前不是 ACTION_DOWN 操作，并且在前面的 ACTION_DOWN 操作时没有子 View 处理该事件。第 52 行的第三个参数为 null，因此会执行 <code>super.dispatchTouchEvent()</code>，即执行 View 的 dispatchTouchEvent()，表示自己处理该事件。</li>\n<li>第 55-57 行: 因为只有当当前为 ACTION_DOWN 操作并且有子 View 处理了该事件时，alreadyDispatchedToNewTouchTarget 才为 true，这时直接将 handled 设为 true，不需要做额外的操作。</li>\n<li>第 59-61 行: 能够进入第 58 行的 else 语句意味着当前事件不是 ACTION_DOWN 并且在前面的 ACTION_DOWN 事件存在子 View 处理了该事件(即 mFirstTouchTarget != null，即在前面的 ACTION_DOWN 事件执行过第 40-46 行代码)。此时就执行 dispatchTransformedTouchEvent()，内部会调用 mFirstTouchTarget.dispatchTouchEvent()。</li>\n<li>第 66-69 行: 做收尾工作。</li>\n</ul>\n<h2 id=\"一些结论的验证\"><a href=\"#一些结论的验证\" class=\"headerlink\" title=\"一些结论的验证\"></a>一些结论的验证</h2><p>在网上有很多关于 Touch 事件的结论，这些结论其实都可以通过分析上面的代码得出。这里举几个例子：</p>\n<ul>\n<li>“某个 view 一旦开始处理事件，如果不消费 ACTION_DOWN 事件，则同一事件序列中的其他事件不会再交给它来处理”: 如果 view 处理但不消费 ACTION_DOWN 事件，则表示执行了第 40 行代码，但是返回 false(这个 view 作为 child 传入)，设这个 view 的父 view 为 v0，此时就没设置 v0 的 mFirstTouchTarget。因此接下来的事件(比如 ACTION_MOVE) 一旦分发到 v0，因为他的 mFirstTouchTarget == null，因此会执行第 52 行代码，即 v0 自己处理该事件。</li>\n<li>“某个 view 一旦决定拦截，那么这一事件序列都只能由它来处理，并且它的 onInterceptTouchEvent 不会被调用”: 因为 view 拦截了事件，因此第 27 行的 if 语句进不去，也就设置不了 view 的 mFirstTouchTarget，接下来的事件分发给 view 时，执行到第 11 行的 if 语句，因为该事件不是 ACTION_DOWN 并且 view 的 mFirstTouchTarget == null，因此 if 语句返回 false，即执行第 21 行设置 intercepted = true，因此不会调用 onInterceptTouchEvent；接着执行到第 51 行，因为 view 的 mFirstTouchTarget 为 null，因此执行第 52 行代码，即自己处理该事件。 </li>\n</ul>\n<h2 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h2><ul>\n<li><a href=\"http://blog.csdn.net/guolin_blog/article/details/9097463\" target=\"_blank\" rel=\"external\">Android事件分发机制完全解析，带你从源码的角度彻底理解(上)</a></li>\n<li><a href=\"http://hukai.me/android-deeper-touch-event-dispatch-process/\" target=\"_blank\" rel=\"external\">Touch事件分发响应机制</a></li>\n<li><a href=\"http://blog.csdn.net/singwhatiwanna/article/details/17339857\" target=\"_blank\" rel=\"external\">Android源码分析-点击事件派发机制</a></li>\n</ul>\n","categories":[],"tags":["Android"]},{"title":"JNI和NDK入门","url":"http://xiazdong.github.io/2015/09/17/JNI和NDK入门/","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>JNI(Java Native Interface) 是 Java 提供的调用  C/C++ 代码的一种方式。同时带来的坏处是让 Java 丧失了跨平台的特性，因为 C/C++ 编译后的二进制代码在不同机器(不同指令集、架构)上并不通用。</p>\n<p>NDK(Native Development Kit) 是 Android 提供的调用 C/C++ 代码的方法，他是基于 JNI 的。通过 NDK 能够更快的将 C/C++ 代码编译成支持多个平台(ARM, X86, mips)的动态库。</p>\n<blockquote>\n<p>本文的操作系统是 Mac OS X，开发环境是 Android Studio。</p>\n</blockquote>\n<h2 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h2><p>Java 中通过 <code>System.loadLibrary(&quot;&lt;name&gt;&quot;)</code> 导入动态库，而不同平台下动态库的表示都不同。Windows 下以 “\\<name\\>.dll” 命名，Linux 下用 “lib\\<name\\>.dll” 命名，Mac 下用 “lib\\<name\\>.jnilib” 命名。</name\\></name\\></name\\></p>\n<h2 id=\"JNI-例子\"><a href=\"#JNI-例子\" class=\"headerlink\" title=\"JNI 例子\"></a>JNI 例子</h2><p>1、在工作目录创建 “JniTest.java”。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">package</span> com.xiazdong;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">JniTest</span></span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">static</span>&#123;</div><div class=\"line\">\t\tSystem.loadLibrary(<span class=\"string\">\"jnitest\"</span>);</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[]args)</span></span>&#123;</div><div class=\"line\">\t\tJniTest test = <span class=\"keyword\">new</span> JniTest();</div><div class=\"line\">\t\tSystem.out.println(test.add(<span class=\"number\">1</span>,<span class=\"number\">2</span>));</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">native</span> <span class=\"keyword\">int</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b)</span></span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>可以看出在 JniTest 类中有一个 add 的 native 方法，其实现为本地代码。</p>\n<p><code>System.loadLibrary(&quot;jnitest&quot;)</code> 表示导入动态库，但是在不同平台表示意义不同，Windows 表示导入 “jnitest.dll”，Linux 表示导入 “libjnitest.so”，Mac 表示导入 “libjnitest.jnilib”。</p>\n<p>2、命令行执行 <code>javac -d . JniTest.java</code> 生成 class 文件。</p>\n<p>3、命令行执行 <code>javah com.xiazdong.JniTest</code> 生成 <code>com_xiazdong_JniTest.h</code> 文件，该文件命令为 <code>&lt;包名&gt;_&lt;类名&gt;.h</code>。</p>\n<p>4、在工作目录创建 <code>test.c</code> 文件。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"com_xiazdong_JniTest.h\"</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></div><div class=\"line\"></div><div class=\"line\"><span class=\"function\">JNIEXPORT jint JNICALL <span class=\"title\">Java_com_xiazdong_JniTest_add</span><span class=\"params\">(JNIEnv * env, jobject thiz, jint a, jint b)</span></span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">return</span> a + b; <span class=\"comment\">//具体实现</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>其中函数的定义可以从 <code>com_xiazdong_JniTest.h</code> 中拷贝过来。函数命名规定为<code>Java_&lt;包名&gt;_&lt;类名&gt;_&lt;方法名&gt;</code>。</p>\n<p>5、命令行执行 <code>gcc -shared -I $JAVA_HOME/include -I $JAVA_HOME/include/darwin -fPIC test.c -o libjnitest.jnilib</code>。该命令生成 “libjnitest.jnilib”。如果是 Linux 环境，则把该命令的 <code>libjnitest.jnilib</code> 改成 <code>libjnitest.so</code> 即可。</p>\n<p>此时生成的动态库是在工作目录下的。</p>\n<p>6、命令行执行 <code>java com.xiazdong.JniTest</code>。</p>\n<p>如果要引入的动态库不在工作目录中，需要通过该命令加入动态库的目录 <code>-Djava.library.path=&lt;dir&gt;</code>。</p>\n<h2 id=\"NDK-例子\"><a href=\"#NDK-例子\" class=\"headerlink\" title=\"NDK 例子\"></a>NDK 例子</h2><p>0、下载ndk，本文使用 “android-ndk-r10e-darwin-x86_64.bin”。</p>\n<p>执行 <code>sudo chmod a+x android-ndk-r10e-darwin-x86_64.bin</code>。</p>\n<p>执行 <code>sudo ./android-ndk-r10e-darwin-x86_64.bin</code> 解压。</p>\n<p>将解压后的 <code>android-ndk-r10e</code> 目录添加到 PATH 环境变量。</p>\n<p>1、创建 jni 目录，注意这里目录名一定要是 jni。</p>\n<p>2、在 jni 目录中创建 test.c。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"jni.h\"</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifdef</span> __cplusplus</span></div><div class=\"line\"><span class=\"keyword\">extern</span> <span class=\"string\">\"C\"</span> &#123;</div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></div><div class=\"line\"></div><div class=\"line\"><span class=\"function\">jint <span class=\"title\">Java_me_xiazdong_ndkdemo_Test_add</span><span class=\"params\">(JNIEnv * env, jobject thiz, jint a, jint b)</span></span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">return</span> a + b;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifdef</span> __cplusplus</span></div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></div></pre></td></tr></table></figure>\n<p>注意：此处包名为 me.xiazdong.ndkdemo，类名为 Test。这个需要特别注意！！</p>\n<p>3、在 jni 目录中创建 Android.mk。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><div class=\"line\">LOCAL_PATH := $(call my-dir) ## 定义 LOCAL_PATH 环境变量为本文件的目录，mydir 表示当前目录。</div><div class=\"line\">include $(CLEAR_VARS) ## 清除除了 LOCAL_PATH 以外其他的 LOCAL_ 环境变量</div><div class=\"line\">LOCAL_MODULE := jnitest ## 动态库名字为 jnitest</div><div class=\"line\">\tLOCAL_SRC_FILES := test.c ## 源文件名字</div><div class=\"line\">include $(BUILD_SHARED_LIBRARY) ## 编译生成共享动态库</div></pre></td></tr></table></figure>\n<p>4、在 jni 目录下创建 Application.mk。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><div class=\"line\">APP_ABI := all  ## 表示生成所有平台的动态库。</div></pre></td></tr></table></figure>\n<p>5、执行 <code>cd ..</code>，即跳到 jni 目录的父目录，并执行 <code>ndk-build</code>。</p>\n<p>此时就生成了 libs 目录，该目录中有以下目录，每个目录都有 “libjnitest.so”：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><div class=\"line\">arm64-v8a</div><div class=\"line\">armeabi</div><div class=\"line\">armeabi-v7a</div><div class=\"line\">mips</div><div class=\"line\">mips64</div><div class=\"line\">x86</div><div class=\"line\">x86_64</div></pre></td></tr></table></figure>\n<p>6、新建 Android 工程，将 libs 中的所有目录拷贝到 “src/main/jniLibs” 中，这是 Android Studio 识别的默认目录。</p>\n<p>7、在 me.xiazdong.ndkdemo 包下创建 Test 类。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">package</span> me.xiazdong.ndkdemo;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test</span> </span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">static</span>&#123;</div><div class=\"line\"> \t   System.loadLibrary(<span class=\"string\">\"jnitest\"</span>);</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">native</span> <span class=\"keyword\">int</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b)</span></span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>8、调用 Test 的 add 方法。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">Test t = <span class=\"keyword\">new</span> Test();</div><div class=\"line\"><span class=\"keyword\">int</span> c = t.add(<span class=\"number\">1</span>,<span class=\"number\">2</span>);</div></pre></td></tr></table></figure>\n<h2 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h2><ul>\n<li><a href=\"http://wiki.jikexueyuan.com/project/jni-ndk-developer-guide/workflow.html\" target=\"_blank\" rel=\"external\">JNI 开发流程</a></li>\n<li><a href=\"http://book.douban.com/subject/26599538/\" target=\"_blank\" rel=\"external\">Android开发艺术探索</a></li>\n</ul>\n","categories":[],"tags":["Android"]},{"title":"为什么 Major GC 比 Minor GC 慢很多？","url":"http://xiazdong.github.io/2015/09/12/为什么Major GC比Minor GC慢很多？/","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>前几天面试的时候有面试官问我：为什么 Major GC 比 Minor GC 慢很多？</p>\n<p>原因如下：</p>\n<ul>\n<li>新生代内存空间比老年代小。</li>\n<li>新生代和老年代采用的垃圾收集算法不同，即新生代采用的 Copying 算法比老年代采用的 Mark-Sweep 算法耗时更短。</li>\n</ul>\n<blockquote>\n<p>Major GC, Minor GC, 新生代, 老年代的概念请看：<a href=\"http://xiazdong.me/2015/01/03/jvm-memory-model/\" target=\"_blank\" rel=\"external\">http://xiazdong.me/2015/01/03/jvm-memory-model/</a>。</p>\n</blockquote>\n<h2 id=\"原理分析\"><a href=\"#原理分析\" class=\"headerlink\" title=\"原理分析\"></a>原理分析</h2><ul>\n<li>新生代一般采用 Copying 算法进行垃圾收集。</li>\n<li>老年代一般采用 Mark-Sweep 或 Mark-Compact 或两者组合的方式(定期进行 Compact)进行垃圾收集。</li>\n</ul>\n<h3 id=\"Mark-Sweep-算法\"><a href=\"#Mark-Sweep-算法\" class=\"headerlink\" title=\"Mark-Sweep 算法\"></a>Mark-Sweep 算法</h3><p>这个算法共有两个步骤：</p>\n<ul>\n<li>Mark: 从 GC Roots 开始遍历可达的所有节点，并对其标记。因此时间复杂度为存活对象的个数。</li>\n<li>Sweep: 对整个老年代内存进行遍历，并将没标记的内存块进行清理。</li>\n</ul>\n<p>伪代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">for</span>(Object obj : reachable objects)</div><div class=\"line\">\tmark(obj)</div><div class=\"line\"><span class=\"keyword\">for</span>(Object obj : old generation)</div><div class=\"line\">\t<span class=\"keyword\">if</span>(obj is not marked)</div><div class=\"line\">\t\tsweep(obj)</div></pre></td></tr></table></figure>\n<p>Mark-Sweep 算法的优点是简单方便，缺点是造成内存碎片。</p>\n<h3 id=\"Mark-Compact-算法\"><a href=\"#Mark-Compact-算法\" class=\"headerlink\" title=\"Mark-Compact 算法\"></a>Mark-Compact 算法</h3><p>由于 Mark-Sweep 算法会导致内存碎片化，因此就引入了 Mark-Compact 算法，该算法执行完毕后，存活的对象会按序放置，但是执行时间较长。</p>\n<p>Mark-Compact 是 <strong>时间换空间</strong>，Copying 是 <strong>空间换时间</strong>，他和 Copying 算法最后都是将存活的对象整理，但是 Mark-Compact 由于要在原有内存上做 Compact(空间更小)，因此耗费的时间比 Copying 时间更长(时间更长)。</p>\n<p>这个算法共两个步骤：</p>\n<ul>\n<li>Mark: 从 GC Roots 开始遍历可达的所有节点，并对其标记。因此时间复杂度为存活对象的个数。</li>\n<li>Compact: 对整个老年代内存进行遍历，并将没标记的内存块进行清理。</li>\n</ul>\n<p>伪代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">for</span>(Object obj : reachable objects)</div><div class=\"line\">\tmark(obj)</div><div class=\"line\"><span class=\"keyword\">for</span>(Object obj : old generation)</div><div class=\"line\">\t<span class=\"keyword\">if</span>(obj is not marked)</div><div class=\"line\">\t\tcompact(obj)</div></pre></td></tr></table></figure>\n<h3 id=\"Copying-算法\"><a href=\"#Copying-算法\" class=\"headerlink\" title=\"Copying 算法\"></a>Copying 算法</h3><p><img src=\"http://i.imgur.com/PyR1o2a.png\" width=\"600px\"></p>\n<p>Copying 算法是新生代采用的垃圾收集算法，他将新生代内存分成两块(或多块)，每次只使用其中的一块。因此浪费了一倍的内存空间，但是由于新生代的内存空间相比老年代较小，因此浪费一倍也还好。</p>\n<p>该算法就是 Mark-Sweep 算法的 Mark 阶段：遍历一遍 GC Roots 可达的所有节点(假设这些节点都在块1)，但是在遍历节点的同时，将该节点按序复制到新生代的另一块内存(块2)。当遍历完所有可达节点后，一次性将块1的内存清理干净。</p>\n<p>伪代码如下：</p>\n<figure class=\"highlight\"><table><tr><td class=\"code\"><pre><div class=\"line\">for(Object obj : reachable objects) # reachable objects is in block 1</div><div class=\"line\">\tmark(obj)</div><div class=\"line\">\tcopy obj to block 2</div><div class=\"line\">sweep block 1</div></pre></td></tr></table></figure>\n<p>Copying 算法的复杂度依赖于存活对象的个数，如果存活的对象太多，那么复制操作会占用很长时间，但是由于新生代具有存活对象很少的特点，因此该算法适用于新生代的垃圾收集。</p>\n<p>Copying 算法的优点是一次遍历即可完成，缺点是如果存活对象很多，那么复制操作会很耗时。</p>\n<h3 id=\"各算法时间比较\"><a href=\"#各算法时间比较\" class=\"headerlink\" title=\"各算法时间比较\"></a>各算法时间比较</h3><p>上面介绍了 Mark-Sweep, Mark-Compact, Copying 三种算法，总体来说可以归纳为：</p>\n<ul>\n<li>Mark-Sweep = Mark 操作 + Sweep 操作。</li>\n<li>Mark-Compact = Mark 操作 + Compact 操作。</li>\n<li>Copying = Mark 操作 + Copy 操作。</li>\n</ul>\n<p>这些操作的耗时比较：</p>\n<ul>\n<li>Compact &gt; Copy &gt; Mark &gt; Sweep</li>\n<li>Mark + Sweep &gt; Copy</li>\n</ul>\n<h2 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h2><ul>\n<li><a href=\"http://hllvm.group.iteye.com/group/topic/28594\" target=\"_blank\" rel=\"external\">Mark-Sweep 和 Copy 算法的区别(1)</a></li>\n<li><a href=\"http://hllvm.group.iteye.com/group/topic/38223#post-248757\" target=\"_blank\" rel=\"external\">Mark-Sweep 和 Copy 算法的区别(2)</a></li>\n<li><a href=\"http://www.cnblogs.com/redcreen/archive/2011/05/04/2037057.html\" target=\"_blank\" rel=\"external\">JVM系列三:JVM参数设置、分析</a></li>\n</ul>\n","categories":[],"tags":["Android"]},{"title":"如何分析 ANR 的原因","url":"http://xiazdong.github.io/2015/09/11/android-how-to-analyze-anr/","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>这个问题是面试的时候被问到的，问题原话：”怎么查看 ANR Log?”。</p>\n<blockquote>\n<p>我们写程序其实并不仅仅是避免 ANR，而是要让应用体验”如丝般顺滑”。</p>\n</blockquote>\n<h2 id=\"引发-ANR-的原因\"><a href=\"#引发-ANR-的原因\" class=\"headerlink\" title=\"引发 ANR 的原因\"></a>引发 ANR 的原因</h2><p>当用户的输入事件(Input Event，如按键或触摸)在5秒内得不到响应 或者 BroadcastReceiver 在 10秒内未做完，就会引发 ANR。一般来说，引起 ANR 的原因：</p>\n<ul>\n<li>主线程有耗时的计算操作。</li>\n<li>主线程在等待获取某个资源(可能是死锁)。</li>\n<li>主线程睡眠太久。</li>\n</ul>\n<p>简单地说就是主线程卡住了，导致用户的输入事件处理不了。</p>\n<h2 id=\"分析-ANR-的原因\"><a href=\"#分析-ANR-的原因\" class=\"headerlink\" title=\"分析 ANR 的原因\"></a>分析 ANR 的原因</h2><p>当发生 ANR 时，我们可以从两部分查看原因：</p>\n<ul>\n<li>初步：Logcat 的 ANR 日志查看 CPU 使用率。如果 CPU 使用率很高，表明有耗时计算。</li>\n<li>深入：查看 “/data/anr/traces.txt” 文件。</li>\n</ul>\n<h3 id=\"Logcat-ANR-Log\"><a href=\"#Logcat-ANR-Log\" class=\"headerlink\" title=\"Logcat ANR Log\"></a>Logcat ANR Log</h3><p>这块日志主要分为三部分。</p>\n<p>第一部分：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">512-670/system_process E/ActivityManager﹕ ANR in me.xiazdong.anrdemo (me.xiazdong.anrdemo/.MainActivity)</div><div class=\"line\">Reason: keyDispatchingTimedOut</div></pre></td></tr></table></figure>\n<p>从上面看出导致 ANR 的原因是 “keyDispatchingTimeOut”。</p>\n<p>第二部分：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">CPU usage from 18523ms to 0ms ago with 99% awake:</div><div class=\"line\">16% 753/com.android.systemui: 13% user + 3.2% kernel / faults: 124 minor</div><div class=\"line\">13% 175/surfaceflinger: 4.2% user + 9% kernel / faults: 3572 minor</div><div class=\"line\">6.4% 512/system_server: 4.7% user + 1.7% kernel / faults: 850 minor</div><div class=\"line\">3% 256/adbd: 0.2% user + 2.8% kernel / faults: 1033 minor</div><div class=\"line\">1.1% 252/mpdecision: 0.1% user + 1% kernel</div><div class=\"line\">0.9% 6652/kworker/0:2: 0% user + 0.9% kernel</div><div class=\"line\">0.8% 1896/cn.ledongli.ldl: 0.6% user + 0.1% kernel / faults: 7 minor</div><div class=\"line\">0.8% 27946/kworker/0:3: 0% user + 0.8% kernel</div><div class=\"line\">0.7% 4711/kworker/u:3: 0% user + 0.7% kernel</div><div class=\"line\">0.5% 3059/com.jianshu.haruki:pushservice: 0.4% user + 0.1% kernel / faults: 24 minor</div><div class=\"line\">0.5% 3607/com.jianshu.haruki: 0.3% user + 0.1% kernel / faults: 2 minor</div><div class=\"line\">0.4% 172/netd: 0.2% user + 0.2% kernel</div><div class=\"line\">0.4% 168/vold: 0.3% user + 0% kernel</div><div class=\"line\">0.3% 127/ueventd: 0.2% user + 0.1% kernel</div><div class=\"line\">0.3% 305/sensors.qcom: 0.1% user + 0.2% kernel</div><div class=\"line\">0.1% 4157/com.ttyongche:ixintui_service_v1: 0.1% user + 0% kernel / faults: 13 minor</div><div class=\"line\">0.1% 8844/com.eg.android.AlipayGphone:push: 0.1% user + 0% kernel / faults: 18 minor</div><div class=\"line\">0% 114/irq/294-atmel_m: 0% user + 0% kernel</div><div class=\"line\">0.1% 167/servicemanager: 0% user + 0% kernel</div><div class=\"line\">0.1% 726/MC_Thread: 0% user + 0.1% kernel</div><div class=\"line\">0.1% 1024/com.android.deskclock: 0.1% user + 0% kernel / faults: 7 minor</div><div class=\"line\">0.1% 9357/com.taobao.taobao: 0% user + 0% kernel / faults: 4 minor</div><div class=\"line\">0% 13958/me.xiazdong.anrdemo: 0% user + 0% kernel / faults: 5 minor</div><div class=\"line\">0% 119/mmcqd/0: 0% user + 0% kernel</div><div class=\"line\">0% 134/jbd2/mmcblk0p26: 0% user + 0% kernel</div><div class=\"line\">0% 728/RX_Thread: 0% user + 0% kernel</div><div class=\"line\">0% 748/wpa_supplicant: 0% user + 0% kernel</div><div class=\"line\">0% 870/com.android.settings: 0% user + 0% kernel</div><div class=\"line\">0% 903/com.baidu.input_mi: 0% user + 0% kernel / faults: 13 minor</div><div class=\"line\">0% 997/com.miui.whetstone: 0% user + 0% kernel</div><div class=\"line\">0% 1301/com.miui.providers.weather: 0% user + 0% kernel</div><div class=\"line\">0% 3011/com.ttyongche:pushservice: 0% user + 0% kernel</div><div class=\"line\">0% 3152/com.ttyongche: 0% user + 0% kernel / faults: 3 minor</div><div class=\"line\">0% 6088/com.tencent.mm: 0% user + 0% kernel / faults: 12 minor</div><div class=\"line\">0% 10189/android.process.media: 0% user + 0% kernel / faults: 4 minor</div><div class=\"line\">0% 10582/kworker/u:0: 0% user + 0% kernel</div><div class=\"line\">0% 13795/com.android.packageinstaller: 0% user + 0% kernel</div><div class=\"line\">0% 27537/kworker/u:2: 0% user + 0% kernel</div><div class=\"line\">0% 31641/logcat: 0% user + 0% kernel</div><div class=\"line\">123% TOTAL: 67% user + 55% kernel + 0.9% iowait</div></pre></td></tr></table></figure>\n<p>这部分显示在 ANR 发生之前 CPU 使用状况。</p>\n<p>第三部分：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">CPU usage from 3154ms to 3704ms later:</div><div class=\"line\">14% 753/com.android.systemui: 8.7% user + 5.2% kernel</div><div class=\"line\">14% 753/ndroid.systemui: 10% user + 3.5% kernel</div><div class=\"line\">1.7% 11566/GL updater: 0% user + 1.7% kernel</div><div class=\"line\">12% 175/surfaceflinger: 5.4% user + 7.2% kernel / faults: 108 minor</div><div class=\"line\">5.4% 467/SurfaceFlinger: 3.6% user + 1.8% kernel</div><div class=\"line\">1.8% 475/GL updater: 1.8% user + 0% kernel</div><div class=\"line\">1.8% 479/SurfaceFlinger: 0% user + 1.8% kernel</div><div class=\"line\">1.8% 480/EventThread: 0% user + 1.8% kernel</div><div class=\"line\">1.8% 914/Binder_2: 0% user + 1.8% kernel</div><div class=\"line\">1.8% 12653/Binder_5: 0% user + 1.8% kernel</div><div class=\"line\">12% 512/system_server: 5.4% user + 7.2% kernel / faults: 9 minor</div><div class=\"line\">7.2% 670/InputDispatcher: 0% user + 7.2% kernel</div><div class=\"line\">1.8% 656/UEventObserver: 0% user + 1.8% kernel</div><div class=\"line\">1.8% 1019/Binder_B: 1.8% user + 0% kernel</div><div class=\"line\">1.8% 5056/Binder_10: 1.8% user + 0% kernel</div><div class=\"line\">0.8% 252/mpdecision: 0% user + 0.8% kernel</div><div class=\"line\">1.6% 286/mpdecision: 0% user + 1.6% kernel</div><div class=\"line\">1.8% 256/adbd: 0% user + 1.8% kernel / faults: 18 minor</div><div class=\"line\">1.8% 256/adbd: 0% user + 1.8% kernel</div><div class=\"line\">0.8% 305/sensors.qcom: 0.8% user + 0% kernel</div><div class=\"line\">0.8% 478/sensors.qcom: 0.8% user + 0% kernel</div><div class=\"line\">0.9% 3059/com.jianshu.haruki:pushservice: 0.9% user + 0% kernel / faults: 2 minor</div><div class=\"line\">0.9% 3218/Thread-5534: 0.9% user + 0% kernel</div><div class=\"line\">0.9% 3607/com.jianshu.haruki: 0.9% user + 0% kernel</div><div class=\"line\">0.9% 3648/Thread-5534: 0.9% user + 0% kernel</div><div class=\"line\">1.3% 27946/kworker/0:3: 0% user + 1.3% kernel</div><div class=\"line\">13% TOTAL: 6.8% user + 6.8% kernel</div></pre></td></tr></table></figure>\n<p>这部分主要输出 ANR 这段时间内 CPU 使用状况，如果 CPU 使用率特别高，可能就能表明主线程有耗时的计算操作。</p>\n<h3 id=\"traces-txt\"><a href=\"#traces-txt\" class=\"headerlink\" title=\"traces.txt\"></a>traces.txt</h3><p>在查看文件内容之前，我们需要了解线程的所有状态。</p>\n<ul>\n<li>THREAD_ZOMBIE: 线程已经终止了。</li>\n<li>THREAD_RUNNING: 线程是 Runnable 的或者正在运行的。</li>\n<li>THREAD_TIMED_WAIT: 线程调用 <code>Object.wait(long millis)</code> 时阻塞。</li>\n<li>THREAD_MONITOR: 线程在获取锁时阻塞。</li>\n<li>THREAD_WAIT: 线程调用 <code>Object.wait()</code> 时阻塞。</li>\n<li>THREAD_INITIALIZING: 线程还没准备好，不能被运行。</li>\n<li>THREAD_STARTING: 线程还没准备好，不能被运行。</li>\n<li>THREAD_NATIVE: 线程在执行 Native Method。</li>\n<li>THREAD_VMWAIT: 线程在等待 VM 的资源。</li>\n<li>THREAD_SUSPENDED: 线程已经被挂起(暂停)，在等待被恢复(resume)。最典型的状况是GC线程在工作，主线程被挂起。</li>\n</ul>\n<p>状态转换图如下：</p>\n<p><img src=\"http://i.imgur.com/3lAAAYg.png\" width=\"800px\"></p>\n<p>在 traces.txt 文件的开头就是最近这次 ANR 的日志。</p>\n<p>这里我们通过几个例子来看看如何分析日志。</p>\n<p>1、在按钮的 onClick() 中调用 Thread.sleep()，日志如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">DALVIK THREADS (17):</div><div class=\"line\">\t&quot;main&quot; prio=5 tid=1 Sleeping ## 表示 ANR 时主线程处于 Sleeping 状态</div><div class=\"line\">| group=&quot;main&quot; sCount=1 dsCount=0 obj=0x73258000 self=0xb4827800</div><div class=\"line\">| sysTid=21428 nice=0 cgrp=default sched=0/0 handle=0xb6f82bec</div><div class=\"line\">| state=S schedstat=( 162539642 60048744 257 ) utm=12 stm=4 core=1 HZ=100</div><div class=\"line\">| stack=0xbe009000-0xbe00b000 stackSize=8MB</div><div class=\"line\">| held mutexes=</div><div class=\"line\">at java.lang.Thread.sleep!(Native method) ## 通过该堆栈可以看出ANR的原因</div><div class=\"line\">- sleeping on &lt;0x02b70dd5&gt; (a java.lang.Object)</div><div class=\"line\">at java.lang.Thread.sleep(Thread.java:1031)</div><div class=\"line\">- locked &lt;0x02b70dd5&gt; (a java.lang.Object)</div><div class=\"line\">at java.lang.Thread.sleep(Thread.java:985)</div><div class=\"line\">at me.xiazdong.anrdemo.MainActivity.clickHandler(MainActivity.java:20)</div><div class=\"line\">at java.lang.reflect.Method.invoke!(Native method)</div><div class=\"line\">at java.lang.reflect.Method.invoke(Method.java:372)</div><div class=\"line\">at android.view.View$1.onClick(View.java:4015)</div></pre></td></tr></table></figure>\n<p>2、主线程和子线程产生死锁，日志如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&quot;main&quot; prio=5 tid=1 MONITOR  ## MONITOR 表示线程是 BLOCKED 状态，即被阻塞住了。</div><div class=\"line\">| group=&quot;main&quot; sCount=1 dsCount=0 obj=0x417bd700 self=0x400310b0</div><div class=\"line\">| sysTid=13958 nice=0 sched=0/0 cgrp=apps handle=1074507568</div><div class=\"line\">| schedstat=( 0 0 0 ) utm=25 stm=6 core=0</div><div class=\"line\">at me.xiazdong.anrdemo.MainActivity.clickHandler(MainActivity.java:~46) \t## 发生问题的地方是 clickHandler 方法</div><div class=\"line\">- waiting to lock &lt;0x425a0530&gt; (a java.lang.Object) held by tid=11 (Thread-3849) ## 主线程正在等待 Thread-3849 线程拥有的资源</div><div class=\"line\">at java.lang.reflect.Method.invokeNative(Native Method)</div><div class=\"line\">at java.lang.reflect.Method.invoke(Method.java:511)</div><div class=\"line\">at android.view.View$1.onClick(View.java:3671)</div><div class=\"line\"></div><div class=\"line\">----------------------------</div><div class=\"line\"></div><div class=\"line\">&quot;Thread-3849&quot; prio=5 tid=11 MONITOR</div><div class=\"line\">| group=&quot;main&quot; sCount=1 dsCount=0 obj=0x425e6150 self=0x67f36008</div><div class=\"line\">| sysTid=13992 nice=0 sched=0/0 cgrp=apps handle=1716642824</div><div class=\"line\">| schedstat=( 0 0 0 ) utm=0 stm=0 core=0</div><div class=\"line\">at me.xiazdong.anrdemo.MainActivity$1.run(MainActivity.java:~31) </div><div class=\"line\">- waiting to lock &lt;0x425a0520&gt; (a java.lang.Object) held by tid=1 (main) ## Thread-3849 线程在等待主线程拥有的资源</div></pre></td></tr></table></figure>\n<h2 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h2><ul>\n<li><a href=\"http://stackoverflow.com/questions/704311/android-how-do-i-investigate-an-anr\" target=\"_blank\" rel=\"external\">StackOverflow: 怎么分析 ANR</a></li>\n<li><a href=\"http://elliotth.blogspot.com/2012/08/how-to-read-dalvik-sigquit-output.html\" target=\"_blank\" rel=\"external\">解释线程的所有状态</a></li>\n<li><a href=\"http://droidyue.com/blog/2015/07/18/anr-in-android/\" target=\"_blank\" rel=\"external\">说说Android中的ANR</a></li>\n</ul>\n","categories":[],"tags":["Android"]},{"title":"Android反编译技术入门","url":"http://xiazdong.github.io/2015/09/08/android-decompile/","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>Android反编译是平常接触比较少的技术，最近由于项目需要，需要查看B612在各个机型的预览分辨率（每次打开相机或切换比例时能够有选取的预览分辨率日志），因此需要三个步骤：</p>\n<ul>\n<li>反编译，将dex文件变成smali代码。</li>\n<li>在合适的地方通过smali代码方式加一些日志。</li>\n<li>重新打包。</li>\n</ul>\n<p>我们这里需要两个工具：</p>\n<ul>\n<li><a href=\"https://ibotpeaches.github.io/Apktool/\" target=\"_blank\" rel=\"external\">Apktool</a>：能够对APK中的dex文件反编译成smali代码，并修改，然后重新打包APK。</li>\n<li><a href=\"https://github.com/skylot/jadx\" target=\"_blank\" rel=\"external\">jadx</a>：能够快速将APK的dex文件变成Java代码，而且还有全局文字搜索功能，因此我们通过搜索关键字，找到你需要了解的代码的位置。</li>\n</ul>\n<h2 id=\"反编译\"><a href=\"#反编译\" class=\"headerlink\" title=\"反编译\"></a>反编译</h2><p>首先通过”apktool d -f -r -o \\<dest-dir\\> \\<apk\\>“将APK反编译（Disassemble），使得dex文件变成smali代码。</apk\\></dest-dir\\></p>\n<h2 id=\"加日志\"><a href=\"#加日志\" class=\"headerlink\" title=\"加日志\"></a>加日志</h2><p>接着我们需要寻找在哪里加日志，这里通过Jadx打开APK，初始界面如下：</p>\n<p><img src=\"https://raw.githubusercontent.com/xiazdong/blog-image/master/jadx-gui.png\" width=\"700px\"></p>\n<p>我们可以在里面大致看出结构，这里我们点击”Navigation”-&gt;”Text Search”，并搜索”setPreviewSize”，结果如下：</p>\n<p><img src=\"https://raw.githubusercontent.com/xiazdong/blog-image/master/jadx-text-search.png\" width=\"500px\"></p>\n<p>基本可以判定打日志一定在defpackge.abl类的Dn()方法中，通过查看两处，很容易判断应该在哪里加日志。</p>\n<p>这里只能通过书写Smali代码的方式加入打日志功能，凭空直接写Smali代码会很困难，因此我们先在demo工程中写Java代码，如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">int</span> w = ...;   <span class=\"comment\">//width</span></div><div class=\"line\"><span class=\"keyword\">int</span> h =  ...;    <span class=\"comment\">//height</span></div><div class=\"line\">StringBuilder b = <span class=\"keyword\">new</span> StringBuilder();</div><div class=\"line\">String str = b.append(w).append(<span class=\"string\">\"*\"</span>).append(h).toString();</div><div class=\"line\">Log.v(<span class=\"string\">\"B612PreviewSize\"</span>, str);</div></pre></td></tr></table></figure>\n<p>然后编译成apk，并通过apktool反编译，查看该Java代码对应的Smali代码，基本就可以直接复制黏贴过来，如下：</p>\n<figure class=\"highlight smali\"><table><tr><td class=\"code\"><pre><div class=\"line\">//前提：v0存着宽度，v1存着高度</div><div class=\"line\">//定义常量<span class=\"built_in\"></span></div><div class=\"line\">const-string v12 , <span class=\"string\">\"B612PreviewSize\"</span><span class=\"built_in\"></span></div><div class=\"line\">const-string v13 , <span class=\"string\">\"*\"</span></div><div class=\"line\"></div><div class=\"line\">//初始化StringBuilder变量<span class=\"built_in\"></span></div><div class=\"line\">new-instance v14, <span class=\"class\">Ljava/lang/StringBuilder;</span><span class=\"built_in\"></span></div><div class=\"line\">invoke-direct &#123;v14&#125;, <span class=\"class\">Ljava/lang/StringBuilder;</span>-&gt;&lt;init&gt;()V</div><div class=\"line\"></div><div class=\"line\">//b.append(w)<span class=\"built_in\"></span></div><div class=\"line\">invoke-virtual &#123;v14, v0&#125;, <span class=\"class\">Ljava/lang/StringBuilder;</span>-&gt;append(I)<span class=\"class\">Ljava/lang/StringBuilder;</span><span class=\"built_in\"></span></div><div class=\"line\">move-result-object v14</div><div class=\"line\">//b.append(<span class=\"string\">\"*\"</span>)</div><div class=\"line\">invoke-virtual&#123;v14,v13&#125;,<span class=\"class\">Ljava/lang/StringBuilder;</span>-&gt;append(<span class=\"class\">Ljava/lang/String;</span>)<span class=\"class\">Ljava/lang/StringBuilder;</span><span class=\"built_in\"></span></div><div class=\"line\">move-result-object v14</div><div class=\"line\">//b.append(h)<span class=\"built_in\"></span></div><div class=\"line\">invoke-virtual &#123;v14, v1&#125;, <span class=\"class\">Ljava/lang/StringBuilder;</span>-&gt;append(I)<span class=\"class\">Ljava/lang/StringBuilder;</span><span class=\"built_in\"></span></div><div class=\"line\">move-result-object v14</div><div class=\"line\">//b.toString()<span class=\"built_in\"></span></div><div class=\"line\">invoke-virtual &#123;v14&#125;, <span class=\"class\">Ljava/lang/StringBuilder;</span>-&gt;toString()<span class=\"class\">Ljava/lang/String;</span><span class=\"built_in\"></span></div><div class=\"line\">move-result-object v14</div><div class=\"line\"><span class=\"built_in\"></span></div><div class=\"line\">invoke-static &#123;v12, v14&#125;, <span class=\"class\">Landroid/util/Log;</span>-&gt;e(<span class=\"class\">Ljava/lang/String;</span><span class=\"class\">Ljava/lang/String;</span>)I</div></pre></td></tr></table></figure>\n<h2 id=\"重新打包\"><a href=\"#重新打包\" class=\"headerlink\" title=\"重新打包\"></a>重新打包</h2><p>我们首先通过”apktool b -o \\<out.apk\\> \\<input-dir\\>“对目录进行重新编译，生成hack.apk，如果直接安装会出现”INSTALL_PARSE_FAILED_NO_CERTIFICATES”错误。</input-dir\\></out.apk\\></p>\n<p>因为修改了内容，但是校验签名出现问题，因此需要重新签名。</p>\n<p>首先生成一个keystore，命令行输入：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">keytool -genkey -alias b612.keystore -keyalg RSA -validity 40000 -keystore b612.keystore</div></pre></td></tr></table></figure>\n<p>然后对hack.apk二次签名，命令行输入：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">jarsigner-overbose -keystore b612.keystore b612-hack.apk b612.keystore</div></pre></td></tr></table></figure>\n<p>最后将hack.apk安装到手机即可。</p>\n<p>我们把重新打包的APK在魅族Pro5上进行测试，对于前置摄像头，9比16的预览分辨率是1280*720，3比4和1比1的预览分辨率是1440*1080。</p>\n","categories":[],"tags":["Android"]},{"title":"JVM内存模型","url":"http://xiazdong.github.io/2015/08/12/JVM内存模型/","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><blockquote>\n<p>本文内容大多来自《深入理解Java虚拟机》，但是经过整理，语言更加简练。</p>\n</blockquote>\n<p>本篇为JVM入门系列的第一篇。本系列一共分为：</p>\n<ol>\n<li>JVM 内存模型。</li>\n<li>垃圾收集算法。</li>\n<li>类加载机制。</li>\n</ol>\n<h2 id=\"JVM-介绍\"><a href=\"#JVM-介绍\" class=\"headerlink\" title=\"JVM 介绍\"></a>JVM 介绍</h2><p>JVM(Java Virtual Machine)是Java程序员很熟悉的名字，但是他不只局限于Java语言，实际上JVM还支持其他语言运行在JVM上。</p>\n<p>总的来说，JVM具有以下两个特性：</p>\n<ol>\n<li><strong>跨平台</strong>：Java程序员应该很清楚这一点，由于JVM，Java语言能够实现”Write Once, Run Anywhere”。</li>\n<li><strong>跨语言</strong>：近年来出现了很多基于JVM的语言，比如 Groovy, Scala 等，之所以称为”基于JVM的语言”是因为JVM的输入其实是字节码格式的文件(而不是Java程序)，而这些语言经过各自编译器编译后变成了字节码格式文件，因此能够在JVM上运行。</li>\n</ol>\n<p>虚拟机其实有很多，比如 Sun Hotspot VM(目前所说的JVM就是这个)，Dalvik VM(Android 的虚拟机)，JRocket VM(另一款JVM，目前也被Oracle收购)。</p>\n<p>JVM 分为 Client 模式和 Server 模式，可以用 <code>java -version</code> 查看。</p>\n<p>JVM 是基于栈的体系结构(其他还有累加器的体系结构、寄存器-寄存器的体系结构等)，这就限制了字节码指令的输入格式，比如 pop 指令表示将栈顶元素出栈，iadd 指令表示将栈顶两个元素相加后再放入栈顶(pop,iadd都是字节码指令)。</p>\n<h2 id=\"JVM-内存模型\"><a href=\"#JVM-内存模型\" class=\"headerlink\" title=\"JVM 内存模型\"></a>JVM 内存模型</h2><p><img src=\"http://i.imgur.com/1aKmO0o.jpg\" alt=\"JVM 内存模型图\"></p>\n<p> JVM拥有自己的内存空间，这块内存空间可以划分成以下几大区域：</p>\n<ol>\n<li><strong>程序计数器</strong>(Program Counter Register): <strong>线程私有</strong>。值为一个整数，表示当前正在执行的字节码指令的地址。</li>\n<li><strong>虚拟机栈</strong>(VM Stack): <strong>线程私有</strong>。他是一个栈，每个元素是一个栈帧(Stack Frame)，一个栈帧表示一个方法调用的状态，栈顶的栈帧为当前正在执行的方法的栈帧。</li>\n<li><strong>本地方法栈</strong>(Native Method Stack): <strong>线程私有</strong>。与虚拟机栈的唯一区别是虚拟机栈中所说的方法是Java方法，而本地方法栈中的方法是Native方法。Hotspot将虚拟机栈和本地方法栈合二为一，即在Hotspot中只有虚拟机栈，没有本地方法栈。</li>\n<li><strong>堆</strong>(Heap): <strong>线程共享</strong>。存放几乎所有的对象实例和数组。他也被称为”GC堆”，因为堆是垃圾收集器的主要管理区域。为了使分配内存和回收内存更方便，堆被分为：<ul>\n<li><strong>新生代</strong>(Young Generation)：之所以称为新生代，是因为每次GC时这块区域的对象都有大批死去，即来得快去得也快(IBM统计约为98%的对象死去)。这部分的垃圾收集也称为 Young GC/Minor GC。新生代区可以继续分为 Eden 区，From Survivor 区，To Survivor 区(即一块 Eden 区，两块 Survivor 区)，From Survivor 区和 To Survivor 区只能使用一个，不能同时使用。一般刚创建的对象被分配在年轻代的 Eden 区(例外是如果一个对象很大，以至于在年轻代的 Eden 区放不下，那么直接进入老年代)，熬过一个 Young GC 后进入 Survivor 区。当年轻代的对象熬过若干个 Young GC 后进入老年代（因为年纪大了）。</li>\n<li><strong>老年代</strong>(Tenured Generation)：之所以称为老年代，是因为每次GC时这块区域的对象存活率较高。这部分的垃圾收集也称为 Full GC/Major GC。一般来说年轻代的空间比老年带的空间小。</li>\n<li>对于上面不同类型的堆内存都存在不同的GC算法，因此这种GC算法称为”分代回收算法”。Young GC 比 Major GC 频率更高，速度更快。</li>\n<li>当多个线程同时分配对象时，为了线程安全，需要对整个堆加锁，这很影响性能(锁的粒度太大)，因此提出了 TLAB(Thread Local Allocation Buffers)，特点是为每个线程在Eden区分配一个缓冲区，每个线程只使用自己的TLAB，等到空间用完了再使用全局锁。</li>\n</ul>\n</li>\n<li><strong>方法区</strong>(Method Area): <strong>线程共享</strong>。存储类元数据、常量、静态变量。Hotspot将其称为永久代(Permanent Generation)，目的是为了表示这块区域的数据一旦生成就不太改变(虽然不是一直不变)，但是这部分区域也需要GC。运行时常量池(Runtime Constant Pool)是方法区的一部分，用来存放符号引用，常量，直接引用等。JDK 1.7开始，字符串常量池从方法区中移出。</li>\n</ol>\n<h3 id=\"对象的那些事\"><a href=\"#对象的那些事\" class=\"headerlink\" title=\"对象的那些事\"></a>对象的那些事</h3><blockquote>\n<p>问题1：新创建的对象如何在堆中分配内存？</p>\n</blockquote>\n<ol>\n<li>若堆中内存是规整的，即可以有一道分界线来划分出两块区域，一块是已分配的内存，另一块是未分配的内存，则使用”<strong>指针碰撞</strong>“(Bump the Pointer)，即用指针来作为分界线。</li>\n<li>若堆中内存是不规整的，则使用”<strong>空间列表</strong>“(Free List)，即用一个列表记录未分配的内存，列表的每个元素为一块未分配的内存，包含起始地址和长度。若要分配对象，则只需要在空间列表中找出一个足够大的区域即可。</li>\n</ol>\n<p>堆是否规整和垃圾收集器采用的GC算法有关，即回收之后是否对堆内存进行压缩整理。</p>\n<blockquote>\n<p>问题2：如何找出对象的类型？</p>\n</blockquote>\n<p>对象实例可以划分为对象头、实例数据、对齐填充。对象头中包含了很多信息，比如对象的hashcode、类型指针等，其中类型指针就是指向方法区的类元数据。</p>\n<h2 id=\"相关虚拟机参数\"><a href=\"#相关虚拟机参数\" class=\"headerlink\" title=\"相关虚拟机参数\"></a>相关虚拟机参数</h2><ul>\n<li><code>-Xmx2g</code>: 堆的最大允许内存为2G。</li>\n<li><code>-Xms2m</code>: 堆的最小允许内存为2M。</li>\n<li><code>-Xmn1m</code>: 堆中年轻代的内存为1M。</li>\n<li><code>-XX:PermSize=128m</code>: 永久代大小为128M。</li>\n<li><code>-XX:MaxPermSize=128m</code>: 永久代最大允许128M。</li>\n<li><code>-Xss128k</code>: 虚拟机栈为128K。</li>\n<li><code>-XX:SurvivorRatio=8</code>: 年轻代中Eden区与Survivor区的容量比值为8。</li>\n<li><code>-XX:PrintGCDetails</code>: 每次GC时输出日志。</li>\n<li><code>-XX:+HeapDumpOnOutOfMemoryError</code>: 在OOM时Dump出堆的日志文件。</li>\n<li><code>-XX:+DisableExplicitGC</code>: 禁用显式GC，即忽略程序中调用的<code>System.gc()</code>。</li>\n</ul>\n","categories":[],"tags":["Android"]},{"title":"Android 抓包实践总结","url":"http://xiazdong.github.io/2015/07/14/Android 抓包实践总结/","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>Android 网络通信是 Android 开发的一个很重要的部分，而抓包能够查看网络通信的具体细节，因此在平时开发过程中经常用到。</p>\n<p>本文将讲解几种抓包形式：</p>\n<ol>\n<li>Charles 实现实时 HTTP/HTTPS 抓包。</li>\n<li>Wireshark+Tcpdump 实现非实时 TCP+HTTP 抓包。</li>\n<li>Wireshark+Tcpdump+nc 实现实时 TCP+HTTP 抓包。</li>\n<li>Stetho 实现侵入式 HTTP 抓包。</li>\n</ol>\n<p>如果只需要查看 HTTP 包，那么只需要使用 Charles，但是如果想要看 TCP 包，那么需要用到 Wireshark。</p>\n<blockquote>\n<p>本文的环境是 MAC OS，Android 手机必须 Root。</p>\n</blockquote>\n<ul>\n<li>Charles 安装：<a href=\"http://blog.csdn.net/jiangwei0910410003/article/details/41620363\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/jiangwei0910410003/article/details/41620363</a></li>\n<li>Wireshark 安装：<a href=\"http://blog.csdn.net/phunxm/article/details/38590561\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/phunxm/article/details/38590561</a></li>\n</ul>\n<h2 id=\"Charles-实时-HTTP-抓包\"><a href=\"#Charles-实时-HTTP-抓包\" class=\"headerlink\" title=\"Charles 实时 HTTP 抓包\"></a>Charles 实时 HTTP 抓包</h2><ul>\n<li>进入 WIFI 设置，设置 WIFI 网络的代理，如下图：</li>\n</ul>\n<p><img src=\"http://i.imgur.com/ChnqdoO.png\" width=\"300px\"></p>\n<ul>\n<li>设置完之后，你在手机的浏览器访问”tu.qq.com”，就能在 Charles 中实时查看，如下图：</li>\n</ul>\n<p><img src=\"http://i.imgur.com/9lvVnbP.png\" width=\"1000px\"></p>\n<p>当然，Charles 也可以抓取 HTTPS 包，但是因为 HTTPS 的报文是加密的，因此为了能够看到明文的报文，过程如下：</p>\n<ul>\n<li>从 <a href=\"http://www.charlesproxy.com/documentation/additional/legacy-ssl-proxying/\" target=\"_blank\" rel=\"external\">这里</a> 下载名为”charles.crt”证书，并通过”adb push charles.crt /mnt/sdcard”放入手机，然后”设置”-&gt;”安全”-&gt;”从存储设备安装”为手机安装证书。</li>\n</ul>\n<p>这样就可以了。你可以在浏览器中输入”www.baidu.com”，发现可以看到请求和响应都是明文了。</p>\n<h2 id=\"Wireshark-Tcpdump-非实时-TCP-HTTP-抓包\"><a href=\"#Wireshark-Tcpdump-非实时-TCP-HTTP-抓包\" class=\"headerlink\" title=\"Wireshark+Tcpdump 非实时 TCP+HTTP 抓包\"></a>Wireshark+Tcpdump 非实时 TCP+HTTP 抓包</h2><p>Charles 只能抓取并查看 HTTP(S) 的包，但是如果想抓取并查看 TCP 的包，就不能不用 Tcpdump(抓取 TCP 包) 和 Wireshark(查看 TCP 包)。</p>\n<p>很多人会说，你抓 TCP 包干啥，又没什么用。因为 HTTP 协议是建立在 TCP 协议之上的，因此通过查看 TCP 包的情况可以看出：HTTP 通信的 TCP 连接是否被复用。</p>\n<ul>\n<li>从 <a href=\"https://github.com/xiazdong/xiazdong.github.io/blob/master/_posts/tcpdump\" target=\"_blank\" rel=\"external\">这里</a> 下载 Tcpdump。</li>\n<li>将 tcpdump 放入手机：<code>adb push ./tcpdump /data/local/tcpdump</code>。</li>\n<li>将 tcpdump 的权限变为可执行：<code>chmod +x tcpdump</code>。</li>\n<li>开始抓包：<code>/data/local/tcpdump -vv -s 0 -w /mnt/sdcard/pcapture.pcap</code>。其中 “-s 0” 表示每个包都抓取全部长度，而不是部分长度；”-w /mnt/sdcard/pcapture.pcap” 表示抓取的包写入指定文件；”-vv” 表示显示多一些信息，如果要显示更多信息可以用 “-vvv”。</li>\n<li>按下 “contrl+c” 结束抓包。</li>\n<li>将”/mnt/sdcard/pcapture.pcap” 移到电脑上：<code>adb pull /mnt/sdcard/pcapture.pcap &lt;指定目录&gt;</code>。</li>\n<li>通过 Wireshark 进行分析。我们可以通过 Wireshark 的 “Follow TCP Stream” 查看一条 TCP 连接是否被复用。</li>\n</ul>\n<p>TCPDUMP 默认采用混杂模式，即能够抓取其他进程的包。</p>\n<blockquote>\n<ul>\n<li>Tcpdump 命令：<a href=\"http://www.berlinix.com/net/tcpdump.php\" target=\"_blank\" rel=\"external\">http://www.berlinix.com/net/tcpdump.php</a></li>\n<li>Wireshark命令：<a href=\"http://www.qtasp.cn/wiresharkcharpt/Customizing%20wireshark.html\" target=\"_blank\" rel=\"external\">http://www.qtasp.cn/wiresharkcharpt/Customizing%20wireshark.html</a></li>\n</ul>\n</blockquote>\n<h2 id=\"Wireshark-实时-TCP-HTTP-抓包\"><a href=\"#Wireshark-实时-TCP-HTTP-抓包\" class=\"headerlink\" title=\"Wireshark 实时 TCP+HTTP 抓包\"></a>Wireshark 实时 TCP+HTTP 抓包</h2><p>非实时抓包一般已经足够了，但是不是特别方便，也不够装逼，因为每次抓包都需要做很多步骤，先手机抓，抓完了再导入电脑看。因此这里给出一个实时抓取并查看 TCP+HTTP 包的方法。</p>\n<p>基本思路如下：</p>\n<p><img src=\"http://i.imgur.com/ffV4vq4.png\" width=\"500px\"></p>\n<ul>\n<li>为手机安装 Busybox：<a href=\"http://xiazdong.me/2015/06/30/introduction-to-busybox/\" target=\"_blank\" rel=\"external\">http://xiazdong.me/2015/06/30/introduction-to-busybox/</a></li>\n<li>在 adb shell 中运行 <code>mount -o remount,rw /</code>：将目录从只读变为可读写。</li>\n<li>在 adb shell 中运行 <code>/data/local/tcpdump -n -vv -s 0 -w – | nc -l -p 11233</code>：手机开始抓包。</li>\n<li>另开一个终端运行 <code>adb forward tcp:11233 tcp:11233 &amp;&amp; nc 127.0.0.1 11233 | sudo wireshark -k -S -i –</code> 实现将手机抓的包传送到电脑的 Wireshark 中。</li>\n</ul>\n<blockquote>\n<p>你会发现 Wireshark 里面有很多 SSDP 的报文，因为 SSDP 是基于 UDP 协议的，因此只需要输入 TCP 就能过滤掉他。</p>\n<ul>\n<li>Wireshark 常用过滤命令点<a href=\"http://jingyan.baidu.com/article/7f41ececede744593c095c79.html\" target=\"_blank\" rel=\"external\">这里</a>。</li>\n<li>Netcat 命令：<a href=\"https://www.91ri.org/7761.htmlhttps://www.91ri.org/7761.html\" target=\"_blank\" rel=\"external\">https://www.91ri.org/7761.htmlhttps://www.91ri.org/7761.html</a></li>\n</ul>\n</blockquote>\n<h2 id=\"Stetho-实现侵入式抓包\"><a href=\"#Stetho-实现侵入式抓包\" class=\"headerlink\" title=\"Stetho 实现侵入式抓包\"></a>Stetho 实现侵入式抓包</h2><p>前面介绍的几种方法的优点是非侵入式，即不需要修改原应用的代码。方法见：<a href=\"http://stormzhang.com/android/2015/03/05/android-debug-use-chrome/\" target=\"_blank\" rel=\"external\">使用Chrome来调试你的Android App</a>。在开发的时候，Stetho是很好的选择，因为不仅能抓包，还能看到数据库内容。</p>\n<h2 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h2><ul>\n<li><a href=\"http://blog.csdn.net/phunxm/article/details/38590561\" target=\"_blank\" rel=\"external\">MAC 安装 Wireshark</a></li>\n<li><a href=\"http://www.cnblogs.com/xiaowenji/archive/2011/03/12/1982309.html\" target=\"_blank\" rel=\"external\">为 Android 安装 Busybox</a></li>\n<li><a href=\"http://blog.csdn.net/gebitan505/article/details/19044857\" target=\"_blank\" rel=\"external\">Tcpdump + Wireshark 非实时抓包</a></li>\n<li><a href=\"http://tech.uc.cn/?p=2278\" target=\"_blank\" rel=\"external\">Wireshark 实时抓包(TCP,HTTP)</a></li>\n<li><a href=\"http://blog.csdn.net/jiangwei0910410003/article/details/41620363\" target=\"_blank\" rel=\"external\">Charles 实现 HTTP 抓包</a></li>\n</ul>\n","categories":[],"tags":["Android"]},{"title":"DNS基础","url":"http://xiazdong.github.io/2015/06/23/DNS基础/","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>Cracking the code interview 中有一道题：<a href=\"http://www.hawstein.com/posts/17.1.html\" target=\"_blank\" rel=\"external\">当你在浏览器中输入一个URL，并按下 Enter后都发生了什么？</a>，在 Github 上有一个仓库：<a href=\"https://github.com/skyline75489/what-happens-when-zh_CN\" target=\"_blank\" rel=\"external\">what-happens-when-zh_CN</a> 也介绍了在浏览器中输入URL后发生的事情，其中都只是简单地介绍了 DNS 域名解析的过程，但其实域名解析远比这个复杂，因此本文将介绍关于 DNS 的基础知识。</p>\n<p>本文演讲PPT请参见：<a href=\"http://xiazdong.github.io/slides/dns\">xiazdong.github.io/slides/dns</a></p>\n<h2 id=\"DNS-相关介绍\"><a href=\"#DNS-相关介绍\" class=\"headerlink\" title=\"DNS 相关介绍\"></a>DNS 相关介绍</h2><h3 id=\"DNS-基本概念\"><a href=\"#DNS-基本概念\" class=\"headerlink\" title=\"DNS 基本概念\"></a>DNS 基本概念</h3><p>DNS(Domain Name System, 域名系统) 是互联网的基础设施，主要负责域名解析，即负责将域名转换成 IP 地址。1983 年由 Paul Mockapetris 设计出来。</p>\n<p>域名是一个树状结构构成的，如下图，每个域名对应一个或多个 DNS 服务器，域名解析请求也是从上到下一步一步进行下发的。</p>\n<center><br><img src=\"http://i.imgur.com/6qVliAd.gif\" width=\"300px\"><br></center>\n\n<p>下面介绍两个基本概念：</p>\n<ul>\n<li><strong>Zone</strong>: 以上图来说，就是一棵子树。比如”.com”的 Zone 就是以 “.com” 为根的子树。因此 “www.taobao.com” 是在 “.com” 的 Zone 里的。</li>\n<li><strong>Domain</strong>: 树中的一条路径。比如 “taobao.com.” 是 Domain，”www.taobao.com.” 也是 Domain。</li>\n</ul>\n<p>从上图可知，域名(Domain)分成很多类：</p>\n<ul>\n<li><strong>根域名(Root Domain)</strong>: 是树状结构的根，在 URL 中对应的是：”.”。全世界一共有13个根域名服务器(每个服务器都是一个集群，通过 Anycast 技术共用一个 IP)，这13个根域名服务器的名字分别是 <code>[A-M].root-servers.net</code>，根域名服务器的分布图如下：</li>\n</ul>\n<center><br><img src=\"http://i.imgur.com/1eXmBYw.png\" width=\"600px\"><br></center>\n\n<ul>\n<li><strong>顶级域名(Top Level Domain, TLD)</strong>: 根域名的下一层，URL 中对应例如：”.com”,”.cn”,”.net”。TLD 分成两类：<ul>\n<li>gTLD(generic TLD, 国际顶级域名): 比如 <code>.com</code>, <code>.net</code>。</li>\n<li>ccTLD(Country Code TLD, 国家和地区顶级域名): 比如 <code>.cn</code>, <code>.jp</code>。</li>\n</ul>\n</li>\n<li><strong>二级域名(Second Level Domain)</strong>：这层就是一般我们用钱去 Godaddy 买的域名，比如”taobao.com”。</li>\n<li>三级、四级域名…</li>\n</ul>\n<p>URL 就是一个由”.”分隔的字符串，总长度必须小于等于255字节，每个分隔的子串必须小于等于63字节。其实完整的每个URL都是以”.”结尾的，比如”www.taobao.com.”，只是现在大家默认都会省去这个点。</p>\n<p>为了完成域名解析，不得不介绍一下 Local DNS。</p>\n<ul>\n<li>一般上网我们都是设置为 DHCP(Dynamic Host Configuration Protocol)的，Local DNS 是你连上网之后，由网络服务提供商(ISP, Internet Service Provider, 比如移动、连通、电信)自动就近分配(地理位置尽量近以加快域名解析的速度)给计算机的(一般会分配两个，一个主DNS，一个备用DNS)，因此 Local DNS 是由 ISP 自己维护的， ISP 还会为计算机分配 IP。如果你想自己设置 DNS 也是可以的(可以是公共 DNS，比如 <a href=\"http://www.alidns.com/\" target=\"_blank\" rel=\"external\">AliDNS</a> 或 Google 的 <code>8.8.8.8</code>)，这样计算机就不使用 Local DNS 了。</li>\n<li>因为 Root DNS 的13个 IP 都是公开的，因此一般 Local DNS 会以静态文件的形式内置这13个 Root DNS 的 IP。</li>\n</ul>\n<p>Local DNS 是负责帮你完成域名解析的大功臣，你只需要把 DNS 域名解析的报文请求发送给 Local DNS，它会以递归的方式帮你完成一系列的请求解析(因为要不断请求不同层级的 DNS，先从根 DNS 开始，再到 TLD，…)，并最终返回给你域名的 IP。 Local DNS 执行流程如下图：</p>\n<center><br><img src=\"http://i.imgur.com/WdAkAaV.png\" width=\"500px\"><br></center><br>&gt; - 内网 IP: 这是局域网内部的IP地址，输入 <code>ipconfig</code> 看到的是内网IP，比如 “192.168.0.103”。<br>&gt; - 公网 IP: 这是运营商分配的IP地址，这个地址并不是你电脑独占的，比如我在家里电脑和手机连的是同一个网，那么他们共享同一个公网 IP。在百度里输入 IP，就能看到自己的外网 IP。<br><br>查看公网 IP 和 Local DNS 的 IP 的简便方法是访问：阿里的<a href=\"http://tool.alikunlun.com/doc.html\" target=\"_blank\" rel=\"external\">昆仑镜</a>或者腾讯的<a href=\"http://utp.qq.com/\" target=\"_blank\" rel=\"external\">华佗</a>。<br><br>&gt; 如果要自己搭一个 DNS 服务器，一般使用 BIND(Berkeley Internet Name Domain)。<br><br>### DNS 分类<br><br>- <strong>递归 DNS</strong>：负责接收域名解析请求，并帮助用户一次又一次递归地请求不同的 DNS 服务器，最后得到 IP 并返回给用户。比如 Local DNS, 公共 DNS。<br>- <strong>权威 DNS</strong>：保存某个域 DNS 解析的权威信息，怎么解析他说了算。 至于哪个 DNS 服务器是权威 DNS，则在上一级的 Zone File 中通过 NS 记录设置。比如为了让 DNSPod 的 “f1g1ns1.dnspod.net”和” f1g1ns2.dnspod.net” 作为 “xiazdong.me” 的权威 DNS，必须要到 Godaddy 中设置 Nameserver(即设置 NS 记录：<code>xiazdong.me NS f1g1ns1.dnspod.net</code>)，表明现在 “xiazdong.me” 有两个权威 DNS 服务器。<br><br>&gt; 一个 DNS 既可以作为递归 DNS，也可以同时作为权威 DNS，即当 DNS 请求该 DNS 负责的域名时，则进行解析；当 DNS 请求不是他负责的域名时，则作为递归 DNS 使用。<br><br>### DNS 攻击<br><br>- <strong>DNS 劫持(DNS Hijacking or DNS redirection)</strong>：攻击的人会 劫持 DNS 服务器，并获得管理权限，从而修改映射关系。常见的 DNS 劫持是 DNS 广告劫持，现象是比如你访问”www.taobao.com”，会在页面上弹出一个不相关广告，这是运营商干的，Local DNS 是 ISP 管理的，当你发一个 DNS 域名请求到 Local DNS，他会将 DNS 响应报文中的 IP 改成自己搭的广告服务器的IP，他预先会写一个静态页面在广告服务器，其中 <code>&lt;iframe&gt;</code> 依旧请求原页面，但是区别是多加一些代码用来弹广告。这个解决方法就是投诉。<br>- <strong>DNS 污染(DNS cache poisoning)</strong>：DNS 服务器的缓存映射被篡改。假设 Root DNS 被污染，那么如果用户请求 “www.taobao.com”，Root DNS 直接返回一个假 IP，让用户访问不了淘宝。如果 Root DNS 都被污染了，那就无解了。因此 DNS 劫持是对 DNS 服务器本身做修改，而 DNS 污染是对 DNS 服务器缓存做修改。<br>- <strong>DDOS(Distributed Deny Of Service, 分布式拒绝服务)</strong>： 搞一堆肉机，制造大量 DNS 解析请求，大量提升 QPS，导致 DNS 服务器的带宽被塞满，无法为其他用户提供服务。一些常见的解决方法是：黑名单(不对黑名单中 IP 提供 DNS 解析请求服务)、白名单(只对白名单中的 IP 提供 DNS 解析请求服务)。<br><br>### DNS Zone File<br><br>DNS Zone File(DNS 区域文件)是每个 DNS 服务器都需要有的一个文本文件，用来进行域名解析。一般格式如下：<br><br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">$ORIGIN example.com.     ; designates the start of this zone file in the namespace</div><div class=\"line\">$TTL 1h                  ; default expiration time of all resource records without their own TTL value</div><div class=\"line\">example.com.  IN  SOA   ns.example.com. username.example.com. ( 2007120710 1d 2h 4w 1h )</div><div class=\"line\">example.com.  IN  NS    ns                    ; ns.example.com is a nameserver for example.com</div><div class=\"line\">example.com.  IN  NS    ns.somewhere.example. ; ns.somewhere.example is a backup nameserver for example.com</div><div class=\"line\">example.com.  IN  MX    10 mail.example.com.  ; mail.example.com is the mailserver for example.com</div><div class=\"line\">@             IN  MX    20 mail2.example.com. ; equivalent to above line, &quot;@&quot; represents zone origin</div><div class=\"line\">@             IN  MX    50 mail3              ; equivalent to above line, but using a relative host name</div><div class=\"line\">example.com.  IN  A     192.0.2.1             ; IPv4 address for example.com</div><div class=\"line\">\t      IN  AAAA  2001:db8:10::1        ; IPv6 address for example.com</div><div class=\"line\">ns            IN  A     192.0.2.2             ; IPv4 address for ns.example.com</div><div class=\"line\">\t      IN  AAAA  2001:db8:10::2        ; IPv6 address for ns.example.com</div><div class=\"line\">www           IN  CNAME example.com.          ; www.example.com is an alias for example.com</div><div class=\"line\">wwwtest       IN  CNAME www                   ; wwwtest.example.com is another alias for www.example.com</div><div class=\"line\">mail          IN  A     192.0.2.3             ; IPv4 address for mail.example.com</div><div class=\"line\">mail2         IN  A     192.0.2.4             ; IPv4 address for mail2.example.com</div><div class=\"line\">mail3         IN  A     192.0.2.5             ; IPv4 address for mail3.example.com</div></pre></td></tr></table></figure><br><br>解释如下：<br><br>- 文件中每行都是一个资源记录(Resource Record,RR)，资源记录有很多类型，比如 SOA(Start Of Authority), A(Address), NS(Name Server), MX(Mail eXchange), CNAME(别名，一般出于调度考虑)。<br>- <code>$ORIGIN example.com.</code>: 这个 Zone File 的 DNS 的域是 “example.com.”<br>- <code>$TTL 1h</code>: 该文件的记录的最大存活时间是1小时。<br>- <code>example.com.  IN  SOA   ns.example.com. username.example.com.</code>: “example.com.” 的首选 DNS 服务器是 “ns.example.com.”，管理员邮箱是”username@example.com.”。<br>- <code>example.com.  IN  NS ns</code>: “ns.example.com.” 是 “example.com” 的 Nameserver。<br>- <code>example.com.  IN  NS ns.somewhere.example.</code>: “ns.somewhere.example.” 是 “example.com” 的另一个 Nameserver。<br>- <code>example.com.  IN  MX 10 mail.example.com.</code>: “mail.example.com.” 是 “example.com.” 的邮件服务器，优先级是10(优先级数字越小，则优先级越高)。MX 表示 Mail eXchange。<br>- <code>@ IN  MX    20 mail2.example.com.</code>: 也是设置邮件服务器，优先级是20。<br>- <code>@ IN  MX    50 mail3</code>: “mail3.example.com.” 是 “example.com” 的邮件服务器，优先级是50。<br>- <code>example.com.  IN  A     192.0.2.1</code>: “example.com” 的 IPv4 地址是 “192.0.2.1”。<br>- <code>IN  AAAA  2001:db8:10::1</code>: “example.com” 的IPv6 地址是 “2001:db8:10::1”。<br>- <code>ns IN  A     192.0.2.2</code>: “ns.example.com.” 的 IPv4 地址是 “192.0.2.2”。<br>- <code>www IN  CNAME example.com.</code>: “www.example.com.” 是 “example.com” 的别名。<br>- <code>wwwtest IN CNAME www</code>: “wwwtest.example.com.” 是 “www.example.com.” 的别名。<br>- <code>mail IN  A 192.0.2.3</code>: “mail.example.com” 的 IPv4 地址是 “192.0.2.3”。<br>- <code>mail2 IN  A 192.0.2.4</code>: “mail2.example.com” 的 IPv4 地址是 “192.0.2.4”。<br>- <code>mail3 IN  A 192.0.2.5</code>: “mail3.example.com” 的 IPv4 地址是 “192.0.2.5”。<br><br>那么 CNAME 能不能被 A 替代呢？答案是不能，主要是看需求。因为：<br><br>- 定义不同: A 记录对应的是 IP，CNAME 对应的是 URL，他只是域名解析的中间结果，因此 CNAME 引入了中间态。<br>- 应用场景不同: 如果我想把某个域名指向 google.com，而 google.com 有很多 IP 地址，而且可能随时会更换，因此最好的方式是通过 CNAME 指向 google.com，而不是用 A 记录指向 google.com 对应的一个 IP 地址。<br><br>一般来说，一个域名的 DNS 服务器会有很多台，会以 Master-Slave 的形式部署，而每台 Master 或 Slave 都会有 Zone File，Slave 会通过 AXFR(全量传输), IXFR(增量传输) 或 Notify 的方式同步 Master 的 Zone File。如下图：<br><br><center><br><img src=\"http://i.imgur.com/4lR3zJu.png\" width=\"600px\"><br></center>\n\n<p>从上面这张图看出：Remote Admin 是 DNSPod 提供的操作界面，当你修改了记录后，他会同步到 Master 的 Zone File 中，并通知 Slave 更新。</p>\n<p>DNSPod 的权威 DNS 是”f1g1ns1.dnspod.net”和” f1g1ns2.dnspod.net”，我的博客”xiazdong.me”的权威 DNS 设置成了这两个 URL，为了让这个权威 DNS 生效，我需要去申请域名的平台(Godaddy)将 DNS NameServer 设置为这两个 URL，这样才能够生效，一般来说 Master DNS 服务器和 Slave DNS 服务器都是权威 DNS。如果你在 DNSPod 平台上修改 A 记录，那么会把修改同步到 Master DNS 服务器，Slave 再通过某种方式同步 Master 的 Zone File。</p>\n<h2 id=\"域名解析全过程\"><a href=\"#域名解析全过程\" class=\"headerlink\" title=\"域名解析全过程\"></a>域名解析全过程</h2><p>比如你在 Chrome 中输入 “www.taobao.com”，并按下回车，域名解析会进行如下步骤：</p>\n<ol>\n<li>查看浏览器 DNS 缓存。Chrome 可以通过 <code>chrome://net-internals/#dns</code> 查看浏览器的 DNS 缓存，一般这些缓存的 TTL(Time To Live) 是几分钟。</li>\n<li>查看系统 DNS 缓存。 Windows 可以通过 <code>ipconfig /displaydns</code> 查看系统 DNS 缓存。这里面包含了 hosts 文件设置的映射，有时候修改了 hosts 文件后，为了让 hosts 文件生效，需要执行 <code>ipconfig /flushdns</code>。</li>\n<li>查看路由器 DNS 缓存。</li>\n<li>查看 Local DNS 的 DNS 缓存。这部分缓存是由 ISP 自己实现，有些 ISP 为了减少域名解析次数，会将缓存的 TTL 特意变长一点，比如原来  TTL=10min，但是 ISP 自己实现的时候，设置缓存的时间是30min。这也会导致你更改了 DNS 服务器的 A 记录后不能马上生效的原因。</li>\n<li>如果这些缓存都没有域名对应的IP，那么 Local DNS 会帮你递归地开始进行域名解析。<ul>\n<li>因为在 Local DNS 中内置了 13个 Root DNS 的 IP，因此任意选择一个 Root DNS 的 IP 发起 DNS 解析请求报文，当 Root DNS 收到 Local DNS 的请求后，会发现这个 URL 的顶级域名是 “.com”，因此他会把 “.com” 的 DNS 服务器的 IP(通常会发13个 “.com” 的服务器的 IP)发送给 Local DNS 作为响应。</li>\n<li>Local DNS 收到 Root DNS 的响应后，会继续把请求发送给 “.com” 的 DNS 服务器(它的 IP 从 Root DNS 的响应中获得)，”.com” 的 DNS 服务器收到请求后，会发现这个 URL 的二级域名是 “taobao.com”，因此会把 “taobao.com” 的 DNS 服务器的 IP(通常也会有多个)发送给 Local DNS 作为响应。</li>\n<li>Local DNS 收到 “.com” DNS 的响应后，会继续把请求发送给 “.taobao.com” 的 DNS 服务器(它的 IP 从 “.com” DNS 的响应中获得)，”taobao.com” 的 DNS 服务器收到请求后，会发现这个 URL 的子域名是 “www.taobao.com”，那么会把 “www.taobao.com” 的 DNS 服务器的 IP 发送给 Local DNS 作为响应。当然这里可能会有一个问题，因为”www.taobao.com”会有多个IP对应，那么到底返回哪个IP呢？一般 DNS 会有调度原则，实现方法是：DNS 服务器会内置一个 IP 库，会根据请求源的 IP(Local DNS 的 IP) 确定他的国家、地区、运营商，因此会返回就近的 IP，这就实现了就近调度。一般 CDN(Content Delivery Network, 内容分发网络, 主要存储静态文件如 CSS, JS)的实现原理就是这样。</li>\n<li>Local DNS 收到了 “www.taobao.com” 的 IP，也就完成了任务，他会把这个 IP 送回给计算机。</li>\n</ul>\n</li>\n</ol>\n<blockquote>\n<ul>\n<li>域名请求和响应是以 UDP 协议发送的。</li>\n<li>RTT(Round Trip Time): 一次请求+响应的时间。</li>\n<li>TTL(Time To Live): 当 DNS 服务器返回 IP 时，会带有 TTL，表示这个映射你能缓存的时间，比如 TTL=10min，那么这个映射关系只能缓存10分钟，10分钟之后就过期了。但是 ISP 的 Local DNS 可能并不会那么听话，他可能会缓存半个小时。</li>\n</ul>\n</blockquote>\n<p>在无线端的域名解析，需要提几点：</p>\n<ul>\n<li>在开发移动应用时，为了节省域名解析的时间，采用”<strong>IP直连</strong>“的方式，即在应用中内置可能会用到的域名的 IP(比如手机淘宝可能会访问的域名其实都是可预料的)，这样就省去了域名解析的时间(一般解析时间在200ms-400ms)。</li>\n<li>由于 Local DNS 运维水平参差不齐，可能会出现 DNS 劫持、ISP 分配给用户的 Local DNS 不在一个地区，又因为一个应用可能会访问的域名是固定的，因此大公司都会自己实现一套异步的 DNS 解析，比如腾讯的 HttpDNS。</li>\n</ul>\n<p>HttpDNS 的实现思路是：</p>\n<ul>\n<li>开辟一个线程，从应用启动后定期地发起 HttpDNS 的域名解析请求(同时可以请求解析多个域名)到 HttpDNS 服务器(定期发起请求是因为怕 IP 过期)，该请求走 HTTP 协议，然后 HttpDNS 服务器把 HTTP 请求转换成 DNS 请求，并对后端的 DNS 服务器进行 DNS 域名解析请求，当解析完成后，会将请求域名的 IP 地址送回给客户端，并缓存起来。</li>\n<li>当应用发起网络请求，会首先看 HttpDNS 的缓存中是不是存在已经解析好的 IP 地址，如果有，则直接拿来用(这里可能会出现 IP 过期，也需要降级走 Local DNS)；如果没有，则降级走 Local DNS。</li>\n</ul>\n<h2 id=\"dig-命令\"><a href=\"#dig-命令\" class=\"headerlink\" title=\"dig 命令\"></a>dig 命令</h2><p>上一节已经介绍了 DNS 域名解析的基本流程，本节我们通过 Linux 中的 dig(Domain Information Groper) 命令来验证这个解析流程。以 <code>dig +trace www.taobao.com</code> 为例。</p>\n<p>输出如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">; &lt;&lt;&gt;&gt; DiG 9.8.3-P1 &lt;&lt;&gt;&gt; +trace taobao.com</div><div class=\"line\">;; global options: +cmd</div><div class=\"line\">.\t\t\t84725\tIN\tNS\tl.root-servers.net.</div><div class=\"line\">.\t\t\t84725\tIN\tNS\tj.root-servers.net.</div><div class=\"line\">.\t\t\t84725\tIN\tNS\tc.root-servers.net.</div><div class=\"line\">.\t\t\t84725\tIN\tNS\tf.root-servers.net.</div><div class=\"line\">.\t\t\t84725\tIN\tNS\ti.root-servers.net.</div><div class=\"line\">.\t\t\t84725\tIN\tNS\tk.root-servers.net.</div><div class=\"line\">.\t\t\t84725\tIN\tNS\th.root-servers.net.</div><div class=\"line\">.\t\t\t84725\tIN\tNS\te.root-servers.net.</div><div class=\"line\">.\t\t\t84725\tIN\tNS\tm.root-servers.net.</div><div class=\"line\">.\t\t\t84725\tIN\tNS\ta.root-servers.net.</div><div class=\"line\">.\t\t\t84725\tIN\tNS\tg.root-servers.net.</div><div class=\"line\">.\t\t\t84725\tIN\tNS\tb.root-servers.net.</div><div class=\"line\">.\t\t\t84725\tIN\tNS\td.root-servers.net.</div><div class=\"line\">;; Received 505 bytes from 10.65.0.1#53(10.65.0.1) in 159 ms</div><div class=\"line\">;上面这些数据是从 /etc/resolv.conf 中指定的 DNS 服务器获得的13个根域名服务器的 IP 地址和名称。</div><div class=\"line\"></div><div class=\"line\">com.\t\t\t172800\tIN\tNS\ta.gtld-servers.net.</div><div class=\"line\">com.\t\t\t172800\tIN\tNS\tb.gtld-servers.net.</div><div class=\"line\">com.\t\t\t172800\tIN\tNS\tc.gtld-servers.net.</div><div class=\"line\">com.\t\t\t172800\tIN\tNS\td.gtld-servers.net.</div><div class=\"line\">com.\t\t\t172800\tIN\tNS\te.gtld-servers.net.</div><div class=\"line\">com.\t\t\t172800\tIN\tNS\tf.gtld-servers.net.</div><div class=\"line\">com.\t\t\t172800\tIN\tNS\tg.gtld-servers.net.</div><div class=\"line\">com.\t\t\t172800\tIN\tNS\th.gtld-servers.net.</div><div class=\"line\">com.\t\t\t172800\tIN\tNS\ti.gtld-servers.net.</div><div class=\"line\">com.\t\t\t172800\tIN\tNS\tj.gtld-servers.net.</div><div class=\"line\">com.\t\t\t172800\tIN\tNS\tk.gtld-servers.net.</div><div class=\"line\">com.\t\t\t172800\tIN\tNS\tl.gtld-servers.net.</div><div class=\"line\">com.\t\t\t172800\tIN\tNS\tm.gtld-servers.net.</div><div class=\"line\">;; Received 488 bytes from 128.63.2.53#53(128.63.2.53) in 275 ms </div><div class=\"line\">;上面这些数据是从13个根域名服务器的其中一个(IP 地址 128.63.2.53)获得 &quot;.com&quot; 的 DNS 服务器的 IP 地址和名称。</div><div class=\"line\"></div><div class=\"line\">taobao.com.\t\t172800\tIN\tNS\tns4.taobao.com.</div><div class=\"line\">taobao.com.\t\t172800\tIN\tNS\tns5.taobao.com.</div><div class=\"line\">taobao.com.\t\t172800\tIN\tNS\tns6.taobao.com.</div><div class=\"line\">taobao.com.\t\t172800\tIN\tNS\tns7.taobao.com.</div><div class=\"line\">;; Received 180 bytes from 192.26.92.30#53(192.26.92.30) in 279 ms</div><div class=\"line\">;上面这些数据是从13个&quot;.com&quot; DNS 服务器的其中一个(IP 地址 192.26.92.30)获得 &quot;taobao.com&quot; 的 DNS 服务器的 IP 地址和名称。</div><div class=\"line\"></div><div class=\"line\">taobao.com.\t\t1800\tIN\tA\t110.75.115.70</div><div class=\"line\">taobao.com.\t\t10800\tIN\tNS\tns7.taobao.com.</div><div class=\"line\">taobao.com.\t\t10800\tIN\tNS\tns5.taobao.com.</div><div class=\"line\">taobao.com.\t\t10800\tIN\tNS\tns4.taobao.com.</div><div class=\"line\">taobao.com.\t\t10800\tIN\tNS\tns6.taobao.com.</div><div class=\"line\">;; Received 196 bytes from 110.75.38.29#53(110.75.38.29) in 3 ms</div><div class=\"line\">;上面这些数据是从4个&quot;taobao.com&quot;的 DNS 服务器的其中一个(IP 地址为 110.75.38.29)获得 &quot;taobao.com&quot; 的 IP 地址：110.75.115.70。</div></pre></td></tr></table></figure>\n<h2 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h2><ul>\n<li><a href=\"http://segmentfault.com/a/1190000002662495\" target=\"_blank\" rel=\"external\">程序员DNS知识指南</a></li>\n<li><a href=\"http://blog.chinaunix.net/uid-28216282-id-3757849.html\" target=\"_blank\" rel=\"external\">DNS解析过程详解</a></li>\n<li><a href=\"http://www.cnblogs.com/cyq1162/archive/2012/11/26/2789424.html\" target=\"_blank\" rel=\"external\">简说宽带商的弹窗广告进化及网站应对之策</a></li>\n</ul>\n","categories":[],"tags":["网络"]},{"title":"什么是缓存的后台进程？","url":"http://xiazdong.github.io/2015/03/12/缓存后台进程/","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p><img src=\"http://i.imgur.com/rKmt3cQ.png\" width=\"200px\"></p>\n<p>在应用管理这个界面里面发现有<strong>已缓存</strong>这一项，里面写了”缓存的后台进程”，英文为 Cached Background Process。</p>\n<p>这个词由 <code>Cached</code> 和 <code>Background Process</code> 组成，因此本文就这两个方面进行解释。</p>\n<p>参考：<a href=\"http://stackoverflow.com/questions/14259504/on-android-whats-the-difference-between-running-processes-and-cached-backgroun\" target=\"_blank\" rel=\"external\">StackOverflow</a></p>\n<h2 id=\"Background-Process\"><a href=\"#Background-Process\" class=\"headerlink\" title=\"Background Process\"></a>Background Process</h2><p>Android 对进程划分了5个等级：</p>\n<ol>\n<li>Foreground Process: 用户看得见，且能与用户交互的进程。</li>\n<li>Visible Process: 用户看得见的进程，可以是没有完全隐藏的。</li>\n<li>Service Process: Started 的服务。</li>\n<li>Background Process: 不可见的进程。</li>\n<li>Empty Process: 不包含任何组件的进程。</li>\n</ol>\n<p>等级越高越容易被回收。很显然后台进程属于等级4，是非常容易被系统回收的。</p>\n<h2 id=\"Cached\"><a href=\"#Cached\" class=\"headerlink\" title=\"Cached\"></a>Cached</h2><blockquote>\n<p>为了更充分地利用 CPU，操作系统会在内存中放置多个进程，这种技术叫 Multiprogramming。</p>\n</blockquote>\n<p>Cached Background Process 的特征是：这个后台进程没有前台界面显示，并且没有服务在运行。<br>Cached Background Process 目前在内存中因为内存很充裕，这样做是为了：当用户再次打开该应用时，能更快地打开。如果系统发现内存不够用了，就很容易将踢出内存。</p>\n<p>总的来说，Cached Background Process 和 Running Process 的区别在于：虽然他们都在内存中，但是 Running Process 是需要消耗 CPU 的(至少一个服务还在运行)，而 Cached Background Process 是不需要消耗 CPU 的。我们可以从下图中看出 Running Process 都是带着服务的：</p>\n<p><img src=\"http://i.imgur.com/hih5BAq.png\" width=\"200px\"></p>\n","categories":[],"tags":["Android"]},{"title":"观察者模式","url":"http://xiazdong.github.io/2015/03/11/观察者模式/","content":"<h2 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h2><ul>\n<li>定义：观察者模式定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态发生变化时，会通知所有观察者对象，使它们能够自动更新自己。</li>\n<li>UML 图：如下。</li>\n</ul>\n<p><img src=\"http://i.imgur.com/gpmJ9sB.png\" alt=\"\"></p>\n<p>从上图看出：</p>\n<ul>\n<li>在主题对象(Subject)中存在一个观察者集合 observerCollection。</li>\n<li>通过 <code>registerObserver(observer)</code> 将 observer 注册到 Subject；通过 <code>unregisterObserver(observer)</code> 取消注册。</li>\n<li>主题对象有一个 <code>notifyObservers()</code> 方法，当 Subject 对象状态发生变化时，就会主动调用该方法，通知注册在该对象的所有观察者调用 <code>notify()</code>。</li>\n</ul>\n<p>因此可以看出：一个观察者可以注册到多个主体对象中，一个主体对象也可以有多个观察者。</p>\n<p>实际应用：你在门上装了一个防盗装置，当门关的时候就开始监听门的状态(注册了一个观察者)，当门打开时就发出警报(调用了 <code>notify()</code>)。</p>\n<h2 id=\"Android-中的应用：ListView\"><a href=\"#Android-中的应用：ListView\" class=\"headerlink\" title=\"Android 中的应用：ListView\"></a>Android 中的应用：ListView</h2><p>在 ListView 中我们会调用 <code>setAdapter(adapter)</code> 设置 ListView 的具体内容，但是实际上这个方法中还新建了一个观察者，并注册在 adapter 上：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">mDataSetObserver = <span class=\"keyword\">new</span> AdapterDataSetObserver();</div><div class=\"line\">mAdapter.registerDataSetObserver(mDataSetObserver);</div></pre></td></tr></table></figure>\n<p>因此一个 ListView 中就有一个 AdapterDataSetObserver。当 adapter 内容发生改变时，开发者会调用 <code>adapter.notifyDataSetChanged()</code> ，这个方法的内部实现就是通知注册在 adapter 上的所有观察者调自己的 <code>onChanged()</code> 方法。</p>\n","categories":[],"tags":["设计模式"]},{"title":"策略模式","url":"http://xiazdong.github.io/2015/03/09/策略模式/","content":"<h2 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h2><ul>\n<li>定义：将可变的部分从程序中抽离出来变成算法接口(即策略接口)，在该接口下分别封装了一系列算法实现(每个算法实现都是一个实现策略接口的具体类)。</li>\n<li>UML 图：如下。</li>\n</ul>\n<p><img src=\"http://i.imgur.com/O8v93Nj.jpg\" alt=\"\"></p>\n<ul>\n<li>应用场景：上面的 UML 图就是策略模式很典型的应用场景：支付场景。当你在网上购物，并进入支付界面，系统会列出一堆可用的支付方式：招商银行、工商银行、支付宝等方式。因此这里 PaymentMethod 接口表示支付策略；Visa, Paypal, MobilePayment 类就是具体的支付策略；你只需要通过在客户端预留 <code>setPaymentMethod(PaymentMethod m)</code> 方法并且在该方法中设置 <code>PaymentMethod paymentMethod</code> 的成员变量为某个支付策略，这样就只需要调用 <code>paymentMethod.pay(money)</code> 即可完成支付。实现代码如下：</li>\n</ul>\n<p>IPaymentMethod.java</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">IPaymentMethod</span> </span>&#123;</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">pay</span><span class=\"params\">(<span class=\"keyword\">double</span> money)</span></span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>Visa.java</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Visa</span> <span class=\"keyword\">implements</span> <span class=\"title\">IPaymentMethod</span></span>&#123;</div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">pay</span><span class=\"params\">(<span class=\"keyword\">double</span> money)</span> </span>&#123;</div><div class=\"line\">        System.out.println(<span class=\"string\">\"Visa:\"</span> + money);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\">`</div></pre></td></tr></table></figure>\n<p>PayPal.java</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">public class PayPal implements IPaymentMethod &#123;</div><div class=\"line\">    @Override</div><div class=\"line\">    public void pay(double money) &#123;</div><div class=\"line\">        System.out.println(&quot;PayPal:&quot; + money);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>MobilePayment.java</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MobilePayment</span> <span class=\"keyword\">implements</span> <span class=\"title\">IPaymentMethod</span> </span>&#123;</div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">pay</span><span class=\"params\">(<span class=\"keyword\">double</span> money)</span> </span>&#123;</div><div class=\"line\">        System.out.println(<span class=\"string\">\"MobilePayment:\"</span> + money);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>Client.java</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Client</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">private</span> IPaymentMethod mPaymentMethod;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setPaymentMethod</span><span class=\"params\">(IPaymentMethod paymentMethod)</span></span>&#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.mPaymentMethod = paymentMethod;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">pay</span><span class=\"params\">(<span class=\"keyword\">double</span> money)</span></span>&#123;</div><div class=\"line\">        mPaymentMethod.pay(money);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String args[])</span></span>&#123;</div><div class=\"line\">        Client client = <span class=\"keyword\">new</span> Client();</div><div class=\"line\">        IPaymentMethod m = <span class=\"keyword\">new</span> Visa();</div><div class=\"line\">        client.setPaymentMethod(m);</div><div class=\"line\">        client.pay(<span class=\"number\">100</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"Android-中的应用：setAdapter\"><a href=\"#Android-中的应用：setAdapter\" class=\"headerlink\" title=\"Android 中的应用：setAdapter()\"></a>Android 中的应用：setAdapter()</h2><p>策略模式其实在 Android 中很常见，最明显的就是 ListView 中的适配器(Adapter)策略。类图如下：</p>\n<p><img src=\"http://i.imgur.com/Ue0OJ8m.png\" alt=\"\"></p>\n<p>通过将上图与文章最前面的图相比，可以看出：</p>\n<ul>\n<li>ListView 就是 Client。</li>\n<li>ListAdapter 接口是策略接口；BaseAdapter, HeaderViewListAdapter 是具体的策略。</li>\n</ul>\n","categories":[],"tags":["设计模式"]},{"title":"Activity LaunchMode 应用场景","url":"http://xiazdong.github.io/2015/03/08/android-launchmode/","content":"<p>Standard 就不说了，因为一般都是使用这种模式。</p>\n<h2 id=\"SingleTop\"><a href=\"#SingleTop\" class=\"headerlink\" title=\"SingleTop\"></a>SingleTop</h2><ul>\n<li>应用场景：网易新闻。</li>\n<li>假设主界面为 MainActivity，显示新闻的界面是 DetailActivity，显然显示任何一条新闻都会使用 DetailActivity，即把新闻内容通过 Intent 传给 DetailActivity 就可以了。</li>\n<li>假设你正在看新闻1(即在 DetailActivity)，此时手机收到服务器的推送：收到一条通知(新闻2)，点击通知就会跳转到 DetailActivity 并显示新闻2，当你点击通知时，因为目前栈顶的 Activity 就是 DetailActivity，因此这里就是使用 SingleTop 的地方，即点击通知后以 SingleTop 加载模式打开 DetailActivity 并显示新闻2，因此新闻1的 DetailActivity 就被覆盖掉了。</li>\n<li>此后你点击返回键会回到主界面。</li>\n</ul>\n<h2 id=\"SingleTask\"><a href=\"#SingleTask\" class=\"headerlink\" title=\"SingleTask\"></a>SingleTask</h2><ul>\n<li>应用场景：微信的主界面(一般应用主界面都会以 SingleTask 启动)。</li>\n<li>你打开微信主界面(在栈的最底部)后，进入朋友圈(在栈的顶部)，此时你点击 Home 键回桌面，并打开网易新闻。</li>\n<li>假设你想将网易新闻的一条新闻分享给微信好友，那么就按照 <code>分享</code>-&gt;<code>微信</code>-&gt;<code>好友A</code>-&gt;<code>分享给他</code>-&gt;<code>留在微信</code>。接着会跳转微信的主界面，即不是你原本所在的朋友圈，并且微信的栈只剩下一个元素：主界面的 Activity。这里就使用了 SingleTask(即以 SingleTask 加载模式打开微信主界面)。</li>\n</ul>\n<h2 id=\"SingleInstance\"><a href=\"#SingleInstance\" class=\"headerlink\" title=\"SingleInstance\"></a>SingleInstance</h2><ul>\n<li>应用场景：闹铃的响铃界面。</li>\n<li>你以前设置了一个闹铃：上午6点。在上午5点58分，你启动了闹铃设置界面，并按 Home 键回桌面；在上午5点59分时，你在微信和朋友聊天；在6点时，闹铃响了，并且弹出了一个对话框形式的 Activity(名为 AlarmAlertActivity) 提示你到6点了(这个 Activity 就是以 SingleInstance 加载模式打开的)，你按返回键，回到的是微信的聊天界面，这是因为 AlarmAlertActivity 所在的 Task 的栈只有他一个元素，因此退出之后这个 Task 的栈空了。如果是以 SingleTask 打开 AlarmAlertActivity，那么当闹铃响了的时候，按返回键应该进入闹铃设置界面。</li>\n</ul>\n","categories":[],"tags":["Android"]},{"title":"虚拟机类加载机制","url":"http://xiazdong.github.io/2014/12/31/虚拟机类加载机制/","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><blockquote>\n<p>本文内容大多来自《深入理解Java虚拟机》，但是经过整理，语言更加简练。</p>\n</blockquote>\n<p>虚拟机的类加载机制是一个与Java程序员息息相关的知识点，因为我们写的程序都是由类构成的(一个一个class文件)，这些类都会被放进JVM中。那么介绍虚拟机的类加载机制就是为了让你了解一个class文件被放入JVM的整个过程。</p>\n<p>本文主要介绍两个知识点：</p>\n<ol>\n<li><strong>虚拟机类加载机制</strong>：类的生命周期。</li>\n<li><strong>双亲委派模型</strong>：越基础的类交给越上层的类加载器加载。</li>\n</ol>\n<h2 id=\"一个例子\"><a href=\"#一个例子\" class=\"headerlink\" title=\"一个例子\"></a>一个例子</h2><p>可能有Java程序员觉得：这么底层的知识了解了干啥？！安心写应用不就好了！我却觉得：在一般的应用开发中确实用不到这部分知识点，但是这却是Java程序员需要知道的基础理论，他帮助你更加了解你每天在写的Java程序的内部运作过程。</p>\n<p>这里我给出一个例子：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span> </span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">static</span>&#123;</div><div class=\"line\">\t\tSystem.out.print(<span class=\"string\">\"1 \"</span>);</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span> </span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">static</span> A instance = <span class=\"keyword\">new</span> A();</div><div class=\"line\">\t\t<span class=\"keyword\">static</span> &#123;</div><div class=\"line\">\t\t\tSystem.out.print(<span class=\"string\">\"5 \"</span>);</div><div class=\"line\">\t\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">B</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t\t\tSystem.out.print(<span class=\"string\">\"-1 \"</span>);</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">A</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t\tSystem.out.print(<span class=\"string\">\"4 \"</span>);</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> A <span class=\"title\">getInstance</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t\tSystem.out.print(<span class=\"string\">\"3 \"</span>);</div><div class=\"line\">\t\t<span class=\"keyword\">return</span> B.instance;</div><div class=\"line\"></div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"keyword\">static</span> &#123;</div><div class=\"line\">\t\tSystem.out.print(<span class=\"string\">\"2 \"</span>);</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</div><div class=\"line\">\t\tA t1 = A.getInstance();</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>输出结果是：<code>1 2 3 4 5</code>。</p>\n<p>这个例子经常在笔试面试场合遇到(一般写程序不可能写成这样，太BT了…)，这个例子如果给一个不懂JVM的程序员看，他一定不知道答案(除非死记硬背)，但是如果了解了JVM的类加载机制，那么 So Easy! </p>\n<h2 id=\"类加载机制\"><a href=\"#类加载机制\" class=\"headerlink\" title=\"类加载机制\"></a>类加载机制</h2><p>虚拟机的类加载机制分为7个阶段：</p>\n<ol>\n<li><strong>加载</strong>：<em>程序员不可见</em>。将一个类的二进制字节流加载到虚拟机的方法区中，并创建类对应的Class对象。</li>\n<li><strong>验证</strong>：<em>程序员不可见</em>。对类的各种信息进行验证，确保JVM的安全。</li>\n<li><strong>准备</strong>：<em>程序员不可见</em>。为静态变量在方法区中分配内存，并初始化为数据类型的零值。</li>\n<li><strong>解析</strong>：<em>程序员不可见</em>。将各种符号引用转化为直接引用。</li>\n<li><strong>初始化</strong>：<em>程序员可见</em>。执行JVM自己生成的<code>&lt;clinit&gt;()</code>方法。</li>\n<li><strong>使用</strong>：<em>程序员可见</em>。</li>\n<li><strong>卸载</strong>：<em>程序员不可见</em>。类从方法区中移出。</li>\n</ol>\n<p>上述 1,2,3,5 阶段是按顺序开始的，但是可能是交叉进行的。比如不同方面的验证(下文中会介绍)可能穿插在加载、解析阶段中进行。</p>\n<h3 id=\"加载\"><a href=\"#加载\" class=\"headerlink\" title=\"加载\"></a>加载</h3><p>加载阶段主要完成三个工作：</p>\n<ol>\n<li>通过常量池中类的全限定名获取对应类的二进制字节流（可能来自Class文件，网络，运行时动态生成等）。</li>\n<li>将二进制字节流读入虚拟机并在方法区中形成类的数据结构。</li>\n<li>在方法区中创建类对应的Class对象。</li>\n</ol>\n<blockquote>\n<p>如果要观察类的加载，则需要加上 <code>+XX:TraceClassLoading</code>，我们会发现程序运行时，首先会加载最基础的类比如 <code>java.lang.Object</code>等。</p>\n</blockquote>\n<p>加载阶段的运行离不开类加载器，类加载器在后文中”双亲委派模型”中会讲解，这里先给出基本介绍：类加载器主要完成根据类的全限定名获取类的二进制字节流(加载阶段的第一个工作)。类加载器有很多，包括系统自带的，自定义的类加载器。</p>\n<p>一个类的唯一性就是由类加载器和类的全限定名决定的，也就是说，如果一个类就算类的全限定名一样，但是由不同的类加载器加载到虚拟机中，则可以共存，即他们是不同的两个类。我们在开发中没出现这种情况是因为类默认都是由同一个类加载器（应用程序类加载器）加载。</p>\n<h3 id=\"验证\"><a href=\"#验证\" class=\"headerlink\" title=\"验证\"></a>验证</h3><p>验证的目的是为了确保二进制字节流符合当前JVM的要求，并使得JVM不受恶意代码的破坏。<br>验证分为：</p>\n<ul>\n<li><strong>文件格式验证</strong>：这个验证是在加载阶段进行的。主要验证二进制字节流是否符合class文件的格式规范，比如class文件是否以魔数0xCAFEBABE开头，主次版本号是否符合当前虚拟机的范围。</li>\n<li><strong>元数据验证</strong>：对类的元数据(类的定义)进行语义分析与验证，比如类是否重写了接口的所有方法，继承的父类是否是非final的。</li>\n<li><strong>字节码验证</strong>：对类中的字节码进行验证，比如方法体内跳转语句的跳转地址是否仍在方法体之内，类型转换语句是否正确。</li>\n<li><strong>符号引用验证</strong>：这个验证在解析阶段发生，主要对引用的合法性进行验证，比如根据类的全限定名是否能找到对应的类，当前类是否有权限访问引用的类、方法、属性。</li>\n</ul>\n<h3 id=\"准备\"><a href=\"#准备\" class=\"headerlink\" title=\"准备\"></a>准备</h3><p>为静态变量在方法区中分配内存，初始化值分为：</p>\n<ol>\n<li>当是static且非final变量，初始化为数据类型的零值。</li>\n<li>当是static final常量，初始化为赋值语句右边的值。</li>\n</ol>\n<h3 id=\"解析\"><a href=\"#解析\" class=\"headerlink\" title=\"解析\"></a>解析</h3><p>将常量池中的符号引用（一个符号而已，但是通过这个符号能够标明引用的对象是什么，比如符号引用是 <code>com.xiazdong.Test</code>，则可以看出他引用的是<code>com.xiazdong.Test</code>这个类）转化为直接引用（指向目标对象的指针或句柄）。</p>\n<p>解析分为类的解析，属性的解析，类方法的解析等，我们这里只介绍类的解析，属性的解析，其他类似。</p>\n<ul>\n<li>类的解析：将类的符号引用（类的全限定名）交给当前类的类加载器去加载该类（中间会触发元数据验证、字节码验证、符号引用验证），加载完后再判断当前类是否有权限访问引用的类，如果没有权限则抛出 <code>java.lang.IllegalAccessError</code>。</li>\n<li>属性的解析：<ol>\n<li>对属性的数据类型对应的类C进行解析（也就是类的解析）。</li>\n<li>如果在类C中存在名称和类型都与目标相匹配的属性，则返回该属性的直接引用。</li>\n<li>否则，在类C的父类或更上层寻找名称和类型都与目标匹配的属性，如果有则返回属性的直接引用。</li>\n<li>否则，抛出 <code>java.lang.NoSuchFieldError</code>。</li>\n<li>如果查找成功，则进行访问权限验证，如果当前类对该属性没有访问权限，则抛出 <code>java.lang.IllegalAccessError</code>。</li>\n</ol>\n</li>\n</ul>\n<h3 id=\"初始化\"><a href=\"#初始化\" class=\"headerlink\" title=\"初始化\"></a>初始化</h3><p>真正开始执行程序员编写的Java代码，也可以说是执行 <code>&lt;clinit&gt;()</code> 方法，该方法是由编译器自动收集类中所有类变量的赋值动作和静态代码块的语句，并按顺序合并产生。JVM对于初始化的时机有明确地规定：</p>\n<ol>\n<li>当遇到字节码指令 new, getstatic, putstatic, invokestatic 时，分别为创建实例，获得静态变量，设置静态变量值，调用静态方法。</li>\n<li>当通过反射访问该类。</li>\n<li>当初始化一个类时，如果发现父类没初始化，则先触发父类的初始化；如果发现父接口没初始化，则不用管父接口。</li>\n<li>程序的主类(main()方法所在的类)要最先初始化。</li>\n<li>(另一个场景先不必考虑。)</li>\n</ol>\n<h2 id=\"例子的分析\"><a href=\"#例子的分析\" class=\"headerlink\" title=\"例子的分析\"></a>例子的分析</h2><p>了解了类加载机制后，我们开始对上面的例子进行分析。</p>\n<h3 id=\"初始化-A-类\"><a href=\"#初始化-A-类\" class=\"headerlink\" title=\"初始化 A 类\"></a>初始化 A 类</h3><p>因为A类是程序的执行主类，因此首先执行A的<code>&lt;clinit&gt;()</code>方法。该类的<code>&lt;clinit&gt;()</code>方法类似如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">System.out.print(“1”);</div><div class=\"line\">System.out.print(“2”);</div></pre></td></tr></table></figure>\n<h3 id=\"执行-A-getInstance\"><a href=\"#执行-A-getInstance\" class=\"headerlink\" title=\"执行 A.getInstance()\"></a>执行 A.getInstance()</h3><ol>\n<li>执行 <code>System.out.print(&quot;3&quot;)</code>。</li>\n<li>因为访问了 B 的静态变量 <code>instance</code>，因此导致该类的初始化，执行该类的<code>&lt;clinit&gt;()</code>方法：</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">A instance = <span class=\"keyword\">new</span> A();<span class=\"comment\">//调用A的构造函数，因此输出4</span></div><div class=\"line\">System.out.print(“<span class=\"number\">5</span>”);</div></pre></td></tr></table></figure>\n<h2 id=\"双亲委派模型\"><a href=\"#双亲委派模型\" class=\"headerlink\" title=\"双亲委派模型\"></a>双亲委派模型</h2><p>类加载器负责完成加载阶段的”根据类的全限定名获取该类的二进制字节流”。<br>类加载器分为：</p>\n<ol>\n<li><strong>启动类加载器</strong>(Bootstrap ClassLoader): C++实现，负责加载 &lt;JAVA_HOME&gt;\\lib(或 -Xbootclasspath 参数指定路径)中的虚拟机识别的类，程序员不能直接使用该类加载器。</li>\n<li><strong>扩展类加载器</strong>(Extension ClassLoader): 负责加载 &lt;JAVA_HOME&gt;\\lib\\ext 中的类库。</li>\n<li><strong>应用程序类加载器</strong>(Application ClassLoader): 负责加载 classpath 指定的类库，这是程序的默认类加载器。</li>\n<li><strong>自定义类加载器</strong>: 用户自己定义的类加载器。继承 ClassLoader 类并重写 <code>findClass()</code>。</li>\n</ol>\n<p>有这么多类加载器，一个类到底要由哪个类加载器加载呢？由此引入了双亲委派模型(Parents Delegation Model)。如下图：</p>\n<p><img src=\"http://i.imgur.com/dPjdejP.jpg\" alt=\"\"></p>\n<p>双亲委派模型的目的是组织类加载器的层次关系(这种层次关系是通过组合方式实现)，并以下面的方式去工作：</p>\n<blockquote>\n<p>如果一个类加载器收到了类加载请求，他首先不会自己去加载，而是会交给父类加载器，因此所有的加载请求最终都应传送到顶层的启动类加载器，只有当父类加载器反馈自己无法完成加载请求时，子加载器才会去尝试自己加载。</p>\n</blockquote>\n<p>因此如果将 <code>java.lang.Object</code> 交给应用程序类加载器加载，则首先会交给父类加载器完成，很幸运启动类加载器能够完成这个加载请求，则就轮不到应用程序类加载器了。</p>\n<h2 id=\"易混点\"><a href=\"#易混点\" class=\"headerlink\" title=\"易混点\"></a>易混点</h2><p><strong>加载</strong>这个词在这篇文章中出现多次，我们要来理清这里面的区别：</p>\n<ol>\n<li>类加载机制：类的生命周期。</li>\n<li>加载阶段：类加载机制的第一个阶段。</li>\n<li>类加载器：完成加载阶段的一部分内容。</li>\n</ol>\n<hr>\n<p>终于写完了，这篇文章也算是2014年的最后一篇博客。<font color=\"red\">再见，2014！</font>希望明年能够更好！</p>\n","categories":[],"tags":["Java"]},{"title":"代理模式及Java实现动态代理","url":"http://xiazdong.github.io/2014/11/27/代理模式及Java实现动态代理/","content":"<h2 id=\"代理模式\"><a href=\"#代理模式\" class=\"headerlink\" title=\"代理模式\"></a>代理模式</h2><p>定义：给某个对象提供一个代理对象，并由代理对象控制对于原对象的访问，即客户不直接操控原对象，而是通过代理对象间接地操控原对象。</p>\n<p><img src=\"http://i.imgur.com/oh3VMNs.gif\" alt=\"代理模式UML图\"></p>\n<p>在上图中：</p>\n<ul>\n<li>RealSubject 是原对象（本文把原对象称为”委托对象”），Proxy 是代理对象。</li>\n<li>Subject 是委托对象和代理对象都共同实现的接口。</li>\n<li><code>Request()</code> 是委托对象和代理对象共同拥有的方法。 </li>\n</ul>\n<p>要理解代理模式很简单，其实生活当中就存在代理模式：</p>\n<blockquote>\n<p>我们购买火车票可以去火车站买，但是也可以去火车票代售处买，此处的火车票代售处就是火车站购票的代理，即我们在代售点发出买票请求，代售点会把请求发给火车站，火车站把购买成功响应发给代售点，代售点再告诉你。<br>但是代售点只能买票，不能退票，而火车站能买票也能退票，因此代理对象支持的操作可能和委托对象的操作有所不同。</p>\n</blockquote>\n<p>再举一个写程序会碰到的一个例子：</p>\n<blockquote>\n<p>如果现在有一个已有项目（你没有源代码，只能调用它）能够调用 <code>int compute(String exp1)</code> 实现对于后缀表达式的计算，你想使用这个项目实现对于中缀表达式的计算，那么你可以写一个代理类，并且其中也定义一个<code>compute(String exp2)</code>，这个<code>exp2</code>参数是中缀表达式，因此你需要在调用已有项目的 <code>compute()</code> 之前将中缀表达式转换成后缀表达式(Preprocess)，再调用已有项目的<code>compute()</code>，当然你还可以接收到返回值之后再做些其他操作比如存入文件(Postprocess)，这个过程就是使用了代理模式。</p>\n</blockquote>\n<p>在平时用电脑也会碰到代理模式的应用：</p>\n<blockquote>\n<p>远程代理：我们在国内因为GFW，所以不能访问 facebook，我们可以用翻墙（设置代理）的方法访问。访问过程是：<br>(1)用户把HTTP请求发给代理<br>(2)代理把HTTP请求发给web服务器<br>(3)web服务器把HTTP响应发给代理<br>(4)代理把HTTP响应发回给用户</p>\n</blockquote>\n<p>Java 实现上面的UML图的代码（即实现静态代理）为：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ProxyDemo</span> </span>&#123;</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String args[])</span></span>&#123;</div><div class=\"line\">\t\tRealSubject subject = <span class=\"keyword\">new</span> RealSubject();</div><div class=\"line\">\t\tProxy p = <span class=\"keyword\">new</span> Proxy(subject);</div><div class=\"line\">\t\tp.request();</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Subject</span></span>&#123;</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">request</span><span class=\"params\">()</span></span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RealSubject</span> <span class=\"keyword\">implements</span> <span class=\"title\">Subject</span></span>&#123;</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">request</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"request\"</span>);</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Proxy</span> <span class=\"keyword\">implements</span> <span class=\"title\">Subject</span></span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">private</span> Subject subject;</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Proxy</span><span class=\"params\">(Subject subject)</span></span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">this</span>.subject = subject;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">request</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"PreProcess\"</span>);</div><div class=\"line\">\t\tsubject.request();</div><div class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"PostProcess\"</span>);</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>代理的实现分为：</p>\n<ul>\n<li>静态代理：代理类是在编译时就实现好的。也就是说 Java 编译完成后代理类是一个实际的 class 文件。</li>\n<li>动态代理：代理类是在运行时生成的。也就是说 Java 编译完之后并没有实际的 class 文件，而是在运行时动态生成的类字节码，并加载到JVM中。</li>\n</ul>\n<h2 id=\"Java-实现动态代理\"><a href=\"#Java-实现动态代理\" class=\"headerlink\" title=\"Java 实现动态代理\"></a>Java 实现动态代理</h2><p>在前一节我们已经介绍了静态代理（第一节已经实现）和动态代理，那么在 Java 中是如何实现动态代理，即如何做到在运行时动态的生成代理类呢？</p>\n<p>首先先说明几个词：</p>\n<ul>\n<li>委托类和委托对象：委托类是一个类，委托对象是委托类的实例。</li>\n<li>代理类和代理对象：代理类是一个类，代理对象是代理类的实例。</li>\n</ul>\n<p>Java实现动态代理的大致步骤如下：</p>\n<ol>\n<li>定义一个委托类和公共接口。</li>\n<li>自己定义一个类（调用处理器类，即实现 <code>InvocationHandler</code> 接口），这个类的目的是指定运行时将生成的代理类需要完成的具体任务（包括Preprocess和Postprocess），即代理类调用任何方法都会经过这个调用处理器类（在本文最后一节对此进行解释）。</li>\n<li>生成代理对象（当然也会生成代理类），需要为他指定(1)委托对象(2)实现的一系列接口(3)调用处理器类的实例。因此可以看出一个代理对象对应一个委托对象，对应一个调用处理器实例。</li>\n</ol>\n<p>Java 实现动态代理主要涉及以下几个类：</p>\n<ul>\n<li><code>java.lang.reflect.Proxy</code>: 这是生成代理类的主类，通过 Proxy 类生成的代理类都继承了 Proxy 类，即 <code>DynamicProxyClass extends Proxy</code>。</li>\n<li><code>java.lang.reflect.InvocationHandler</code>: 这里称他为”调用处理器”，他是一个接口，我们动态生成的代理类需要完成的具体内容需要自己定义一个类，而这个类必须实现 InvocationHandler 接口。</li>\n</ul>\n<p>Proxy 类主要方法为：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//创建代理对象  </span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> Object <span class=\"title\">newProxyInstance</span><span class=\"params\">(ClassLoader loader,Class&lt;?&gt;[] interfaces,InvocationHandler h)</span></span></div></pre></td></tr></table></figure>\n<p>这个静态函数的第一个参数是类加载器对象（即哪个类加载器来加载这个代理类到 JVM 的方法区），第二个参数是接口（表明你这个代理类需要实现哪些接口），第三个参数是调用处理器类实例（指定代理类中具体要干什么）。这个函数是 JDK 为了程序员方便创建代理对象而封装的一个函数，因此你调用<code>newProxyInstance()</code>时直接创建了代理对象（略去了创建代理类的代码）。其实他主要完成了以下几个工作：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> Object <span class=\"title\">newProxyInstance</span><span class=\"params\">(ClassLoader loader,Class&lt;?&gt;[] interfaces,InvocationHandler handler)</span></span></div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"comment\">//1. 根据类加载器和接口创建代理类</span></div><div class=\"line\">    Class clazz = Proxy.getProxyClass(loader, interfaces); </div><div class=\"line\">    <span class=\"comment\">//2. 获得代理类的带参数的构造函数</span></div><div class=\"line\">    Constructor constructor = clazz.getConstructor(<span class=\"keyword\">new</span> Class[] &#123; InvocationHandler.class &#125;);</div><div class=\"line\">    <span class=\"comment\">//3. 创建代理对象，并制定调用处理器实例为参数传入</span></div><div class=\"line\">    Interface Proxy = (Interface)constructor.newInstance(<span class=\"keyword\">new</span> Object[] &#123;handler&#125;);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>Proxy 类还有一些静态方法，比如：</p>\n<ul>\n<li><code>InvocationHandler getInvocationHandler(Object proxy)</code>: 获得代理对象对应的调用处理器对象。</li>\n<li><code>Class getProxyClass(ClassLoader loader, Class[] interfaces)</code>: 根据类加载器和实现的接口获得代理类。</li>\n</ul>\n<p>Proxy 类中有一个映射表，映射关系为：(ClassLoader,(Interfaces,ProxyClass))，可以看出一级key为类加载器，根据这个一级key获得二级映射表，二级key为接口数组，因此可以看出：一个类加载器对象和一个接口数组确定了一个代理类。</p>\n<p>我们写一个简单的例子来阐述 Java 实现动态代理的整个过程：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DynamicProxyDemo01</span> </span>&#123;</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</div><div class=\"line\">\t\tRealSubject realSubject = <span class=\"keyword\">new</span> RealSubject();<span class=\"comment\">//1.创建委托对象</span></div><div class=\"line\">\t\tProxyHandler handler = <span class=\"keyword\">new</span> ProxyHandler(realSubject);<span class=\"comment\">//2.创建调用处理器对象</span></div><div class=\"line\">\t\tSubject proxySubject = (Subject)Proxy.newProxyInstance(RealSubject.class.getClassLoader(), RealSubject.class.getInterfaces(), handler);\t<span class=\"comment\">//3.动态生成代理对象</span></div><div class=\"line\">\t\tproxySubject.request();\t<span class=\"comment\">//4.通过代理对象调用方法</span></div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\">\t</div><div class=\"line\"><span class=\"comment\">/**</span></div><div class=\"line\"> * 接口</div><div class=\"line\"> */</div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Subject</span></span>&#123;</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">request</span><span class=\"params\">()</span></span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">/**</span></div><div class=\"line\"> * 委托类</div><div class=\"line\"> */</div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RealSubject</span> <span class=\"keyword\">implements</span> <span class=\"title\">Subject</span></span>&#123;</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">request</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"====RealSubject Request====\"</span>);</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">/**</span></div><div class=\"line\"> * 代理类的调用处理器</div><div class=\"line\"> */</div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ProxyHandler</span> <span class=\"keyword\">implements</span> <span class=\"title\">InvocationHandler</span></span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">private</span> Subject subject;</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ProxyHandler</span><span class=\"params\">(Subject subject)</span></span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">this</span>.subject = subject;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t<span class=\"meta\">@Override</span></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">invoke</span><span class=\"params\">(Object proxy, Method method, Object[] args)</span></span></div><div class=\"line\">\t\t\t<span class=\"keyword\">throws</span> Throwable &#123;</div><div class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"====before====\"</span>);<span class=\"comment\">//定义预处理的工作，当然你也可以根据 method 的不同进行不同的预处理工作</span></div><div class=\"line\">\t\tObject result = method.invoke(subject, args);</div><div class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"====after====\"</span>);</div><div class=\"line\">\t\t<span class=\"keyword\">return</span> result;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>InvocationHandler 接口中有方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"><span class=\"function\">Object <span class=\"title\">invoke</span><span class=\"params\">(Object proxy, Method method, Object[] args)</span> <span class=\"keyword\">throws</span> Throwable</span></div></pre></td></tr></table></figure>\n<p>这个函数是在代理对象调用任何一个方法时都会调用的，方法不同会导致第二个参数method不同，第一个参数是代理对象（表示哪个代理对象调用了method方法），第二个参数是 Method 对象（表示哪个方法被调用了），第三个参数是指定调用方法的参数。</p>\n<p>动态生成的代理类具有几个特点：</p>\n<ul>\n<li>继承 Proxy 类，并实现了在<code>Proxy.newProxyInstance()</code>中提供的接口数组。</li>\n<li>public final。</li>\n<li>命名方式为 <code>$ProxyN</code>，其中N会慢慢增加，一开始是 <code>$Proxy1</code>，接下来是<code>$Proxy2</code>…</li>\n<li>有一个参数为 InvocationHandler 的构造函数。这个从 <code>Proxy.newProxyInstance()</code> 函数内部的<code>clazz.getConstructor(new Class[] { InvocationHandler.class })</code> 可以看出。</li>\n</ul>\n<p>Java 实现动态代理的缺点：因为 Java 的单继承特性（每个代理类都继承了 Proxy 类），只能针对接口创建代理类，不能针对类创建代理类。</p>\n<blockquote>\n<p>不难发现，代理类的实现是有很多共性的（重复代码），动态代理的好处在于避免了这些重复代码，只需要关注操作。</p>\n</blockquote>\n<h2 id=\"Java-动态代理的内部实现\"><a href=\"#Java-动态代理的内部实现\" class=\"headerlink\" title=\"Java 动态代理的内部实现\"></a>Java 动态代理的内部实现</h2><p>现在我们就会有一个问题： Java 是怎么保证代理对象调用的任何方法都会调用 InvocationHandler 的 <code>invoke()</code> 方法的？</p>\n<p>这就涉及到动态代理的内部实现。假设有一个接口 Subject，且里面有 <code>int request(int i)</code> 方法，则生成的代理类大致如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> $<span class=\"title\">Proxy1</span> <span class=\"keyword\">extends</span> <span class=\"title\">Proxy</span> <span class=\"keyword\">implements</span> <span class=\"title\">Subject</span></span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">private</span> InvocationHandler h;</div><div class=\"line\">\t<span class=\"keyword\">private</span> $Proxy1()&#123;&#125;</div><div class=\"line\">\t<span class=\"keyword\">public</span> $Proxy1(InvocationHandler h)&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">this</span>.h = h;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">request</span><span class=\"params\">(<span class=\"keyword\">int</span> i)</span></span>&#123;</div><div class=\"line\">\t\tMethod method = Subject.class.getMethod(<span class=\"string\">\"request\"</span>, <span class=\"keyword\">new</span> Class[]&#123;<span class=\"keyword\">int</span>.class&#125;);\t<span class=\"comment\">//创建method对象</span></div><div class=\"line\">\t\t<span class=\"keyword\">return</span> (Integer)h.invoke(<span class=\"keyword\">this</span>, method, <span class=\"keyword\">new</span> Object[]&#123;<span class=\"keyword\">new</span> Integer(i)&#125;); <span class=\"comment\">//调用了invoke方法</span></div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>通过上面的方法就成功调用了 invoke() 方法。</p>\n<h2 id=\"元编程\"><a href=\"#元编程\" class=\"headerlink\" title=\"元编程\"></a>元编程</h2><p>到最后，我还想介绍一下元编程，我是从 <a href=\"http://product.china-pub.com/3769393\" target=\"_blank\" rel=\"external\">《MacTalk·人生元编程》</a> 中了解到元编程这个词的：</p>\n<blockquote>\n<p>元编程就是能够操作代码的代码</p>\n</blockquote>\n<p>Java 支持元编程因为反射、动态代理、内省等特性。</p>\n<h2 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h2><ul>\n<li><a href=\"http://www.ibm.com/developerworks/cn/java/j-lo-proxy1/\" target=\"_blank\" rel=\"external\">Java 动态代理机制分析及扩展，第 1 部分</a></li>\n<li><a href=\"http://zhidao.baidu.com/link?url=lPrrnjezrVWQEAwnK3pLWAISllIeqmFBDe-H4PiSzxEczb8EZR0p6asCdsXxSfDLmRf50yoIo6q3QqpoZzoMMa\" target=\"_blank\" rel=\"external\">动态代理的作用是什么？</a></li>\n<li><a href=\"http://rejoy.iteye.com/blog/1627405\" target=\"_blank\" rel=\"external\">JDK动态代理实现原理</a></li>\n<li><a href=\"http://www.cnblogs.com/flyoung2008/archive/2013/08/11/3251148.html\" target=\"_blank\" rel=\"external\">彻底理解JAVA动态代理</a></li>\n<li><a href=\"http://www.imooc.com/learn/214\" target=\"_blank\" rel=\"external\">慕课网：模式的秘密—代理模式</a></li>\n</ul>\n","categories":[],"tags":["设计模式"]},{"title":"Java8新特性之Lambda表达是入门","url":"http://xiazdong.github.io/2014/11/03/Lambda入门/","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>我看了了一些 Lambda 表达式的文章，发现有些文章讲的很好，比如：</p>\n<ul>\n<li>如果想入门 Lambda 表达式，则可以首先看《Java核心技术》作者 Horstmann 写的 <a href=\"http://www.drdobbs.com/jvm/lambda-expressions-in-java-8/240166764\" target=\"_blank\" rel=\"external\">Lambda Expressions in Java 8</a>，中文版请看这里<a href=\"http://iofree.cc/java-8%EF%BC%9Alambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%EF%BC%88%E4%B8%80%EF%BC%89/\" target=\"_blank\" rel=\"external\">JAVA 8：LAMBDA表达式（一）</a>, <a href=\"http://iofree.cc/java-8%EF%BC%9Alambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%EF%BC%88%E4%BA%8C%EF%BC%89/\" target=\"_blank\" rel=\"external\">JAVA 8：LAMBDA表达式（二）</a> 和 <a href=\"http://iofree.cc/java-8%EF%BC%9Alambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%EF%BC%88%E4%B8%89%EF%BC%89/\" target=\"_blank\" rel=\"external\">JAVA 8：LAMBDA表达式（三）</a></li>\n<li><a href=\"http://winterbe.com/posts/2014/03/16/java-8-tutorial/\" target=\"_blank\" rel=\"external\">Java 8 Tutorial</a> 也清晰地介绍了 Lambda 表达式</li>\n<li>如果想系统学习 Lambda 表达式，则可以看 <a href=\"http://cr.openjdk.java.net/~briangoetz/lambda/lambda-state-final.html\" target=\"_blank\" rel=\"external\">State of the Lambda</a>(中文版请点<a href=\"http://zh.lucida.me/blog/java-8-lambdas-insideout-language-features/\" target=\"_blank\" rel=\"external\">这里</a>)、<a href=\"http://cr.openjdk.java.net/~briangoetz/lambda/lambda-libraries-final.html\" target=\"_blank\" rel=\"external\">State of the Lambda: Libraries Edition</a>、<a href=\"http://cr.openjdk.java.net/~briangoetz/lambda/lambda-translation.html\" target=\"_blank\" rel=\"external\">Translation of Lambda Expressions</a></li>\n</ul>\n<p>我也不想重复造轮子，因此本篇文章的侧重点在于总结 Lambda 表达式的核心概念以及使用 Lambda 表达式的场景举例。</p>\n<h2 id=\"Functional-Interface\"><a href=\"#Functional-Interface\" class=\"headerlink\" title=\"Functional Interface\"></a>Functional Interface</h2><p>只包含一个方法的接口称为 Functional Interface（这里的<code>只包含一个方法</code> 不是只有一个方法，因为可能有 default 方法或 static 方法（这些后面会介绍），这里指的是只有一个普通抽象方法）。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">A</span></span>&#123;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">f1</span><span class=\"params\">()</span></span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">@FunctionalInterface</span>       <span class=\"comment\">//Compile Error，因为 B 有2个抽象方法</span></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">B</span> <span class=\"keyword\">extends</span> <span class=\"title\">A</span></span>&#123;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">f2</span><span class=\"params\">()</span></span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>比如 Comparator 接口：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@FunctionalInterface</span></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Comparator</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">compare</span><span class=\"params\">(T o1, T o2)</span></span>;</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">equals</span><span class=\"params\">(Object obj)</span></span>;</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">default</span> Comparator&lt;T&gt; <span class=\"title\">reversed</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\"> \t\t…</div><div class=\"line\"> \t&#125;</div><div class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">static</span> &lt;T, U extends Comparable&lt;? <span class=\"keyword\">super</span> U&gt;&gt; <span class=\"function\">Comparator&lt;T&gt; <span class=\"title\">comparing</span><span class=\"params\">(</span></span></div><div class=\"line\">            \t\t\t\t\t\t\t\t\tFunction&lt;? <span class=\"keyword\">super</span> T, ? extends U&gt; keyExtractor)</div><div class=\"line\">\t&#123;</div><div class=\"line\">\t\t…</div><div class=\"line\">   \t&#125;</div><div class=\"line\">\t\t…</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>解释：</p>\n<ul>\n<li><code>@FunctionalInterface</code> : 此注解只是为了表明 Comparator 接口是一个 Functional Interface(不加也没关系)，当创建的接口违反了要成为 Functional Interface 的规则，则会编译错误，因此这个注解只是为了验证代码的正确性而已。因此如果你以后自己定义了一个 Functional Interface，建议在最开头写上注解 <code>@FunctionalInterface</code>。</li>\n<li>Comparator 接口只新定义了一个普通抽象方法，就是 <code>int compare(T o1, T o2);</code> 其他方法要么是 <code>default</code> 或 <code>static</code> 方法（我们发现 Comparator 接口既有 default 方法，又有 static 方法，这些后面会介绍，这是 Java8 对于接口的新特性），要么是把继承自 Object 类的方法重写了一下(<code>equals</code> 方法)</li>\n<li><code>Function&lt;? super T, ? extends U&gt;</code> : Function 接口是 Java8 新增的 Functional Interface 之一(<code>java.util.function</code> 包中包含了很多内置的 Functional Interface)，<code>Function&lt;T,R&gt;</code> 提供了 <code>R apply(T t)</code> 函数，即给定一个输入t，经过一系列转换返回一个R实例(可以想象成一个名为 <code>apply</code> 的盒子，输入是T类型的实例，输出是R类型的实例，具体盒子的实现可以自定义)。</li>\n<li><code>comparing</code> 函数中加了泛型。其中 <code>&lt;? super T, ? extends U&gt;</code> 表示 Function<a,b> 中的 A 必须要是 T 的父类，B 必须是 U 的子类。</a,b></li>\n</ul>\n<h2 id=\"default-方法\"><a href=\"#default-方法\" class=\"headerlink\" title=\"default 方法\"></a>default 方法</h2><p>default 方法的出现是为了降低未来对于已有接口修改的难度，即如果想对一个已有接口新加一个或多个方法，因为以前不允许在接口中加入函数实现，因此你首先必须要在接口中定义一些抽象方法，并且在实现该接口的所有类中都实现新加的方法，很麻烦对不对（比如世界上有千千万万 Java 程序员使用了 Comparator 接口，如果新版本 JDK 在 Comparator 中新定义了一个抽象方法，那是毁灭性的！千千万万的程序员就要崩溃了，估计用 Java 的人也会大大减少…）；default 帮你解决这个问题，你如果想在接口中新加方法，并且不想影响实现该接口的类，只需要将他声明为 default 并实现他即可，当然实现该接口的类也可以 Overwrite 该 default 方法，当然也可以什么都不做(就像 Comparator 接口中也新加了很多 default 方法，你完全不需要改动写过的现有代码)’</p>\n<p>这里举个例子说明 default 在 JDK 中的应用：</p>\n<ul>\n<li>List 接口中新增了 sort 方法，自从有了这个方法，就不需要调用 <code>Arrays.sort()</code> 方法了。对 ArrayList 类型的实例 list 排序，只调用 <code>list.sort()</code>  即可。</li>\n<li>Iterable 接口中新增了 <code>forEach</code> 方法，我们可以直接使用 <code>list.forEach()</code> 对每个元素做一些操作，不必再自己 for 循环了。</li>\n</ul>\n<h2 id=\"static-方法\"><a href=\"#static-方法\" class=\"headerlink\" title=\"static 方法\"></a>static 方法</h2><p>Java8 开始在接口中能够声明静态方法，这里举个例子说明 static 方法出现的原因：想在接口中定义一些辅助方法，比如原本创建一个实现 Comparator 接口的对象需要 new，现在只需要 <code>Comparator.comparing()</code> 方法就可以创建这样一个对象，很方便。 </p>\n<h2 id=\"Lambda-表达式初窥\"><a href=\"#Lambda-表达式初窥\" class=\"headerlink\" title=\"Lambda 表达式初窥\"></a>Lambda 表达式初窥</h2><h3 id=\"Lambda-表达式基本形式\"><a href=\"#Lambda-表达式基本形式\" class=\"headerlink\" title=\"Lambda 表达式基本形式\"></a>Lambda 表达式基本形式</h3><p>Lambda 表达式以 <code>(ParamList) -&gt; { 函数体 }</code> 或 <code>(ParamList) -&gt; 单个表达式</code>形式存在。前者等价于创建一个实现某个 Functional Interface 的对象，并实现该接口的方法，<code>(ParamList)</code> 必须和 Functional Interface 需要实现的方法的参数一一对应，<code>{ 函数体 }</code> 就是实现方法的函数体。当接口方法的函数体中代码很简单，只需要一个 return 语句就可以搞定时，使用 Lambda 表达式的后者表现形式更简洁，<code>单个表达式</code> 就是 return 语句，只是少了 return 这个单词。</p>\n<blockquote>\n<p>当 <code>(ParamList)</code> 中只有一个参数时，<code>()</code> 可省略，即 <code>(Param)</code> 等价于 <code>Param</code> </p>\n</blockquote>\n<p><strong>例子：</strong></p>\n<p>为了创建一个用于整数之间比较的 Comparator 对象，需要以下6行代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">Comparator&lt;Integer&gt; c = <span class=\"keyword\">new</span> Comparator&lt;Integer&gt;() &#123;</div><div class=\"line\">   <span class=\"meta\">@Override</span></div><div class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">compare</span><span class=\"params\">(Integer o1, Integer o2)</span> </span>&#123;</div><div class=\"line\">       <span class=\"keyword\">return</span> o1.compareTo(o2);</div><div class=\"line\">   &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>实际上用 Lambda 表达式1行解决：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">Comparator&lt;Integer&gt; c = (Integer o1, Integer o2) -&gt; o1.compareTo(o2);</div></pre></td></tr></table></figure>\n<p>Lambda 表达式是一个匿名方法，为了解决实现 Functional Interface 的匿名内部类太过麻烦的问题（本来1行代码能解决的问题用了6行）</p>\n<h3 id=\"Target-Type\"><a href=\"#Target-Type\" class=\"headerlink\" title=\"Target Type\"></a>Target Type</h3><p>Lambda 表达式有一个 Target Type 的概念，意思是这个 Lambda 表达式将返回的类型。同一个 Lambda 表达式在不同的上下文中的 Target Type 是不一样的（Target Type 是通过类型推导得出），比如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">Callable&lt;String&gt; c = () -&gt; “done”;</div></pre></td></tr></table></figure>\n<p>和</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">PrivilegedAction&lt;String&gt; a = () -&gt; “done”;</div></pre></td></tr></table></figure>\n<p>虽然 Lambda 表达式一样，但是前者的 Target Type 是 Callable，后者的 Target Type 是 PrivilegedAction。</p>\n<p>我们也能够通过强制类型转换的方式帮助编译器确定 Target Type：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">Object o = (Runnable) () -&gt; &#123; System.out.println(<span class=\"string\">\"hello\"</span>)&#125;;</div></pre></td></tr></table></figure>\n<h3 id=\"Lambda-和使用匿名内部类实现的区别\"><a href=\"#Lambda-和使用匿名内部类实现的区别\" class=\"headerlink\" title=\"Lambda 和使用匿名内部类实现的区别\"></a>Lambda 和使用匿名内部类实现的区别</h3><p>在 Lambda 表达式中使用 this 关键字表示的意思是外部类，而内部类中使用 this 关键字表示的意思是内部类。Lambda 表达式虽然看上去像内部类，但是本身并不依赖外部类，是独立存在的（内部类的生存依赖于外部类，从内部类的命名本身就能看出）</p>\n<p>比如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Hello</span> </span>&#123;</div><div class=\"line\">\tRunnable r1 = () -&gt; &#123; System.out.println(<span class=\"keyword\">this</span>); &#125;</div><div class=\"line\">\tRunnable r2 = () -&gt; &#123; System.out.println(toString()); &#125;</div><div class=\"line\">    Runnable r3 = <span class=\"keyword\">new</span> Runnable()[</div><div class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">\t\t\tSystem.out.println(<span class=\"keyword\">this</span>);</div><div class=\"line\">\t\t\tSystem.out.println(toString());</div><div class=\"line\">\t    &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">\t</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">toString</span><span class=\"params\">()</span> </span>&#123;  <span class=\"keyword\">return</span> <span class=\"string\">\"Hello\"</span>; &#125;</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String... args)</span> </span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">new</span> Hello().r1.run();</div><div class=\"line\">\t\t<span class=\"keyword\">new</span> Hello().r2.run();</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>r1 和 r2 都是输出 <code>“Hello”</code>，r3 输出 <code>Hello$1@5b89a773</code>。可以看出 Lambda 表达式和一般匿名内部类有区别。</p>\n<p>接下去再举一个例子：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">int</span> a = <span class=\"number\">1</span>;</div><div class=\"line\">        </div><div class=\"line\">Runnable r1 = <span class=\"keyword\">new</span> Runnable() &#123;</div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">int</span> a = <span class=\"number\">2</span>;      <span class=\"comment\">//OK     </span></div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\">        </div><div class=\"line\">Runnable r2 = () -&gt; &#123;</div><div class=\"line\">   <span class=\"keyword\">int</span> a = <span class=\"number\">2</span>;    <span class=\"comment\">//Compile Error</span></div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>可以看出 Lambda 表达式的 block statement 的 scope 和外部类是一个 Level 的，而内部类不是。</p>\n<p>Java 是 Lexical Scoping 的，程序语言可能有两种 scoping 方式：Lexical Scoping 和 dynamic Scoping。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">f()&#123;</div><div class=\"line\">\tg();</div><div class=\"line\">&#125;</div><div class=\"line\">\t</div><div class=\"line\">g()&#123;</div><div class=\"line\">\t<span class=\"keyword\">int</span> a;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>在上面的代码中，如果语言是 lexical scoping 的，则<code>f()</code>函数中不能访问<code>g()</code>的局部变量<code>a</code>，如果是 dynamic scoping 的，则<code>f()</code>函数能够访问<code>g()</code>的局部变量<code>a</code>。</p>\n<h3 id=\"Effectively-Final-变量\"><a href=\"#Effectively-Final-变量\" class=\"headerlink\" title=\"Effectively Final 变量\"></a>Effectively Final 变量</h3><p>原本如果内部类要使用外部的变量，则外部变量一定要定义成 final 的，Java8 以后，如果 Lambda 表达式和内部类要使用外部的变量，则不需要一定定义成 final 的，只需要是 “Effectively final” 即可，意思是你虽然不定义成 final，但是你实际上是 final 的，即使你加了个 final 也不会编译错误。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">int</span> b = <span class=\"number\">1</span>;</div><div class=\"line\"></div><div class=\"line\">Runnable r3 = () -&gt; &#123;</div><div class=\"line\">    System.out.println(b);  <span class=\"comment\">//OK</span></div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">Runnable r4 = <span class=\"keyword\">new</span> Runnable()&#123;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">        System.out.println(b);  <span class=\"comment\">//OK</span></div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>和原来的 final 变量一样，如果要向 <code>final ArrayList arr</code> 的 arr 变量中加入几个元素，这是允许的，但是要改变 arr 的引用，这是不允许的。</p>\n<h3 id=\"Method-Reference\"><a href=\"#Method-Reference\" class=\"headerlink\" title=\"Method Reference\"></a>Method Reference</h3><p>这是 Lambda 表达式的特殊情况，当接口实现方法的函数体中只包含 return 语句，并且 return 语句只是调用了其他方法，没有其他额外的代码，则这时候我们”可能”可以更加简化语法。</p>\n<p>Method Reference 的语法有很多种，因为方法有静态方法、常规方法、构造方法、父类的常规方法等，对于不同的方法，Method Reference 的语法也是不同的。</p>\n<ul>\n<li>静态方法：<em>ClassName</em>::<em>MethodName</em></li>\n<li>实例上的一般方法：<em>instance</em> :: <em>MethodName</em></li>\n<li>超类上的方法：super::<em>MethodName</em></li>\n<li>任意对象的一般方法：<em>ClassName</em>::<em>MethodName</em></li>\n<li>类的构造函数：<em>ClassName</em>::new</li>\n<li>数组构造函数：<em>TypeName</em>[]::new</li>\n</ul>\n<p>比如</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">Comparator&lt;Integer&gt; c = (Integer o1, Integer o2) -&gt; o1.compareTo(o2);</div></pre></td></tr></table></figure>\n<p>等价于 </p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">Comparator&lt;Integer&gt; c = Integer::compareTo;</div></pre></td></tr></table></figure>\n<p>我们能够看到上面的 Method Reference 方式(这里是任意对象的一般方法)比 Lambda 表达式更简单（虽然不那么容易理解），那么问题来了，compareTo 怎么连参数都没有指定，那怎么确定啊？其实 Method Reference 有个规则：</p>\n<blockquote>\n<p>functional interface 的方法的参数一一按顺序对应于 Method Rerference 的方法参数。</p>\n</blockquote>\n<p>因此 <code>Integer::compareTo</code> 等价于 <code>o1.compareTo(o2)</code>。</p>\n<blockquote>\n<p>个人观点：Method Reference 语法比较晦涩，而且给别人看也不太好理解，所以我觉得用 Lambda 表达式也挺好…是不是太没追求了…</p>\n</blockquote>\n<h2 id=\"例子\"><a href=\"#例子\" class=\"headerlink\" title=\"例子\"></a>例子</h2><p>这里就以一个例子讲解下 Lambda 表达式。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span></span>&#123;</div><div class=\"line\">\tString name;</div><div class=\"line\">    <span class=\"keyword\">int</span> age;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getName</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> name;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//1. 最普通的方法</span></div><div class=\"line\">Comparator&lt;Person&gt; c1 = <span class=\"keyword\">new</span> Comparator&lt;Person&gt;() &#123;</div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">compare</span><span class=\"params\">(Person o1, Person o2)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> o1.name.compareTo(o2.name);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//2. Lambda 表达式方法</span></div><div class=\"line\">Comparator&lt;Person&gt; c2 = (Person o1, Person o2) -&gt; o1.name.compareTo(o2.name);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//3. 应用类型推导</span></div><div class=\"line\">Comparator&lt;Person&gt; c3 = (o1, o2) -&gt; o1.name.compareTo(o2.name);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//4. 使用Comparator 的静态方法</span></div><div class=\"line\">Comparator&lt;Person&gt; c4 = Comparator.comparing((p) -&gt; p.name);</div><div class=\"line\"><span class=\"comment\">//也可以写成: Comparator&lt;Person&gt; c4 = Comparator.comparing(p -&gt; p.name);</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//5. 使用Method Reference</span></div><div class=\"line\">Comparator&lt;Person&gt; c5 = Comparator.comparing(Person::getName);</div></pre></td></tr></table></figure>\n<p>上面给了5种方法创建一个 Comparator 对象，目的是对多个 Person 排序，比较的 key 是 name 属性。</p>\n<ul>\n<li>第一种方法是 Java8 以前的方法。</li>\n<li>第二种方法是使用 Lambda 表达式，<code>(Person o1, Person o2)</code> 表示实现方法的参数；<code>o1.name.compareTo(o2.name)</code> 等价于 <code>return o1.name.compareTo(o2.name)</code>；</li>\n<li>第三种编译通过的原因是因为根据类型推导，编译器能够知道 Lambda 表达式的类型是 Comparator\\<person\\>，因此方法参数 Person 不写，编译器也知道。</person\\></li>\n<li>第四种方法使用了 Java8 中 Comparator 接口新加的 static 方法 <code>comparing</code>，参数接收一个 <code>Function&lt;T,R&gt;</code> 对象，根据 <code>Comparator&lt;Person&gt;</code> 得知 <code>T</code> 就是 <code>Person</code>，根据 <code>p.name</code> 得知 <code>R</code> 就是 <code>String</code></li>\n<li>第五种方法使用了 Method Reference</li>\n</ul>\n","categories":[],"tags":["Android"]},{"title":"Picasso使用入门","url":"http://xiazdong.github.io/2014/10/03/Picasso使用入门/","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>图片加载是 Android 开发经常要实现的功能，而这也是谈到 Android 性能优化问题时不得不提的问题，而 Picasso 项目就是帮助我们解决这个问题的，而我在网上搜也没找到比较全面关于 Picasso 的中文教程，因此这里就写一篇关于 Picasso 这个开源项目的介绍。</p>\n<h2 id=\"Picasso-基本介绍\"><a href=\"#Picasso-基本介绍\" class=\"headerlink\" title=\"Picasso 基本介绍\"></a>Picasso 基本介绍</h2><ul>\n<li>项目地址：<a href=\"https://github.com/square/picasso\" target=\"_blank\" rel=\"external\">https://github.com/square/picasso</a></li>\n<li>项目定位：A powerful image downloading and caching library for Android，即实现图片加载、图片缓存的功能。</li>\n<li>该项目的依赖项目有：okHttp, okHttp-urlConnection, okio。如果通过jar包方式添加则需要注意版本，本文用的版本是：Picasso 2.3.4, okHttp 2.0.0, okHttp-urlConnection 2.0.0, okio 1.0.0；如果通过 gradle 添加那么依赖就自动添加进来了。</li>\n<li>很多人会把它和 UIL 项目比较，如果你刚刚接触图片异步加载，则我比较推荐 Picasso，因为使用起来太方便了。</li>\n</ul>\n<h2 id=\"优点\"><a href=\"#优点\" class=\"headerlink\" title=\"优点\"></a>优点</h2><p>1、<strong>入门简单</strong>：一般为了实现一个图片异步加载的功能，少说必须要使用：AsyncTask, LruCache, DiskCache, BitmapFactory 等等，实现起来还是有难度的，但是 Picasso 只需要一行代码即可实现图片异步加载：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">Picasso.with(context).load(<span class=\"string\">\"http://i.imgur.com/DvpvklR.png\"</span>).into(imageView);</div></pre></td></tr></table></figure>\n<p>是不是非常方便。</p>\n<p>2、<strong>自动取消Adapter的下载任务</strong>：一般来说我们在实现 ListView 时会重用 view，比如第10个位置的 view 重用第1个位置的 view，当从第1个位置快速滑到第10个位置时，虽然第1个位置的图片还没下载好，Picasso 能够帮我们自动取消第1个位置的下载任务，开始第10个位置的下载任务，我们只需要管业务逻辑即可。</p>\n<p>3、<strong>利用最少的内存对图片进行变换</strong>：简单的 API 即可实现图片的旋转、改变大小等简单变换，还能够自定义变换。</p>\n<p>4、<strong>自动进行内存和磁盘的缓存</strong>: 不需要自己实现缓存(缺点是不能设定缓存大小)，当然你在加载图片时也可以设置成不使用缓存(skipMemoryCache)。</p>\n<p>5、<strong>提供很好的调试界面</strong>：如果开启调试模式，则如果图片是从网络中获得，则图片左上角会有红色三角形；如果图片从磁盘获得，则图片左上角会有黄色三角形；如果图片从内存获得，则图片左上角会有绿色三角形。如图所示：<br><img src=\"http://square.github.io/picasso/static/debug.png\" alt=\"\"></p>\n<p>6、<strong>支持通过资源id、本地文件、网络载入图片</strong>: <code>load()</code> 函数即可实现从不同的来源载入图片。</p>\n<h2 id=\"基本使用方法\"><a href=\"#基本使用方法\" class=\"headerlink\" title=\"基本使用方法\"></a>基本使用方法</h2><p>一般我遇到的需要实现的功能就是三个：</p>\n<ul>\n<li>简单实现异步加载图片到 ImageView，并在图片加载成功或失败时有个回调，即当图片加载成功时可以自定义一些操作，当图片加载失败时可以自定义一些操作。</li>\n<li>下载图片并保存到本地。</li>\n<li>对加载的图片进行变换。</li>\n</ul>\n<p>接下去我将会介绍常用的一些函数。</p>\n<h3 id=\"1、加载图片到-ImageView\"><a href=\"#1、加载图片到-ImageView\" class=\"headerlink\" title=\"1、加载图片到 ImageView\"></a>1、加载图片到 ImageView</h3><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">ImageView view = <span class=\"keyword\">null</span>;</div><div class=\"line\">Picasso picasso = Picasso.with(<span class=\"keyword\">this</span>);</div><div class=\"line\">picasso.setIndicatorsEnabled(<span class=\"keyword\">true</span>);   <span class=\"comment\">//开启调模式，它能够在图片左上角显示小三角形，这个小三角形的颜色标明了图片的来源：网络、内存缓存、磁盘缓存</span></div><div class=\"line\">picasso.setLoggingEnabled(<span class=\"keyword\">true</span>);  <span class=\"comment\">//打开日志，即log中会打印出目前下载的进度、情况</span></div><div class=\"line\">picasso.load(<span class=\"string\">\"http://xxx.jpg\"</span>)    <span class=\"comment\">//可以是本地图片或网络图片</span></div><div class=\"line\">       .placeholder(R.drawable.placeholder)   <span class=\"comment\">//当图片正在加载时显示的图片(optional)</span></div><div class=\"line\">       .error(R.drawable.error)   \t\t<span class=\"comment\">//当图片加载失败时显示的图片(optional)</span></div><div class=\"line\">       .into(view, <span class=\"keyword\">new</span> Callback() &#123;   <span class=\"comment\">//将图片下载完后放进view中，回调是可选的</span></div><div class=\"line\">           <span class=\"meta\">@Override</span></div><div class=\"line\">           <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onSuccess</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">               <span class=\"comment\">//加载图片成功时回调</span></div><div class=\"line\">           &#125;</div><div class=\"line\">           <span class=\"meta\">@Override</span></div><div class=\"line\">           <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onError</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">               <span class=\"comment\">//加载图片失败时回调</span></div><div class=\"line\">           &#125;</div><div class=\"line\">       &#125;);</div></pre></td></tr></table></figure>\n<h3 id=\"2、加载图片并自定义动作\"><a href=\"#2、加载图片并自定义动作\" class=\"headerlink\" title=\"2、加载图片并自定义动作\"></a>2、加载图片并自定义动作</h3><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">Target target = <span class=\"keyword\">new</span> Target()&#123;</div><div class=\"line\">      <span class=\"meta\">@Override</span></div><div class=\"line\">      <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onBitmapLoaded</span><span class=\"params\">(Bitmap bitmap, Picasso.LoadedFrom loadedFrom)</span> </span>&#123;</div><div class=\"line\">             <span class=\"comment\">//当图片加载成功时调用，bitmap是加载的图片,loadFrom 标明图片的来源是网络、内存还是磁盘</span></div><div class=\"line\">             <span class=\"comment\">//可以在里面执行把图片保存到本地的操作</span></div><div class=\"line\">      &#125;</div><div class=\"line\">      <span class=\"meta\">@Override</span></div><div class=\"line\">      <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onBitmapFailed</span><span class=\"params\">(Drawable errorDrawable)</span> </span>&#123;   <span class=\"comment\">//当图片加载失败时调用</span></div><div class=\"line\">      &#125;</div><div class=\"line\">      <span class=\"meta\">@Override</span></div><div class=\"line\">      <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onPrepareLoad</span><span class=\"params\">(Drawable placeHolderDrawable)</span> </span>&#123;    <span class=\"comment\">//当任务被提交时调用</span></div><div class=\"line\">      &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\">picasso.load(<span class=\"keyword\">new</span> File(<span class=\"string\">\"/1.jpg\"</span>)).into(target); <span class=\"comment\">//指定target任务加载图片</span></div></pre></td></tr></table></figure>\n<h3 id=\"3、对图片进行变换\"><a href=\"#3、对图片进行变换\" class=\"headerlink\" title=\"3、对图片进行变换\"></a>3、对图片进行变换</h3><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">Transformation transformation = <span class=\"keyword\">new</span> Transformation() &#123;</div><div class=\"line\">     <span class=\"meta\">@Override</span></div><div class=\"line\">     <span class=\"function\"><span class=\"keyword\">public</span> Bitmap <span class=\"title\">transform</span><span class=\"params\">(Bitmap bitmap)</span> </span>&#123;</div><div class=\"line\">        Bitmap newBitmap = <span class=\"keyword\">null</span>;</div><div class=\"line\">        <span class=\"comment\">//自定义变换</span></div><div class=\"line\">        <span class=\"keyword\">if</span>(bitmap != <span class=\"keyword\">null</span> &amp;&amp; !bitmap.isRecycled())&#123;   <span class=\"comment\">//将旧图片回收</span></div><div class=\"line\">            bitmap.recycle();</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">return</span> newBitmap;</div><div class=\"line\">     &#125;</div><div class=\"line\"></div><div class=\"line\">     <span class=\"meta\">@Override</span></div><div class=\"line\">     <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">key</span><span class=\"params\">()</span> </span>&#123; <span class=\"comment\">// 将用作cache的key</span></div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">\"key\"</span>;</div><div class=\"line\">     &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\">picasso.load(R.drawable.download)</div><div class=\"line\">\t\t   .skipMemoryCache()\t<span class=\"comment\">//不要把加载的图片放入缓存，也不要从缓存中取图片</span></div><div class=\"line\">        .transform(transformation)    <span class=\"comment\">//执行自定义变换</span></div><div class=\"line\">        .into(view);</div></pre></td></tr></table></figure>\n<h2 id=\"案例-实现异步加载图片的ListView\"><a href=\"#案例-实现异步加载图片的ListView\" class=\"headerlink\" title=\"案例: 实现异步加载图片的ListView\"></a>案例: 实现异步加载图片的ListView</h2><p>效果如下：</p>\n<p><img src=\"http://i.imgur.com/BlGZBYY.gif\" width=\"300\"></p>\n<p>我们使用到了<a href=\"http://blog.csdn.net/lmj623565791/article/details/38902805\" target=\"_blank\" rel=\"external\">通用适配器技术</a>（实现代码为 <a href=\"https://github.com/xiazdong/CommonAdapter\" target=\"_blank\" rel=\"external\">CommonAdapter</a> 项目），使得我们的主要代码只有30+行：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SimpleListActivity</span> <span class=\"keyword\">extends</span> <span class=\"title\">Activity</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreate</span><span class=\"params\">(Bundle savedInstanceState)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">super</span>.onCreate(savedInstanceState);</div><div class=\"line\">        setContentView(R.layout.activity_simple_list);</div><div class=\"line\">        List&lt;DataItem&gt; datas = getSampleDatas();</div><div class=\"line\">        ListView listView = (ListView)findViewById(R.id.list);</div><div class=\"line\">        Picasso.with(<span class=\"keyword\">this</span>).setIndicatorsEnabled(<span class=\"keyword\">true</span>);</div><div class=\"line\">        listView.setAdapter(<span class=\"keyword\">new</span> CommonAdapter&lt;DataItem&gt;(<span class=\"keyword\">this</span>,datas,R.layout.item_list) &#123;</div><div class=\"line\">            <span class=\"meta\">@Override</span></div><div class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">convert</span><span class=\"params\">(ViewHolder holder, DataItem item,<span class=\"keyword\">int</span> position)</span> </span>&#123;</div><div class=\"line\">                holder.setText(R.id.text,item.name);</div><div class=\"line\">                holder.setImage(R.id.image,item.url,<span class=\"keyword\">null</span>);  <span class=\"comment\">//setImage 函数中使用了 Picasso 库 </span></div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> List&lt;DataItem&gt; <span class=\"title\">getSampleDatas</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        List&lt;DataItem&gt; datas = <span class=\"keyword\">new</span> ArrayList&lt;DataItem&gt;();</div><div class=\"line\">        String[] urls = getResources().getStringArray(R.array.urls);</div><div class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; urls.length; i++)&#123;</div><div class=\"line\">            DataItem item = <span class=\"keyword\">new</span> DataItem(urls[i],urls[i]);</div><div class=\"line\">            datas.add(item);</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">return</span> datas;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DataItem</span></span>&#123;</div><div class=\"line\">    String url;</div><div class=\"line\">    String name;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">DataItem</span><span class=\"params\">(String url, String name)</span></span>&#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.url = url;</div><div class=\"line\">        <span class=\"keyword\">this</span>.name = name;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h2><ul>\n<li>官方文档：<a href=\"http://square.github.io/picasso/\" target=\"_blank\" rel=\"external\">http://square.github.io/picasso/</a></li>\n<li>Picasso Javadoc：<a href=\"http://square.github.io/picasso/javadoc/index.html\" target=\"_blank\" rel=\"external\">http://square.github.io/picasso/javadoc/index.html</a></li>\n<li>详细使用教程：<a href=\"http://www.opensourcealternative.org/tutorials/android-tutorials/android-picasso-save-image-tutorial/\" target=\"_blank\" rel=\"external\">http://www.opensourcealternative.org/tutorials/android-tutorials/android-picasso-save-image-tutorial/</a></li>\n<li>简单使用方法：<a href=\"http://blog.chengyunfeng.com/?p=492\" target=\"_blank\" rel=\"external\">http://blog.chengyunfeng.com/?p=492</a></li>\n<li>内部实现分析：<a href=\"http://blog.csdn.net/xu_fu/article/details/17043231\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/xu_fu/article/details/17043231</a></li>\n</ul>\n","categories":[],"tags":["Android"]},{"title":"su和sudo","url":"http://xiazdong.github.io/2014/09/17/ su和sudo/","content":"<h2 id=\"su-与-sudo-的区别\"><a href=\"#su-与-sudo-的区别\" class=\"headerlink\" title=\"su 与 sudo 的区别\"></a>su 与 sudo 的区别</h2><blockquote>\n<p>这两个操作并不是单纯的切换成 root 用户，而是能够切换成任何一个其他用户。</p>\n</blockquote>\n<ul>\n<li>su(Switch User): 切换用户的意思，他可以切换成任何其他用户，<strong>切换时需要输入目标用户(target user)的密码</strong>，切换成功之后会开启一个新的 shell 实例（可以当作是新开了一个命令行窗口），因此你如果要退回到原来的用户，你需要 <code>exit</code> 而不是 <code>logout</code>（类似于关闭当前的命令行窗口）。</li>\n<li>sudo: 官方定义是<code>execute a command as another user</code>，也就是说并不是要真正登录成另一个用户，而是以另一个用户的身份去执行命令，执行该命令之后<strong>需要输入当前用户的密码</strong>。前面说到 <code>sudo</code> 是请求授权，那么是不是要授权该用户是在 <code>/etc/sudoers</code> 中设置，如果要设置该文件，只需要使用 <code>visudo</code> 即可。比如：<code>root    ALL=(ALL) ALL</code> 表示 root 拥有全部权限。</li>\n</ul>\n<p>打个比方，假设有两个用户 A 和 B，用户 B 输入 <code>su - A</code> 意味着是让用户 A 自己做事情，因此需要输入用户 A 的密码；<code>sudo -i -u A</code> 意味着用户 A 已经同意用户 B 以 A 的名义做事情，因此这条指令需要输入用户 B 的密码只是为了确认是用户 B 输入了这条命令即可。<br>因此 <code>sudo</code> 和 <code>su</code> 最大的区别在于前者是借着某人的名义做事(do sth as sb)，而后者是真的人在做事(become sb)。 </p>\n<p>最后给张有趣配图说明 <code>sudo</code> 的作用：</p>\n<p><img src=\"http://i.imgur.com/gPkYqlh.jpg\" alt=\"\"></p>\n<h2 id=\"su-的使用\"><a href=\"#su-的使用\" class=\"headerlink\" title=\"su 的使用\"></a>su 的使用</h2><ul>\n<li><code>su</code>: 登录 root 用户</li>\n<li><code>su usr1</code>: 登录 usr1 用户</li>\n</ul>\n<h2 id=\"sudo-的使用\"><a href=\"#sudo-的使用\" class=\"headerlink\" title=\"sudo 的使用\"></a>sudo 的使用</h2><ul>\n<li><code>sudo -i</code>: 以 root 用户的名义登录</li>\n<li><code>sudo -i -u usr1</code>:以 usr1 用户的名义登录</li>\n</ul>\n<h2 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h2><ol>\n<li><a href=\"http://my.oschina.net/shuay/blog/53567\" target=\"_blank\" rel=\"external\">http://my.oschina.net/shuay/blog/53567</a></li>\n<li><a href=\"http://os.51cto.com/art/201307/404879.htm\" target=\"_blank\" rel=\"external\">http://os.51cto.com/art/201307/404879.htm</a></li>\n<li><a href=\"http://blog.csdn.net/u010749410/article/details/12711031\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/u010749410/article/details/12711031</a></li>\n<li><a href=\"http://www.aminglinux.com/bbs/thread-6899-1-1.html\" target=\"_blank\" rel=\"external\">http://www.aminglinux.com/bbs/thread-6899-1-1.html</a></li>\n</ol>\n","categories":[],"tags":["Android"]},{"title":"Android 性能优化：StrictMode","url":"http://xiazdong.github.io/2014/09/07/Android 性能优化：StrictMode/","content":"<h2 id=\"StrictMode\"><a href=\"#StrictMode\" class=\"headerlink\" title=\"StrictMode\"></a>StrictMode</h2><p>Android 2.3 引入了 <code>android.os.StrictMode</code>（Android 3.0 中又在 StrictMode 中新加入了几个方法），为了能够帮助开发者检测 “主线程” 或 “虚拟机” 的一些影响性能或者不良的代码，为了能够让应用更平滑、响应更快。当然如果你已经足够了解 android 最佳实践，完全可以忽略这个类。注意：这个类只在开发时使用，发布时请去除。</p>\n<blockquote>\n<p>目前 Android 4.0 以上的占有率为 84.3%，因此有很多应用直接 minSdk 设置为 14。因此一般不必考虑 StrictMode 中 API Level 的问题。</p>\n</blockquote>\n<p>StrictMode 共有两种策略(policy)：</p>\n<ul>\n<li>ThreadPolicy: 线程相关策略，包括主线程访问网络、磁盘(现在手机中使用闪存)读写、慢代码的检测。我们能够分别检测(detect)这些操作或允许(permit)这些操作。一旦出现了违规(violation)，就会有相应的提示（比如 Log 显示）。</li>\n<li>VMPolicy: 虚拟机相关的策略，包括 SQLite 或 SQLiteCursor 没关闭、实现 Closable 接口的类使用后没关闭 等。 </li>\n</ul>\n<p>当然也可以忽略某些违规，比如检测磁盘读写，因为一般来说在主线程中进行文件系统的读写是可以的。</p>\n<p>一旦我们在入口 Activity 的 <code>onCreate()</code> 的最前面添加 StrictMode 相关代码，则在整个程序中 StrictMode 都会有效。</p>\n<p>模版代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreate</span><span class=\"params\">(Bundle savedInstanceState)</span> </span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">if</span> (DEVELOPER_MODE) &#123;</div><div class=\"line\">        StrictMode.setThreadPolicy(<span class=\"keyword\">new</span> StrictMode.ThreadPolicy.Builder()</div><div class=\"line\">                    .detectAll()</div><div class=\"line\">                    .penaltyLog()</div><div class=\"line\">                    .build());</div><div class=\"line\">        StrictMode.setVmPolicy(<span class=\"keyword\">new</span> StrictMode.VmPolicy.Builder()</div><div class=\"line\">                    .detectLeakedSqlLiteObjects()</div><div class=\"line\">                    .detectLeakedClosableObjects()</div><div class=\"line\">                    .penaltyLog()</div><div class=\"line\">                    .penaltyDeath()</div><div class=\"line\">                    .build());</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">super</span>.onCreate(savedInstanceState);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>当然，为了方便，可以直接使用 <code>StrictMode.enableDefaults()</code> 启用 StrictMode。</p>\n<p>其实 ThreadPolicy 和 VMPolicy 差不多，<code>detectAll()</code> 表示检测全部的违规，<code>penaltyLog()</code> 表示当违规时打印 Log。</p>\n<blockquote>\n<ul>\n<li>对于 ThreadPolicy 来说，我们可以使用 <code>detectNetwork()</code> 检测主线程网络访问，<code>detectDiskReads()</code> 和 <code>detectDiskWrites()</code> 检测主线程磁盘读写，<code>detectCustomSlowCalls()</code> 检测主线程自定义的慢代码。当然也可以使用 <code>permitXXX()</code> 允许这些操作。</li>\n<li>对于 VMPolicy 来说，<code>detectLeakedSqliteObjects()</code> 检测 SQLite 和 SQLiteCursor 内存泄漏(没关闭)，<code>detectLeakedClosableObjects()</code> 检测实现 Closable 接口的对象内存泄漏。</li>\n<li>我们能通过 <code>StrictMode.getThreadPolicy()</code> 和 <code>StrictMode.getVMPolicy()</code> 获得当前采取的 ThreadPolicy 和 VMPolicy。</li>\n</ul>\n</blockquote>\n<h2 id=\"案例\"><a href=\"#案例\" class=\"headerlink\" title=\"案例\"></a>案例</h2><p>场景：从网络上下载一张图片并且在 ImageView 中显示。</p>\n<p>核心代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">ImageView imageView = (ImageView)findViewById(R.id.view);</div><div class=\"line\">    URL url = <span class=\"keyword\">null</span>;</div><div class=\"line\">    Bitmap bmp = <span class=\"keyword\">null</span>;</div><div class=\"line\">    <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">        url = <span class=\"keyword\">new</span> URL(<span class=\"string\">\"http://www.tencent.com/1.jpg\"</span>);</div><div class=\"line\">        bmp = BitmapFactory.decodeStream(url.openConnection().getInputStream());</div><div class=\"line\">    &#125;<span class=\"keyword\">catch</span>(Exception e)&#123;</div><div class=\"line\">        e.printStackTrace();</div><div class=\"line\">    &#125;<span class=\"keyword\">finally</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span>(bmp!=<span class=\"keyword\">null</span>)&#123;</div><div class=\"line\">            imageView.setImageBitmap(bmp);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>\n<p>这段代码一运行，StrictMode 就出现了一堆建议：</p>\n<p>1、 根据下面的 log 可以看出查找域名花费了 446 ms。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">D/StrictMode﹕ StrictMode policy violation; ~duration=446 ms: android.os.StrictMode$StrictModeNetworkViolation: policy=63 violation=4</div><div class=\"line\">        at android.os.StrictMode$AndroidBlockGuardPolicy.onNetwork(StrictMode.java:1184)</div><div class=\"line\">        at java.net.InetAddress.lookupHostByName(InetAddress.java:394)</div><div class=\"line\">        ...</div><div class=\"line\">        at libcore.net.http.HttpURLConnectionImpl.getInputStream(HttpURLConnectionImpl.java:168)</div><div class=\"line\">        at info.xiazdong.performanceoptimization.MainActivity.onCreate(MainActivity.java:33)</div><div class=\"line\">        ...</div></pre></td></tr></table></figure>\n<p>2、连接服务器花费 377 ms。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">D/StrictMode﹕ StrictMode policy violation; ~duration=377 ms: android.os.StrictMode$StrictModeNetworkViolation: policy=63 violation=4</div><div class=\"line\">        at android.os.StrictMode$AndroidBlockGuardPolicy.onNetwork(StrictMode.java:1184)</div><div class=\"line\">        at libcore.io.BlockGuardOs.connect(BlockGuardOs.java:84)</div><div class=\"line\">        at libcore.io.IoBridge.connectErrno(IoBridge.java:127)</div><div class=\"line\">        at libcore.io.IoBridge.connect(IoBridge.java:112)</div><div class=\"line\">        ...</div><div class=\"line\">        at libcore.net.http.HttpURLConnectionImpl.getInputStream(HttpURLConnectionImpl.java:168)</div><div class=\"line\">        at info.xiazdong.performanceoptimization.MainActivity.onCreate(MainActivity.java:36)</div><div class=\"line\">        ...</div></pre></td></tr></table></figure>\n<p>3、 解码图片花费了 205 ms。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">D/StrictMode﹕ StrictMode policy violation; ~duration=205 ms: android.os.StrictMode$StrictModeNetworkViolation: policy=63 violation=4</div><div class=\"line\">        at android.os.StrictMode$AndroidBlockGuardPolicy.onNetwork(StrictMode.java:1184)</div><div class=\"line\">        at libcore.io.BlockGuardOs.recvfrom(BlockGuardOs.java:163)</div><div class=\"line\">        at libcore.io.IoBridge.recvfrom(IoBridge.java:503)</div><div class=\"line\">        at java.net.PlainSocketImpl.read(PlainSocketImpl.java:488)</div><div class=\"line\">        ...</div><div class=\"line\">        at android.graphics.BitmapFactory.decodeStream(BitmapFactory.java:791)</div><div class=\"line\">        at info.xiazdong.performanceoptimization.MainActivity.onCreate(MainActivity.java:36)</div><div class=\"line\">        ...</div></pre></td></tr></table></figure>\n<p>因此访问网络的操作都建议在子线程中进行，绝对不能在主线程进行。</p>\n<blockquote>\n<p>现在手机的像素越来越高，魅族4的相机像素达到 2070 万，拍出照片的尺寸是 5248 <em> 3936，如果这张照片是 ARGB_8888 类型的位图，则放在内存中将占据：2070 </em> 4 字节，约 78M，即使手机有足够内存放这张图片，在主线程解码(decode)也需要花费不少时间，因此一般这种耗时的操作都在子线程中进行，比如使用 AsyncTask（因为屏幕像素和相机像素差距比较大，因此一般都不会原图显示，因为手机上显示一张高清图片没有什么价值）</p>\n</blockquote>\n<h2 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h2><ul>\n<li><a href=\"http://developer.android.com/reference/android/os/StrictMode.html\" target=\"_blank\" rel=\"external\">Android Reference: StrictMode</a></li>\n<li><a href=\"http://hb.qq.com/a/20110914/000054.htm\" target=\"_blank\" rel=\"external\">Android最佳实践之：StrictMode介绍</a></li>\n</ul>\n","categories":[],"tags":["Android"]},{"title":"ACM常用算法","url":"http://xiazdong.github.io/2012/11/04/ACM常用算法/","content":"<p><img src=\"https://raw.githubusercontent.com/xiazdong/blog-image/master/acm_alg.jpg\" alt=\"\"></p>\n","categories":[],"tags":["算法"]},{"title":"about","url":"http://xiazdong.github.io/about/index.html","content":"","categories":[],"tags":[]},{"title":"search","url":"http://xiazdong.github.io/search/index.html","content":"","categories":[],"tags":[]},{"title":"tag","url":"http://xiazdong.github.io/tag/index.html","content":"","categories":[],"tags":[]},{"title":"category","url":"http://xiazdong.github.io/category/index.html","content":"","categories":[],"tags":[]}]