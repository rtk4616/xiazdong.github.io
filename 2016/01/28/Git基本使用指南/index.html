<!DOCTYPE html>


  <html class="light page-post">


<head>
  <meta charset="utf-8">
  
  <title>Git基本使用指南 | xiazdong</title>

  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
    <meta name="keywords" content="Git," />
  

  <meta name="description" content="前言本人接触 Git 也有两年了，但是之前只是草草学习，没有很好的掌握他，主要原因是没有工作需要(在学校里面哪用的到Git…)。我觉得 Git 这个工具在学校里很难充分了解到他，只有在公司里十几个人一起开发项目时才会感觉到他的优越性。 作为一个程序员，学习 Git 的原因有两个：  在工作中一个项目肯定要多人完成，多人协作开发再正常不过了。 Github 越来越火，要用 Github 就必须要会">
<meta name="keywords" content="Git">
<meta property="og:type" content="article">
<meta property="og:title" content="Git基本使用指南">
<meta property="og:url" content="http://xiazdong.github.io/2016/01/28/Git基本使用指南/index.html">
<meta property="og:site_name" content="xiazdong">
<meta property="og:description" content="前言本人接触 Git 也有两年了，但是之前只是草草学习，没有很好的掌握他，主要原因是没有工作需要(在学校里面哪用的到Git…)。我觉得 Git 这个工具在学校里很难充分了解到他，只有在公司里十几个人一起开发项目时才会感觉到他的优越性。 作为一个程序员，学习 Git 的原因有两个：  在工作中一个项目肯定要多人完成，多人协作开发再正常不过了。 Github 越来越火，要用 Github 就必须要会">
<meta property="og:image" content="http://i.imgur.com/OitUnUF.png">
<meta property="og:image" content="http://i.imgur.com/bKD9cri.png">
<meta property="og:image" content="https://cloud.githubusercontent.com/assets/1319791/7051226/c4570828-ddf4-11e4-87eb-8fc165e5ece4.gif">
<meta property="og:updated_time" content="2017-05-16T13:58:22.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Git基本使用指南">
<meta name="twitter:description" content="前言本人接触 Git 也有两年了，但是之前只是草草学习，没有很好的掌握他，主要原因是没有工作需要(在学校里面哪用的到Git…)。我觉得 Git 这个工具在学校里很难充分了解到他，只有在公司里十几个人一起开发项目时才会感觉到他的优越性。 作为一个程序员，学习 Git 的原因有两个：  在工作中一个项目肯定要多人完成，多人协作开发再正常不过了。 Github 越来越火，要用 Github 就必须要会">
<meta name="twitter:image" content="http://i.imgur.com/OitUnUF.png">

  

  
    <link rel="icon" href="/favicon.ico">
  

  <link href="/css/styles.css?v=c114cbe6" rel="stylesheet">


  
    <link rel="stylesheet" href="/css/personal-style.css">
  

  

  

  


  
    <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
  

  
    <link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.3.0/css/font-awesome.min.css">
  
</head>

<body>


  
    <span id="toolbox-mobile" class="toolbox-mobile">盒子</span>
  

  <div class="post-header CENTER">
   
  <div class="toolbox">
    <a class="toolbox-entry" href="/">
      <span class="toolbox-entry-text">盒子</span>
      <i class="icon-angle-down"></i>
      <i class="icon-home"></i>
    </a>
    <ul class="list-toolbox">
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/archives/"
            rel="noopener noreferrer"
            target="_self"
            >
            博客
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/tag/"
            rel="noopener noreferrer"
            target="_self"
            >
            分类
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/about/"
            rel="noopener noreferrer"
            target="_self"
            >
            关于
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/atom.xml"
            rel="noopener noreferrer"
            target="_blank"
            >
            RSS
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/search/"
            rel="noopener noreferrer"
            target="_self"
            >
            搜索
          </a>
        </li>
      
    </ul>
  </div>


</div>


  <div id="toc" class="toc-article">
    <strong class="toc-title">文章目录</strong>
    <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#前言"><span class="toc-text">前言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Git-基本概念"><span class="toc-text">Git 基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Git-配置"><span class="toc-text">Git 配置</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#命令自动补全"><span class="toc-text">命令自动补全</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#修改默认编辑器"><span class="toc-text">修改默认编辑器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HTTP-访问-Git-Server-免输入密码"><span class="toc-text">HTTP 访问 Git Server 免输入密码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Git-的基本组成部分"><span class="toc-text">Git 的基本组成部分</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#文件的状态"><span class="toc-text">文件的状态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Git-提交历史"><span class="toc-text">Git 提交历史</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Git-命令"><span class="toc-text">Git 命令</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#基本命令"><span class="toc-text">基本命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#版本撤销或回退"><span class="toc-text">版本撤销或回退</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#分支"><span class="toc-text">分支</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#patch相关命令"><span class="toc-text">patch相关命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#远程仓库相关"><span class="toc-text">远程仓库相关</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Github-相关"><span class="toc-text">Github 相关</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-Github-基本概念"><span class="toc-text">1. Github 基本概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-给开源项目贡献代码"><span class="toc-text">2. 给开源项目贡献代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-Github-Flow"><span class="toc-text">3. Github Flow</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-Github-支持-Git-LFS"><span class="toc-text">4. Github 支持 Git LFS</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Gist"><span class="toc-text">Gist</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Gitter"><span class="toc-text">Gitter</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Tig"><span class="toc-text">Tig</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#参考文献"><span class="toc-text">参考文献</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#附：视频教程"><span class="toc-text">附：视频教程</span></a></li></ol>
  </div>



<div class="content content-post CENTER">
   <article id="post-Git基本使用指南" class="article article-type-post" itemprop="blogPost">
  <header class="article-header">
    <h1 class="post-title">Git基本使用指南</h1>

    <div class="article-meta">
      <span>
        <i class="icon-calendar"></i>
        <span>2016.01.28</span>
      </span>

      
        <span class="article-author">
          <i class="icon-user"></i>
          <span>xiazdong</span>
        </span>
      

      


      

      
      <i class="fa fa-eye"></i> 
        <span id="busuanzi_container_page_pv">
           &nbsp热度 <span id="busuanzi_value_page_pv">
           <i class="fa fa-spinner fa-spin"></i></span>℃
        </span>
      

      
      
    </div>
  </header>

  <div class="article-content">
    
      <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本人接触 Git 也有两年了，但是之前只是草草学习，没有很好的掌握他，主要原因是没有工作需要(在学校里面哪用的到Git…)。我觉得 Git 这个工具在学校里很难充分了解到他，只有在公司里十几个人一起开发项目时才会感觉到他的优越性。</p>
<p>作为一个程序员，学习 Git 的原因有两个：</p>
<ol>
<li>在工作中一个项目肯定要多人完成，多人协作开发再正常不过了。</li>
<li>Github 越来越火，要用 Github 就必须要会 Git。</li>
</ol>
<p>因此 Git 目前已经是一个软件开发人员默认的必会技能。</p>
<p>在工作中一般首选是用 Git 的 GUI 工具来操作 Git(这里推荐 Tower，用起来特别顺手；Github Desktop 也不错， Sourcetree 用的人也非常多，而且跨平台)，因为在工作中一个项目一天的提交量超过200是很正常的，如果你要看今天哪些人提交了、提交了哪些内容，用命令行 <code>git log</code> 就很费劲，图形化界面的展示就看起来舒服很多。</p>
<p>很多人说：用命令行看起来多帅啊。但是解决问题是第一位，你只要了解了 Git 的操作原理，用图形化界面能够更清晰地完成你的工作。</p>
<blockquote>
<p>我一般为了让自己不忘记 git 命令，都用命令行。</p>
</blockquote>
<p>本文会按照以下顺序介绍：</p>
<ul>
<li>Git 基本概念。</li>
<li>Git 基本命令、分支命令、撤销命令、合并命令、patch命令、远程仓库命令。</li>
<li>Github, Github Flow, Gist, Tig, Gitter。</li>
</ul>
<p>本文所用的软件或平台包括：</p>
<ol>
<li>MAC </li>
<li>Git + Github</li>
<li>Tower 2.1.0</li>
<li>Beyond Compare 4</li>
</ol>
<blockquote>
<p>Git 是 Global Information Tracker 的缩写，即对全局信息进行跟踪。</p>
</blockquote>
<p>等到阅读完本文，可以通过 <a href="http://pcottle.github.io/learnGitBranching/" target="_blank" rel="external">Learn Git Branching</a> 验证下自己是不是真的学会了 Git。</p>
<h2 id="Git-基本概念"><a href="#Git-基本概念" class="headerlink" title="Git 基本概念"></a>Git 基本概念</h2><blockquote>
<p>Linus Torvalds 在 Google Talk 上做的关于 Git 的演讲：<a href="https://www.youtube.com/watch?v=4XpnKHJAok8" target="_blank" rel="external">这里</a>，笔记见<a href="http://blog.tizgrape.com/linus-torvalds%E5%9C%A8google-talk%E4%B8%8A%E5%81%9A%E7%9A%84git%E6%BC%94%E8%AE%B2/" target="_blank" rel="external">这里</a>。</p>
</blockquote>
<h3 id="Git-配置"><a href="#Git-配置" class="headerlink" title="Git 配置"></a>Git 配置</h3><p>在使用 Git 之前需要做2件事：</p>
<ol>
<li>配置 UserName(<code>git config --global user.name &quot;&lt;name&gt;&quot;</code>), Email(<code>git config --global user.email &lt;email&gt;</code>)。</li>
<li>如果要连接远程代码托管网站(如 Github)，则需要生成 SSH 协议的 RSA 密钥和公钥。</li>
</ol>
<h4 id="命令自动补全"><a href="#命令自动补全" class="headerlink" title="命令自动补全"></a>命令自动补全</h4><p>为了让 Git 在 bash 中拥有类似 bash 的提示功能，比如输入 <code>git co</code>，再按两下 tab，则会提示可用命令有 <code>commit, config</code>，我们可以如下配置：</p>
<ul>
<li>下载 <a href="https://github.com/git/git/blob/master/contrib/completion/git-completion.bash" target="_blank" rel="external">git-completion.bash</a> 文件放到用户主目录。</li>
<li>在 <code>.bash_profile</code> 中添加 <code>source ~/git-completion.bash</code>。</li>
</ul>
<h4 id="修改默认编辑器"><a href="#修改默认编辑器" class="headerlink" title="修改默认编辑器"></a>修改默认编辑器</h4><p>默认 git 使用的编辑器是vim，如果想改成 sublime text，则步骤如下：</p>
<ul>
<li>在用户的工作目录创建 bin 目录。 </li>
<li>命令行执行 <code>ln -s &quot;/Applications/Sublime Text.app/Contents/SharedSupport/bin/subl&quot; ~/bin/subl</code></li>
<li>将 <code>~/bin/subl</code> 添加到环境变量 PATH 中(.zshrc 或 .bashrc 中)。</li>
<li>命令行执行 <code>git config --global core.editor &quot;subl -n -w&quot;</code>。</li>
</ul>
<p>但是个人使用下来还是用 vim 作为默认编辑器体验最好，因为一直在命令行里面操作比较流畅。</p>
<h4 id="HTTP-访问-Git-Server-免输入密码"><a href="#HTTP-访问-Git-Server-免输入密码" class="headerlink" title="HTTP 访问 Git Server 免输入密码"></a>HTTP 访问 Git Server 免输入密码</h4><p>本小节参考：</p>
<ul>
<li>安装 wget: 从 “<a href="http://ftp.gnu.org/gnu/wget/" target="_blank" rel="external">http://ftp.gnu.org/gnu/wget/</a>“ 下载解压文件，并依次执行：<code>./configure --with-ssl=openssl</code>, <code>make</code>, <code>sudo make install</code>。</li>
<li>下载 git-credential-netrc 脚本：<code>wget https://raw.githubusercontent.com/git/git/master/contrib/credential/netrc/git-credential-netrc</code></li>
<li>git-credential-netrc 脚本拥有执行权限：<code>chmod +x git-credential-netrc</code></li>
<li>将该脚本拷贝到 bin 目录(即放入 PATH 环境变量中)：<code>cp git-credential-netrc ~/bin/</code>。</li>
<li>在用户目录下创建 .netrc 文件，内容为：</li>
</ul>
<p>模板如下：</p>
<pre><code>machine &lt;git-server-host&gt;  # 比如 github.com
login &lt;account&gt;
password &lt;your-password&gt;
protocol http
</code></pre><ul>
<li>对 .netrc 文件控制权限，因为里面有密码：<code>sudo chmod 0600 .netrc</code></li>
<li>git 配置：<code>git config --global credential.helper &quot;~/bin/git-credential-netrc&quot;</code>。</li>
<li>安装 GPG 命令：<code>sudo port install gnupg gnupg2</code>。</li>
<li>生成 GPG key：<code>gpg --gen-key</code>。</li>
<li>查看你的 GPG key: <code>gpg --list-keys</code></li>
<li>用 GPG 密钥加密 .netrc 文件：<code>gpg -e -r &lt;你的gpg key&gt; .netrc</code><br><a href="http://www.sunzhongwei.com/http-git-server-without-password.html" target="_blank" rel="external">http://www.sunzhongwei.com/http-git-server-without-password.html</a></li>
</ul>
<h3 id="Git-的基本组成部分"><a href="#Git-的基本组成部分" class="headerlink" title="Git 的基本组成部分"></a>Git 的基本组成部分</h3><ul>
<li><strong>工作目录</strong>(working directory): 你在文件管理器中看得到的目录就是工作目录。 </li>
<li><strong>暂存区</strong>(Stage Area or Index)。</li>
<li><strong>本地仓库</strong>(Local Repository): Git 是分布式的版本控制系统，本地仓库就是本地的一个备份仓库。</li>
<li><strong>远程仓库</strong>(Remote Repository): Github 中托管的(不是在本地的)仓库。</li>
</ul>
<blockquote>
<p>目前有很多 Git 仓库的托管网站，国外有 Github, Bitbucket，国内有 Gitcafe, Coding.net，功能或许有些许区别，但是建议使用 Github，因为 Github 的知名度最高，而且著名的开源项目都会放在这托管，况且目前 Github 还没被封，即使被封了，最好也不要用国内的，原因1是指不定哪一天公司倒闭了，还要转移项目，多麻烦；原因2是 Github 生态圈已经构成，就像微信和来往功能可能差不多，但是你朋友全在用微信，你会用来往的概率大吗？当然为了熟悉 Git 的基本使用，用 Gitcafe, Coding.net 也是不错的选择，因为毕竟速度更快。</p>
<p>Github 提供<a href="https://education.github.com/" target="_blank" rel="external">学生特权</a>，包括免费 <code>.me</code> 的域名(小伙伴再也不用担心没有个人域名了)、让你的 Github 账号拥有5个私有仓库等。</p>
</blockquote>
<h3 id="文件的状态"><a href="#文件的状态" class="headerlink" title="文件的状态"></a>文件的状态</h3><p>工作目录中的文件共有几种常见状态：</p>
<ul>
<li><strong>Untracked</strong>: 未跟踪的，表示该文件没有被 Git 管理。</li>
<li><strong>Unmodified</strong>: 被 Git 跟踪但工作目录中该文件没有被修改过。</li>
<li><strong>Modified</strong>: 在工作目录中，该文件被改过了，但还没被加入暂存区。</li>
<li><strong>Staged</strong>: 工作目录中文件被修改，并且已被加入暂存区。</li>
<li><strong>Deleted</strong>: 工作目录中某个文件被删除，但是把这个删除操作还没提交到本地仓库。</li>
<li><strong>Unmerged</strong>: 当文件处于冲突时的状态。</li>
</ul>
<h3 id="Git-提交历史"><a href="#Git-提交历史" class="headerlink" title="Git 提交历史"></a>Git 提交历史</h3><p>Git 提交的历史构成了一个有向无环图，每个节点是一个提交对象(Commit Object,其中包含SHA-1码、提交人的名字、提交人的邮箱、日期等)，每条边表示提交的顺序，比如 <code>u--&gt;v</code>，表示 <code>v</code> 是父节点，<code>u</code> 是子节点，即 <code>u</code> 是 <code>v</code> 的后一次提交，如下图：</p>
<p><img src="http://i.imgur.com/OitUnUF.png" width="700"></p>
<p>上图中可以看出：</p>
<ul>
<li>红色的如 <code>master</code>, <code>testing</code> 是</li>
<li>分支名，我们可以在 <code>.git/refs/heads</code> 下看到有 <code>master</code> 和 <code>testing</code> 两个文件名(这是分支的实现方式，下文还会讲到)。</li>
<li>HEAD 是一个指针，一般指向一个分支名(从图中也可以看出)，表示的是最后一次提交，实现方法是在 <code>.git/</code> 目录下有个 <code>HEAD</code> 文件，里面包含了他指向的分支名，比如 <code>ref: refs/heads/master</code>，但是 HEAD 指针也可以指向一个提交(<code>.git/HEAD</code> 文件的内容是一次提交的 HASH 值)，称为”detached HEAD”(分离式 HEAD)。</li>
</ul>
<blockquote>
<p><a href="https://github.com/esc/git-big-picture" target="_blank" rel="external">Git Big Picture</a> 是拓展命令，可以以图片格式输出整个 Git 树。</p>
<p>Git 中 author 与 commitor 的区别：对于一个开源项目，如果你要贡献一段代码，你就是 author，帮你提交进项目的人就是 commitor。</p>
</blockquote>
<p>在公司中，如果要提交到公司内的 gitlab，需要使用公司邮箱，如果在提交中带有私人邮箱的提交，则会 push 不上去。经常遇到的问题是你在开发公司的项目，但是用的是私人邮箱提交，等到发现的时候已经来不及了。那怎么对过去的提交批量修改邮箱配置呢？在命令行执行下面命令即可：</p>
<pre><code>git filter-branch -f --env-filter &quot;GIT_AUTHOR_NAME=&apos;&lt;new_name&gt;&apos;; GIT_AUTHOR_EMAIL=&apos;&lt;new_email&gt;&apos;;&quot; HEAD
</code></pre><h2 id="Git-命令"><a href="#Git-命令" class="headerlink" title="Git 命令"></a>Git 命令</h2><p>下面介绍的命令都是在 Git 中很常用的，这些命令的含义也是必须要搞清楚的，当然这些命令在 Tower 中也能实现，所以平时工作可以使用 Tower 完成，没必要再用命令行。</p>
<h3 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h3><ul>
<li><code>git status</code>: 查看当前状态，包括当前处于哪个分支、有哪些修改的文件没加入暂存区、哪些修改的文件加入了暂存区但没提交。</li>
<li><code>git add &lt;file&gt;</code>: 将 <code>&lt;file&gt;</code> 加入跟踪或将修改添加到暂存区。</li>
<li><code>git add -A &lt;file&gt;</code>: 如果 <code>&lt;file&gt;</code> 被删除了，想把这个删除的改变提交上去，那么用上面的命令添加会失败，因此加 <code>-A</code>，表示将工作区对 <code>&lt;file&gt;</code> 的所有修改都提交到暂存区。因此删除文件建议使用 <code>git rm</code>，而不是从文件管理器直接删除。</li>
<li><code>git add -p &lt;file&gt;</code>: 交互式地对 <code>&lt;file&gt;</code> 文件的部分内容进行暂存，而不是一起暂存。具体参见 <a href="http://www.oschina.net/translate/10-tips-git-next-level?cmp" target="_blank" rel="external">这里</a></li>
<li><code>git commit -m &lt;message&gt;</code>: 将暂存区的内容提交到本地仓库。</li>
<li><code>git commit --amend</code>: 当你对上次提交不满意(比如漏了提交2个文件，或者多提交了文件，或者对提交输入的 message 不满意)，想重新提交，则使用 <code>--amend</code> 参数，效果是将暂存区的内容提交，并覆盖上次的提交。</li>
<li><code>git commit -am &lt;message&gt;</code>: 多了 <code>-a</code> 参数，跳过 <code>git add</code> 命令直接提交。</li>
<li><code>git commit --fixup &lt;SHA-1&gt;</code>: 创建一个新的提交，专门修复较早期 <code>&lt;SHA-1&gt;</code> 提交(比如有个文件忘提交了)，新提交的 commit message 和 <code>&lt;SHA-1&gt;</code> 的一样。</li>
<li><code>git commit --squash &lt;SHA-1&gt;</code>: 和 <code>git commit --fixup &lt;SHA-1&gt;</code> 作用一样，只是新提交的 commit message 不是 <code>&lt;SHA-1&gt;</code> 的 commit message，而是自定义 commit message，默认是 <code>!squash &lt;eariler commit message&gt;</code>。</li>
<li><code>git mv &lt;old&gt; &lt;new&gt;</code>: 将文件重命名(这里注意，不能手动直接改文件名哦！)，但是在本地仓库中还没生效，直到 <code>git commit</code> 之后才生效。  </li>
<li><code>git diff &lt;file&gt;</code>: 查看工作目录和暂存区中 <code>&lt;file&gt;</code> 的区别。</li>
<li><code>git diff --cached &lt;file&gt;</code>: 查看暂存区和本地仓库中 <code>&lt;file&gt;</code> 的区别。</li>
<li><code>git diff &lt;SHA1&gt; &lt;SHA2&gt;</code>: 比较两次提交(<code>&lt;SHA1&gt;</code> 和 <code>&lt;SHA2&gt;</code>)的区别。</li>
<li><code>git diff &lt;branch&gt; &lt;file&gt;</code>: 查看分支 <code>&lt;branch&gt;</code> 中的 <code>&lt;file&gt;</code> 和工作目录的 <code>&lt;file&gt;</code> 的区别。</li>
<li><code>git log</code>: 查看提交的历史，包括提交的 SHA-1 码、谁提交了、什么时候提交的。</li>
<li><code>git log --pretty=oneline</code>: 更简洁地显示提交历史，每个提交都只有一行，只显示 SHA-1 和 commit message。</li>
<li><code>git blame &lt;file&gt;</code>: 查看 <code>&lt;file&gt;</code> 文件的每行是谁修改的，blame是责怪的意思，因此这个命令用来找罪魁祸首用。</li>
<li><code>git show &lt;commit-id&gt;</code>: 显示 <code>&lt;commit-id&gt;</code> 的具体修改。</li>
</ul>
<blockquote>
<p><code>.git/ORIG_HEAD</code> 文件的内容是一次提交的HASH值，他也是一个指针，指针名叫 “ORIG_HEAD”，当git进行一些危险操作比如merge，reset等时，git就会把进行危险操作之前的HEAD指针指向的提交保存到ORIG_HEAD中，以便用户后悔了，想恢复。</p>
</blockquote>
<p>一般在公司开发项目，tag 肯定会使用，比如在2015年8月12日要发 1.0 版本，那么到了那个时候，就会在某个提交处打上 v1.0 的 tag。</p>
<p>tag 分为 lightweight tag(轻量级标签，只是指向一个提交，并不带任何 message)和annotated tag(带注释标签，标签带有注释)。所有标签都存放在 <code>.git/refs/tags</code> 目录中，每个标签是一个文件，如果是轻量级标签，则内容是提交的 HASH 值；如果是带注释标签，则内容是 Object 值。</p>
<ul>
<li><code>git tag</code>: 显示所有标签。</li>
<li><code>git tag &lt;name&gt;</code>: 创建一个轻量级标签 <code>&lt;name&gt;</code>，并指向 HEAD。</li>
<li><code>git tag &lt;name&gt; &lt;commit-id&gt;</code>: 创建一个轻量级标签 <code>&lt;name&gt;</code>，并指向 <code>&lt;commit-id&gt;</code>。</li>
<li><code>git tag -a &lt;name&gt; -m &lt;message&gt;</code>: 创建一个带注释标签 <code>&lt;name&gt;</code>，他有注释 <code>&lt;message&gt;</code>。</li>
<li><code>git show &lt;tag-name&gt;</code>: 查看 <code>&lt;tag-name&gt;</code> 标签的详细信息。</li>
<li><code>git push --tags</code>: 将所有 tag 提交到远程仓库，因为默认的 <code>git push</code> 并不会提交 tag。</li>
<li><code>git tag -d &lt;name&gt;</code>: 删除本地 tag。</li>
<li><code>git push origin :refs/tags/&lt;name&gt;</code>: 将本地删除的名为 <code>&lt;name&gt;</code> 的 tag 推送到远程仓库。</li>
</ul>
<p>接下来介绍一个不太常用的命令：<code>git bisect</code> 相关命令，该命令主要用来排查某个未知时段出现的问题，假设你现在的代码是编译不过的(提交树为 <code>c1-&gt;c2-&gt;c3-&gt;c4-&gt;c5-&gt;c6</code>，当前提交是 c6)，你又不知道什么时候引入错误的，你唯一确定的是在 c1 提交的时候代码还是编译通过的，此时可以使用 <code>git bisect</code>，该命令的主要思想是通过二分查找的方法在提交树上确定问题发生在哪个提交上，并联系提交者。以前面的例子为例，我们执行下列命令：</p>
<pre><code>git bisect start   # 开始二分查找问题
git bisect good c1 # c1 提交的时候代码还是好的
git bisect bad c6  # c6 提交的时候代码有问题
</code></pre><p>运行完上面命令后，git 会进入 c1 到 c6 的中间提交状态，这里是 c4，当你发现 c4 提交代码还是好的，则执行 <code>git bisect good</code>，那么可以确定问题一定发生在 c5 到 c6 之间；如果 c4 提交代码是坏的，则执行 <code>git bisect bad</code>，那么可以确定问题一定发生在 c2 到 c4 之间；以此类推，通过二分查找的方法，能够更快的定位问题。</p>
<p>定位完问题后，执行 <code>git bisect reset</code> 可以恢复执行 <code>git bisect start</code> 之前的状态。</p>
<blockquote>
<p><a href="http://gitbook.liuhui998.com/5_4.html" target="_blank" rel="external">查找问题的利器 - Git Bisect</a></p>
</blockquote>
<h3 id="版本撤销或回退"><a href="#版本撤销或回退" class="headerlink" title="版本撤销或回退"></a>版本撤销或回退</h3><ul>
<li><code>git checkout &lt;file&gt;</code>: 丢弃工作目录对 <code>&lt;file&gt;</code> 的修改，并用暂存区的 <code>&lt;file&gt;</code> 替换。</li>
<li><code>git checkout HEAD &lt;file&gt;</code>: 将工作目录和暂存区的 <code>&lt;file&gt;</code> 用 HEAD 指针指向的 <code>&lt;file&gt;</code> 替换。</li>
<li><code>git checkout &lt;branch&gt; &lt;file&gt;</code>: 用分支 <code>&lt;branch&gt;</code> 中的 <code>&lt;file&gt;</code> 替换工作目录和暂存区的 <code>&lt;file&gt;</code>。</li>
<li><code>git rm &lt;file&gt;</code>: 删除工作目录和暂存区的 <code>&lt;file&gt;</code>，但是本地仓库没有影响，只有 <code>git commit</code> 才会从本地仓库中删除 <code>&lt;file&gt;</code>。因此如果你想删除一个文件，不要在文件管理器里删除，而要用 <code>git rm</code>。</li>
<li><code>git rm --cached &lt;file&gt;</code>: 取消对 <code>&lt;file&gt;</code> 的跟踪，但是对于工作目录、本地仓库中和远程仓库中 <code>&lt;file&gt;</code> 的状态不会变化，只是在暂存区中删除 <code>&lt;file&gt;</code>。</li>
<li><code>git reset HEAD &lt;file&gt;</code>: 将暂存区中的 <code>&lt;file&gt;</code> 用本地仓库的 HEAD 指针中 <code>&lt;file&gt;</code> 的状态替换，并将原本在暂存区中 <code>&lt;file&gt;</code> 的修改变为未暂存状态。 </li>
<li><code>git reset --hard &lt;SHA-1&gt;</code>: 将工作目录和暂存区的状态回到 <code>&lt;SHA-1&gt;</code>。</li>
<li><code>git reset --soft &lt;SHA-1&gt;</code>: 工作目录和暂存区内容不变，仅仅将 HEAD 指向 <code>&lt;SHA-1&gt;</code>。这个命令的使用场景：我在公司里面使用内部的 Gitlab，你如果要 push，则必须 <code>git config</code> 的邮箱配成公司邮箱才行，但是我一开始用我的私人邮箱进行了一次提交，就后悔了，因为一旦包含这次提交，我就不能把代码 push 到公司 Gitlab 上了。这时候想要丢弃这次提交，但是又想要工作目录仍然保存我最新修改的代码，这时候可以用 <code>git reset --soft</code>。</li>
<li><code>git revert HEAD</code>: 生成新的提交，新的提交中撤销 HEAD 指向提交的修改内容。revert 表示”恢复”的意思，但是 “git revert” 和 “git reset” 的区别是：”git reset” 只是修改 HEAD 指针，而 “git revert” 是生成一个新的提交，比如 HEAD 指向的提交中添加了一行，那么在 “git revert” 生成的新的提交中删除该行，即 revert 某个提交实际上就是将原本添加的变成删除，将原本删除的变成添加。</li>
<li><code>git revert &lt;commit-id&gt;</code>: 生成新的提交，新的提交中撤销 <code>&lt;commit-id&gt;</code> 提交的内容，撤销方法和上面一样，即 <code>&lt;commit-id&gt;</code> 提交中添加的，在新的提交中就删除。</li>
<li><code>git reflog</code>: 显示 HEAD 指针曾经指向的所有提交，在<code>.git/logs/HEAD</code>文件中保存了HEAD这个列表。使用场景：找回丢失的提交(比如 <code>git reset --hard</code> 后悔了，但你又通过 <code>git log</code> 找不到原来的提交了，那么就可以使用 <code>git reflog</code>)。</li>
</ul>
<blockquote>
<p>如果理解不了 <code>git checkout</code> 和 <code>git reset</code> 命令，可以看<a href="http://marklodato.github.io/visual-git-guide/" target="_blank" rel="external">图解Git</a>，里面讲的非常清楚，讲清楚了很多教程中忽略的问题。</p>
</blockquote>
<p><code>git checkout</code> 适用于文件级别的撤销，<code>git reset --hard</code> 适用于仓库级别的撤销。</p>
<h3 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h3><p>Git 的分支非常轻量级，实现方法是每个分支对应 <code>.git/refs/heads/</code> 目录下的一个文件，每个文件只包含一个 SHA-1 码，表示提交ID，比如文件<code>testing</code> 的内容是 <code>6c35ebf175daff89f32b9123529fe22d93d1d8d9</code>，因此一个分支名指向一个提交对象。</p>
<blockquote>
<p>因此鼓励 <strong>早点建分支，经常建分支</strong>。</p>
</blockquote>
<p>分支的合并主要采用<strong>三方合并</strong>：比如当前分支是 <code>master</code>，执行 <code>git merge testing</code>，表示将 <code>master</code>，<code>testing</code> 以及这两个分支的公共祖先进行三方合并。</p>
<p>特性分支(Topic Branch): 用于实现某个单一功能而存在的分支。比如有一个项目，他有3个功能，我们就开3个特性分支。</p>
<p>分支的合并主要有两种方法：merge 和 rebase，各有特色，rebase 能够形成更加线性的提交历史。</p>
<blockquote>
<p>使用 rebase 要遵循一个规则：永远不要衍合那些已经推送到远程仓库的提交，即比如你现在在本地完成了一个功能，最新的提交为01234，你把它推送到远程仓库之后，那么你就不能再衍合01234这个提交了，因为这会导致其他人的混乱。</p>
</blockquote>
<ul>
<li><code>git branch &lt;name&gt;</code>: 保留本地目录、暂存区的修改，并创建名为 <code>&lt;name&gt;</code> 的分支（即创建一个指针，指向 HEAD 指针指向的分支对应的提交）。</li>
<li><code>git checkout &lt;branch&gt;</code>: 将 HEAD 指针指向 <code>&lt;branch&gt;</code> 分支名，即当前分支为 <code>&lt;branch&gt;</code>。</li>
<li><code>git checkout &lt;commit-id&gt;</code>: 将 HEAD 指针指向 <code>&lt;commit-id&gt;</code> 提交(一般 HEAD 指针都是指向分支名的)，形成 detached HEAD。</li>
<li><code>git checkout -b &lt;name&gt;</code>: 创建分支 <code>&lt;name&gt;</code>，并将 HEAD 指针指向 <code>&lt;name&gt;</code> 分支，等价于(1)<code>git branch &lt;name&gt;</code>(2)<code>git checkout &lt;name&gt;</code>。</li>
<li><code>git branch -d &lt;name&gt;</code>: 删除分支 <code>&lt;name&gt;</code>(其实只是删除分支文件而已)。</li>
<li><code>git branch -D &lt;name&gt;</code>: 强力删除分支 <code>&lt;name&gt;</code>(Git 会自己判断是不是可以删除分支，和 <code>-d</code> 的区别是如果 Git 判断不能删除分支，则用 <code>-D</code> 可以强制删除)。</li>
<li><code>git branch -a</code>: 列出全部的分支。</li>
<li><code>git branch -r</code>: 列出远程分支。</li>
<li><code>git branch</code>: 列出本地分支。</li>
<li><code>git branch --merged</code>: 列出已经与当前分支合并的分支，通常列出的那些分支除了当前分支之外都可以删掉，因为已经没有任何作用了。</li>
<li><code>git branch --no-merged</code>: 列出尚未和当前分支合并的分支。</li>
<li><code>git stash</code>: 贮藏(stash)当前的状态，git专门有一个”stash栈”用来存放贮藏的多个状态。这个命令的使用场景是：你正在基于 dev 分支写代码，突然Boss说在 master 分支上出了个bug，快去修复。那么你写代码写到一半，怎么办？你想要像游戏一样先将当前状态存档，修复完了bug之后，再读档恢复到先前的状态。</li>
<li><code>git stash pop</code>: 从”stash栈”弹出一个状态，并恢复该状态。具体的 stash 实现原理请看<a href="http://www.cnblogs.com/hustskyking/p/git-improve.html" target="_blank" rel="external">这里</a>。</li>
<li><code>git stash apply</code>: 和 <code>git stash pop</code> 不同，这个命令并不会从”stash栈”弹出状态，只是纯粹将栈顶的状态恢复。</li>
<li><code>git merge &lt;name&gt;</code>: 将分支 <code>&lt;name&gt;</code> 合并入当前分支。</li>
<li><code>git cherry-pick &lt;commit-1&gt; &lt;commit-2&gt; ... &lt;commit-n&gt;</code>: 将提交 <code>&lt;commit-1&gt; ... &lt;commit-n&gt;</code> 的提交内容在 HEAD 指针上按顺序重演一遍。比如有一系列提交：b1-&gt;b2-&gt;b3，HEAD 指向 b3，执行 <code>git cherry-pick b1 b2</code> 后，变成了 b1-&gt;b2-&gt;b3-&gt;b1-&gt;b2，HEAD 指向后一个 b2。这个命令的使用场景：当在所有分支上都出现了一个共同的小bug，此时就可以通过在一个分支上修改该bug，并将该bug的提交应用在其他的分支上。</li>
<li><code>git cherry-pick &lt;start-commit&gt;..&lt;end-commit&gt;</code>: 和上一个命令一样，只是将 <code>&lt;start-commit&gt;</code> 到 <code>&lt;end-commit&gt;</code> 的所有提交(不包括 <code>&lt;start-commit&gt;</code>) 在 HEAD 指针上按顺序重演一遍。</li>
<li><code>git cherry-pick &lt;start-commit&gt;^..&lt;end-commit&gt;</code>: 和上一个命令一样，只是将 <code>&lt;start-commit&gt;</code> 到 <code>&lt;end-commit&gt;</code> 的所有提交(包括 <code>&lt;start-commit&gt;</code>) 在 HEAD 指针上按顺序重演一遍。</li>
<li><code>git rebase &lt;name&gt;</code>: 将当前分支衍合到 <code>&lt;name&gt;</code> 分支。将当前分支与 <code>&lt;name&gt;</code> 分支的公共祖先开始到当前分支的改变在 <code>&lt;name&gt;</code> 分支重演一遍，然后将当前分支移到最新处，<code>&lt;name&gt;</code> 分支不动。<code>rebase</code> 命令可以说是自动一系列的 <code>cherry-pick</code> 命令。比如现在分支 <code>b1</code> 和 <code>b2</code> 的公共祖先是 <code>b</code>，<code>b</code> 到 <code>b1</code> 之间有4次提交(c1,c2,c3,c4)，如果当前分支是 <code>b1</code>，且运行 <code>git rebase b2</code>，则会将这四次提交(c1,c2,c3,c4)重新在 <code>b2</code> 分支上重演一遍(形成的Git树为：b2-&gt;c1-&gt;c2-&gt;c3-&gt;c4)，并且将 <code>b1</code> 分支指向最新的那个提交，而 <code>b2</code> 分支不动。</li>
<li><code>git rebase --onto &lt;SHA-1&gt; &lt;name&gt;</code>: 和上一条命令的区别在于，这条命令是从 <code>&lt;SHA-1&gt;</code> 提交开始在 <code>&lt;name&gt;</code> 分支上衍合，比如上面的例子，假设 <code>git rebase --onto c2 b2</code>，则将 c3,c4 衍合到 <code>b2</code>，即形成 b2-&gt;c3-&gt;c4，<code>b1</code> 分支指向 <code>c4</code> 提交。</li>
<li><code>git rebase &lt;name&gt; &lt;fname&gt;</code>: 将 <code>&lt;fname&gt;</code> 分支衍合到 <code>&lt;name&gt;</code> 分支。</li>
<li><code>git rebase -i &lt;start-commit&gt;</code>: 重新提交从 <code>&lt;start-commit&gt;</code> (不包括该提交)开始的所有提交。<code>-i</code> 表示进入交互模式，即打开一个编辑器，你可以选择删除某些提交，或修改某些提交的commit message，或合并某些提交为一个提交。因为这个命令比较复杂，这里举了例子：</li>
</ul>
<p>我们创建了7次提交，如下：</p>
<figure class="highlight"><table><tr><td class="code"><pre><div class="line">git log --pretty=oneline  # 第一步</div><div class="line"></div><div class="line">cc21fc335bc61ee49bc325ee59250fe7fd84496a g</div><div class="line">63fb59217d78100405867774a377bae2974718ef f</div><div class="line">b61cece6c683809f0bfe4ddc7dc4a6672af714ac e</div><div class="line">511e6959690aa76fbfa055c1154af925b7516571 d</div><div class="line">a7388b246adfe7c82d402b4280b18b825528d9e4 c</div><div class="line">eab9c3451745efdbadbcd78c49feb56ffa834ddc b</div><div class="line">8950be78e1cc5f8d1693c418d0a23a9681bb8042 a</div><div class="line"></div><div class="line">git rebase -i 8950be7     # 第二步</div><div class="line"></div><div class="line"># 打开编辑器后显示如下：</div><div class="line"></div><div class="line">pick eab9c34 b</div><div class="line">pick a7388b2 c</div><div class="line">pick 511e695 d</div><div class="line">pick b61cece e</div><div class="line">pick 63fb592 f</div><div class="line">pick cc21fc3 g</div></pre></td></tr></table></figure>
<p>你可以对该内容进行修改。</p>
<ul>
<li>删除某行表示取消该提交。</li>
<li>pick: 使用该提交。</li>
<li>reword: 和 pick 含义一样，但是可以修改 commit message（但是并不是直接在每行最右边直接修改，而是后来保存退出编辑器后再修改）。</li>
<li>fixup: 将该提交和上一个提交合并为一个”新”提交，新提交的 commit message 只会使用上一个提交的 commit message。</li>
<li>squash: 和 fixup 一样合并提交，只是可以自定义新提交的 commit message。</li>
<li>如果只是想删除全部的提交，那就别用 <code>git rebase -i</code> 了，直接用 <code>git reset --hard</code>。</li>
</ul>
<p>我们可以修改如下：</p>
<figure class="highlight"><table><tr><td class="code"><pre><div class="line">reword eab9c34 b # 修改 eab9c34 提交的 commit message，等到保存退出后git会自动弹出编辑器让你自定义 commit message</div><div class="line">#pick a7388b2 c  # 删除 a7388b2 提交</div><div class="line">pick 511e695 d   # 将 511e695, b61cece, 63fb592 合并为一个提交，并使用 511e695 的 commit message</div><div class="line">fixup b61cece e</div><div class="line">fixup 63fb592 f</div><div class="line">pick cc21fc3 g</div></pre></td></tr></table></figure>
<p>当保存并退出编辑器后，git会从上到下执行每行的命令。</p>
<blockquote>
<p>合并分支时会出现冲突，对于代码量很大的文件，相比手工一行一行解决冲突，使用 Beyond Compare 更加方便。</p>
</blockquote>
<h3 id="patch相关命令"><a href="#patch相关命令" class="headerlink" title="patch相关命令"></a>patch相关命令</h3><p>“git format-patch” 命令用于生成补丁文件(.patch)，将这些补丁文件给其他人可以通过 “git am \<patch-file\>“ 应用这些补丁。在 Git 中，一次提交对应一个 .patch 文件，补丁文件的命名方式为：<code>&lt;id&gt;-&lt;message&gt;.patch</code>，\<id\>从 1 开始计数，\<message\> 是这次提交的第一行 commit message。因此如果要对多个提交生成补丁，则会生成多个 .patch 文件。</message\></id\></patch-file\></p>
<ul>
<li><code>git format-patch -n</code>: 生成 HEAD 前 n 个提交的补丁(包含 HEAD 的提交)。</li>
<li><code>git format-patch -n &lt;commit-id&gt;</code>: 生成 <code>&lt;commit-id&gt;</code> 的前 n 次提交的补丁(包含 <code>&lt;commit-id&gt;</code>)。</li>
<li><code>git format-patch -1 &lt;commit-id&gt;</code>: 仅生成 <code>&lt;commit-id&gt;</code> 一次提交的补丁。</li>
<li><code>git format-patch &lt;start-commit-id&gt; &lt;end-commit-id&gt;</code>: 生成 <code>&lt;start-commit-id&gt;</code> 开始到 <code>&lt;end-cimmit-id&gt;</code> 提交的补丁(包含 <code>&lt;start-commit-id&gt;</code>, <code>end-commit-id</code>)。</li>
<li><code>git format-patch &lt;commit-id&gt;</code>: 生成 <code>&lt;commit-id&gt;</code> 之后的所有提交的补丁(不包含 <code>&lt;commit-id&gt;</code>)。</li>
<li><code>git format-patch --root &lt;commit-id&gt;</code>: 生成从树根到 <code>&lt;commit-id&gt;</code> 的所有提交的补丁(包含 <code>&lt;commit-id&gt;</code>)。</li>
<li><code>git am bugfix.patch</code>: 应用 bugfix.patch 补丁文件。</li>
</ul>
<blockquote>
<p>生成多个补丁文件给他人会让别人应用补丁比较麻烦，因为不得不一个一个应用，因此可以通过 <code>git format-patch -3 --stdout &gt; bugfix.patch</code> 将所有生成的补丁合成一个 <code>bugfix.patch</code> 文件。</p>
</blockquote>
<h3 id="远程仓库相关"><a href="#远程仓库相关" class="headerlink" title="远程仓库相关"></a>远程仓库相关</h3><p>远程仓库相关有两个概念：</p>
<ol>
<li><strong>远程分支</strong> ：对远程仓库状态的索引。引入远程仓库之后，分支就分为了本地分支和远程分支，本地分支名字以 <code>&lt;分支名&gt;</code> 形式存在，远程分支名字以 <code>&lt;远程主机名&gt;/&lt;分支名&gt;</code> 形式存在。比如在克隆远程仓库后，就会出现 <code>origin</code> 的远程主机名，对应的URL是 <code>https://..../xx.git</code>，而远程仓库的 master 分支是 <code>origin/master</code>。</li>
<li><strong>追踪分支</strong> ：在引入远程仓库之后，本地分支和远程分支会有一种追踪(相关联)的关系，比如本地分支 <code>master</code> 和远程分支 <code>origin/master</code> 拥有追踪关系，这种追踪关系可以自定义，也可以由 Git 自动赋予。</li>
</ol>
<blockquote>
<p>对远程分支的进一步解释：</p>
<p>他只是对远程仓库状态的索引。比如别人在远程仓库新建了一个 <code>test</code> 分支，而这个分支在你本地是没有的，则当你 <code>git fetch</code> 之后，本地只会有远程分支 <code>origin/test</code>，而不会有本地分支 <code>test</code>，你需要通过 <code>git checkout -b test origin/test</code> 创建内容和远程分支 <code>origin/test</code> 一样的本地分支 <code>test</code>。</p>
</blockquote>
<ul>
<li><code>git clone &lt;url&gt;</code>: 克隆远程仓库 <code>&lt;url&gt;</code>，并赋予远程主机名 <code>origin</code>，这是克隆所有分支。</li>
<li><code>git clone -b &lt;branch_name&gt; &lt;url&gt;</code>: 克隆远程仓库 <code>&lt;url&gt;</code> 的 <code>&lt;branch_name&gt;</code> 分支到本地。</li>
<li><code>git clone -o &lt;remote&gt; &lt;url&gt;</code>: 克隆远程仓库 <code>&lt;url&gt;</code>，并赋予远程主机名 <code>&lt;remote&gt;</code>。</li>
<li><code>git push &lt;remote-name&gt; &lt;local-branch&gt;:&lt;remote-branch&gt;</code>: 将本地 <code>&lt;local-branch&gt;</code> 分支提交到远程主机名为 <code>&lt;remote-name&gt;</code> 的 <code>&lt;remote-branch&gt;</code> 分支。</li>
<li><code>git push origin master:master dev_01:dev_01 dev_02:dev_02</code>: <code>git push</code> 命令支持同时做几个推送命令，这条命令是同时推送 master, dev_01, dev_02 分支到远程仓库。</li>
<li><code>git push &lt;remote-name&gt; &lt;local-branch&gt;</code>: 将本地分支 <code>&lt;local-branch&gt;</code> 提交到远程主机名为 <code>&lt;remote-name&gt;</code> 的与本地分支有追踪关系的远程分支。</li>
<li><code>git push &lt;remote-name&gt; --force &lt;local-branch&gt;:&lt;remote-branch&gt;</code>: 假设你改错了个东西，并且提交到了远程仓库，你想回到旧版本，并更新到远程仓库，那么你在本地 <code>git reset</code> 到旧的 commit 后，使用上面的 <code>git push</code> 命令是提交不上去的(报错：”Updates were rejected because your current branch is behind its remote counterpart”)，这时可以使用这条命令，即加 <code>--force</code>。</li>
<li><code>git push &lt;remote-name&gt; :&lt;remote-branch&gt;</code>: 删除远程主机名为 <code>&lt;remote-name&gt;</code> 的 <code>&lt;remote-branch&gt;</code> 分支。</li>
<li><code>git fetch &lt;remote-name&gt;</code>: 从远程主机 <code>&lt;remote-name&gt;</code> 中取回所有更新，远程主机的分支在本地会用 <code>&lt;remote-name&gt;/&lt;branch&gt;</code> 表示，其实这也是个分支名而已(这种形式的分支称为“远程分支”)。如果你想合并入本地的 <code>&lt;branch&gt;</code> 分支，则可以用 <code>git checkout &lt;branch&gt;</code> 和 <code>git merge &lt;remote-name&gt;/&lt;branch&gt;</code> 合并；也可以用 <code>git pull &lt;remote-name&gt; &lt;branch&gt;</code> 直接完成。</li>
<li><code>git fetch &lt;remote-name&gt; &lt;branch&gt;</code>: 取回远程主机 <code>&lt;remote-name&gt;</code> 中的分支 <code>&lt;branch&gt;</code> 的更新。</li>
<li><code>git remote add &lt;name&gt; &lt;url&gt;</code>: 添加远程主机名 <code>&lt;name&gt;</code>，并用他代表 <code>&lt;url&gt;</code>。</li>
<li><code>git remote rm &lt;name&gt;</code>: 删除远程主机名 <code>&lt;name&gt;</code>，并不是真的删除远程仓库内容。</li>
<li><code>git remote -v</code>: 列出可用的远程主机名。</li>
<li><code>git remote set-url &lt;name&gt; &lt;url&gt;</code>: 重新将远程主机名 <code>&lt;name&gt;</code> 对应的地址是 <code>&lt;url&gt;</code>。</li>
<li><code>git remote rename &lt;old&gt; &lt;new&gt;</code>: 重命名远程主机 <code>&lt;old&gt;</code> 为 <code>&lt;new&gt;</code>。</li>
<li><code>git pull &lt;remote-name&gt; &lt;remote-branch&gt;:&lt;local-branch&gt;</code>: 取回远程主机 <code>&lt;remote-name&gt;</code> 的分支 <code>&lt;remote-branch&gt;</code> 更新，并将他与本地分支 <code>&lt;local-branch&gt;</code> 合并。</li>
<li><code>git pull &lt;remote-name&gt; &lt;remote-branch&gt;</code>: 取回远程主机 <code>&lt;remote-name&gt;</code> 的分支 <code>&lt;remote-branch&gt;</code> 更新，并将他与当前分支合并。</li>
</ul>
<h2 id="Github-相关"><a href="#Github-相关" class="headerlink" title="Github 相关"></a>Github 相关</h2><p>Github 是 Git 仓库的托管平台(又被称为”全球最大的同性交友网站”)，但是发展到现在，他其实已经变成了一个团队协作的平台(Github 的口号是”Build Software better, together”)，Google Code 也因为他关闭了，Google 将他的仓库都搬到 Github 上了。</p>
<p>Github 又多了 Social 的概念，比如 Follow People, Watch Repositories，你也可以通过 Explore 找到更多的 Projects 或 People。</p>
<blockquote>
<p><a href="https://mac.github.com/index.html" target="_blank" rel="external">Github for Mac</a> 是 Github 官方推出的客户端，非常好用，他弱化了 Git 的概念，比如 push,pull 等，而用 Sync 代替了 pull+push。在2015年8月12日又推出了新版，新增功能有：</p>
<ul>
<li>提出了”Start contributing, natively”，即在本地客户端就可以完成 Pull Request，而不需要到 Github 网站上。</li>
<li>按行提交，而不是将整个文件的改变一起提交。</li>
<li>仅仅通过单击分支的方式就切换分支。</li>
</ul>
</blockquote>
<h3 id="1-Github-基本概念"><a href="#1-Github-基本概念" class="headerlink" title="1. Github 基本概念"></a>1. Github 基本概念</h3><ul>
<li><strong>Star</strong>: 收藏项目，类似于浏览器当中的加入书签功能。</li>
<li><strong>Watch</strong>: 除了收藏，当该项目收到 Pull Request 时，都会通知你。</li>
<li><strong>Fork</strong>: 只有你想贡献代码给该项目，才用 Fork，一般都用 Star，因此流传着一句话：不贡献代码的 Fork 就是耍流氓！</li>
</ul>
<blockquote>
<p>有一个很普遍的问题，就是 Fork 之后，如果原作者的代码更新了，在你自己 Fork 的项目中是看不出更新的。最简单的解决方法是重新 Fork；复杂一点的是 merge。</p>
</blockquote>
<ul>
<li>Issues: Github 每个项目都有一个 Issues 模块，官方定义：”Issues are used to track todos, bugs, feature requests, and more.”，简单地说就是项目的小型论坛，你可以在里面提任何的问题，可以回复别的Issue，但是 Issues 的最终命运是要被关闭的，即问题解决了就关闭。</li>
</ul>
<h3 id="2-给开源项目贡献代码"><a href="#2-给开源项目贡献代码" class="headerlink" title="2. 给开源项目贡献代码"></a>2. 给开源项目贡献代码</h3><p>作为一个有上进心的程序员，为开源世界做贡献是很常见的愿景。</p>
<p>假设这次要贡献的是 JQuery，地址是：<a href="https://github.com/jquery/jquery" target="_blank" rel="external">https://github.com/jquery/jquery</a>。方法如下：</p>
<ol>
<li>Fork 别人的项目成为自己的项目，地址是 <a href="https://github.com/xiazdong/jquery" target="_blank" rel="external">https://github.com/xiazdong/jquery</a>。</li>
<li>将 <a href="https://github.com/xiazdong/jquery" target="_blank" rel="external">https://github.com/xiazdong/jquery</a> Clone 到本地。</li>
<li>修改代码。</li>
<li>提交到远程仓库 <a href="https://github.com/xiazdong/jquery" target="_blank" rel="external">https://github.com/xiazdong/jquery</a>。</li>
<li>New Pull Request 等待原作者的审批。</li>
</ol>
<h3 id="3-Github-Flow"><a href="#3-Github-Flow" class="headerlink" title="3. Github Flow"></a>3. Github Flow</h3><p><a href="http://gitbeijing.com/flow/" target="_blank" rel="external">Github Flow</a> 是由 Github 人员总结的一套使用 Git 的工作流程如下图：</p>
<p><img src="http://i.imgur.com/bKD9cri.png" width="600px"></p>
<p>上图中的编号解释：</p>
<ol>
<li>将队友加入项目的 Collaborator。</li>
<li>每个功能都新建一个特性分支。</li>
<li>在特性分支上做开发。</li>
<li>开发完之后提交 Pull Request。</li>
<li>提交完后可以在所在的 Pull Request 讨论留言，作为 Code Review。</li>
<li>当达成一致时，Merge Pull Request 到 master 分支，其中 master 分支的代码都是可以直接部署运行的，即最稳定的，不能直接在 master 上改代码。</li>
</ol>
<blockquote>
<p><a href="http://gitbeijing.com/github_flow.html" target="_blank" rel="external">团队合作流程</a> 有对 Github Flow 进行详细介绍。</p>
</blockquote>
<p>一般在公司里的开发习惯是：如果2015年8月12日要发一个版本，那么新建一个 dev_20150812 分支，但是不要再该分支上修改，而是每次都新建一个分支(比如 dev_20150812_feature1)，修改完了之后再发一个 merge request 到 dev_20150812。</p>
<h3 id="4-Github-支持-Git-LFS"><a href="#4-Github-支持-Git-LFS" class="headerlink" title="4. Github 支持 Git LFS"></a>4. Github 支持 Git LFS</h3><p>原来，根据 <a href="https://help.github.com/articles/what-is-my-disk-quota/" target="_blank" rel="external">官方说明</a>，Github 对于每个仓库的大小限制在 1G，仓库中每个文件的大小限制 100M，如果文件大小大于 50M，那么 push 时会出现 warning。</p>
<p>但是在2015年4月8日，Github官方宣布支持 <a href="https://github.com/blog/1986-announcing-git-large-file-storage-lfs" target="_blank" rel="external">Git LFS</a> 扩展，每个仓库默认有 1G 的大文件存储空间，每个月带宽也是 1G。Git LFS(Large File Storage) 的官方定义是”command line extension for managing large files in Git”，即 Git LFS 是为了让 Git 更好地支持大文件管理而实现的一个命令行的扩展，即你只要安装好了之后，就能够使用类似 <code>git lfs</code> 使用 LFS，即将 LFS 集成到 Git 中。</p>
<p><img src="https://cloud.githubusercontent.com/assets/1319791/7051226/c4570828-ddf4-11e4-87eb-8fc165e5ece4.gif" width="600px"></p>
<p><a href="https://github.com/github/git-lfs" target="_blank" rel="external">Git LFS</a> 的实现思路可以从上面的图中看出：有一个 Git Large File Storage Server(位于右上角)专门存储大文件，而 Git 仓库只是使用一个”text pointer”(仅仅是一段文本，作为指针)来记录大文件的位置。原来 Git 对大文件管理支持的不好是因为加入大文件之后，Git 仓库就会变得非常大，管理起来就速度很慢，而现在有了这种方法之后，Git 仓库不会因为大文件的加入而体积变大。</p>
<p>在 Github 中，Github 既充当 Git 仓库的角色，也充当 LFS Server 的角色(地址是：”<a href="https://media.githubusercontent.com/media/xiazdong/...&quot;)。" target="_blank" rel="external">https://media.githubusercontent.com/media/xiazdong/...&quot;)。</a></p>
<p>Git LFS 的安装教程见<a href="https://git-lfs.github.com/" target="_blank" rel="external">这里</a>，官方文档见<a href="https://github.com/github/git-lfs/tree/master/docs" target="_blank" rel="external">这里</a>。</p>
<blockquote>
<p>目前我已经收到 Github 的邮件，说已经正式公开支持 LFS 特性。</p>
</blockquote>
<p>这里列举几个常用的命令：</p>
<ul>
<li><code>git lfs --h</code>: 查看帮助。</li>
<li><code>git lfs track &lt;file&gt;</code>: LFS 开始跟踪 <code>&lt;file&gt;</code>。</li>
<li><code>git lfs track</code>: 列出 LFS 跟踪的文件。 </li>
<li><code>git lfs untrack &lt;file&gt;</code>: LFS 取消跟踪 <code>&lt;file&gt;</code>。</li>
<li><code>git lfs push</code>: 将 LFS 跟踪的文件 push 到 LFS Server。</li>
<li><code>git lfs status</code>: 查看 LFS 的状态。</li>
</ul>
<h3 id="Gist"><a href="#Gist" class="headerlink" title="Gist"></a>Gist</h3><ul>
<li>英文定义：Gist is a simple way to share snippets and pastes with others. All gists are Git repositories, so they are automatically versioned, forkable and usable from Git.</li>
<li>中文定义：Gist是一种分享小段代码给别人的简单的方式。每个 Gist 都是 Git 仓库，他被自动进行版本控制，他也能被 fork。</li>
</ul>
<h3 id="Gitter"><a href="#Gitter" class="headerlink" title="Gitter"></a>Gitter</h3><p><a href="http://gitter.im" target="_blank" rel="external">Gitter</a> 是一款专门为 Github 打造的聊天应用(标语为”Chat, for GitHub.”)，你可以为某个你的项目新建一个聊天室，并且邀请一些人在里面讨论。目前支持 Web, Mac, IOS, Android。</p>
<blockquote>
<p>用下来感觉是不错，而且还跨平台，逼格特别高，但是其实直接建个QQ群也挺好使的。</p>
</blockquote>
<h3 id="Tig"><a href="#Tig" class="headerlink" title="Tig"></a>Tig</h3><p><a href="https://github.com/jonas/tig" target="_blank" rel="external">Tig</a> 是一款字符模式的 Git 操作界面。不过不容易上手。</p>
<ul>
<li>输入 <code>tig</code> 进入 Main View。可以看到一系列提交 log。可以通过”上下键”上下选择具体某个提交。</li>
<li>选中某个提交后，输入 “Enter” 查看提交的信息。输入 “s” 进入这次提交的 Status View，即查看这次提交修改了哪些文件。输入 “t” 查看这次提交的 Tree View。</li>
<li>输入 “q” 回上一级。</li>
<li>输入 “h” 进入帮助界面。</li>
</ul>
<blockquote>
<p>我目前还没有适应这种使用 Git 的方式，还是比较推荐 Tower。</p>
</blockquote>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul>
<li><a href="http://git-scm.com/book/en/v2" target="_blank" rel="external">Pro Git</a>: 这本书是 Github 的员工 Scott Chacon 写的，最好的 Git 学习书。</li>
<li><a href="https://try.github.io/levels/1/challenges/1" target="_blank" rel="external">Try Git</a>: Github 官方的 Git 入门实验教程。</li>
<li><a href="http://marklodato.github.io/visual-git-guide/index-zh-cn.html" target="_blank" rel="external">图解 Git</a>: 将一些其他书中不太清楚的概念用图的方式讲清楚了。</li>
<li><a href="http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000" target="_blank" rel="external">廖雪峰 Git教程</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2014/06/git_remote.html" target="_blank" rel="external">Git远程操作详解</a></li>
<li><a href="http://www.cnblogs.com/hustskyking/p/git-improve.html" target="_blank" rel="external">git版本管理策略及相关技巧(A)</a></li>
<li><a href="http://www.php-oa.com/2014/10/22/github-operation.html" target="_blank" rel="external">Github 上 Fork 别人的项目后的常用的操作指南</a></li>
<li><a href="http://blog.krdai.info/post/17485259496/github-flow" target="_blank" rel="external">在 GitHub 當中使用的 work flow</a></li>
<li><a href="http://happypeter.github.io/gitbeijing/" target="_blank" rel="external">Git 北京</a>: 主要介绍Github相关内容。</li>
<li><a href="http://blog.kidwm.net/388" target="_blank" rel="external">Tig使用入门</a></li>
<li><a href="https://github.com/blog/2019-how-to-undo-almost-anything-with-git" target="_blank" rel="external">How to undo (almost) anything with Git</a></li>
<li><a href="http://alblue.bandlem.com/2011/08/git-tip-of-week-detached-heads.html" target="_blank" rel="external">Git Tip of the Week: Detached Heads</a></li>
<li><a href="http://www.oschina.net/translate/10-tips-git-next-level?cmp" target="_blank" rel="external">10 Tips to Push Your Git Skills to the Next Level</a></li>
</ul>
<h2 id="附：视频教程"><a href="#附：视频教程" class="headerlink" title="附：视频教程"></a>附：视频教程</h2><p>快过年了，附上点福利吧~</p>
<ul>
<li><a href="http://www.icoolxue.com/album/show/41" target="_blank" rel="external">Git权威指南 视频</a></li>
<li><a href="http://study.163.com/course/courseMain.htm?courseId=976002" target="_blank" rel="external">李兴华 Git</a></li>
<li><a href="https://www.udacity.com/course/ud775" target="_blank" rel="external">Udacity: How to use Git and Github</a></li>
</ul>

    
  </div>
</article>


   
  <div class="text-center donation">
    <div class="inner-donation">
      <span class="btn-donation">支持一下</span>
      <div class="donation-body">
        <div class="tip text-center">扫一扫，支持xiazdong</div>
        <ul class="theme.donation.items.length">
        
          <li class="item">
            <img src="/images/qr-wechat.png" alt="">
          </li>
        
          <li class="item">
            <img src="/images/qr-alipay.png" alt="">
          </li>
        
        </ul>
      </div>
    </div>
  </div>


   
  <div class="box-prev-next clearfix">
    <a class="show pull-left" href="/2015/10/26/校招找工作小结/">
        <i class="icon icon-angle-left"></i>
    </a>
    <a class="show pull-right" href="/2016/05/16/程序员教你健身/">
        <i class="icon icon-angle-right"></i>
    </a>
  </div>




</div>


  <a id="backTop" class="back-top">
    <i class="icon-angle-up"></i>
  </a>




  <div class="modal" id="modal">
  <span id="cover" class="cover hide"></span>
  <div id="modal-dialog" class="modal-dialog hide-dialog">
    <div class="modal-header">
      <span id="close" class="btn-close">关闭</span>
    </div>
    <hr>
    <div class="modal-body">
      <ul class="list-toolbox">
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/archives/"
              rel="noopener noreferrer"
              target="_self"
              >
              博客
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/tag/"
              rel="noopener noreferrer"
              target="_self"
              >
              分类
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/about/"
              rel="noopener noreferrer"
              target="_self"
              >
              关于
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/atom.xml"
              rel="noopener noreferrer"
              target="_blank"
              >
              RSS
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/search/"
              rel="noopener noreferrer"
              target="_self"
              >
              搜索
            </a>
          </li>
        
      </ul>

    </div>
  </div>
</div>



  
      <div class="fexo-comments comments-post">
    

    




    

  </div>

  

  <script type="text/javascript">
  function loadScript(url, callback) {
    var script = document.createElement('script')
    script.type = 'text/javascript';

    if (script.readyState) { //IE
      script.onreadystatechange = function() {
        if (script.readyState == 'loaded' ||
          script.readyState == 'complete') {
          script.onreadystatechange = null;
          callback();
        }
      };
    } else { //Others
      script.onload = function() {
        callback();
      };
    }

    script.src = url;
    document.getElementsByTagName('head')[0].appendChild(script);
  }

  window.onload = function() {
    loadScript('/js/bundle.js?235683', function() {
      // load success
    });
  }
</script>

</body>
</html>
