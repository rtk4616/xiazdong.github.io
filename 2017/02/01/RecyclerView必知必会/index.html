<!DOCTYPE html>


  <html class="light page-post">


<head>
  <meta charset="utf-8">
  
  <title>RecyclerView必知必会 | xiazdong</title>

  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
    <meta name="keywords" content="Android," />
  

  <meta name="description" content="本文转载于Bugly公众号。 前言下文中Demo的源代码地址：RecyclerViewDemo。  Demo1: RecyclerView添加HeaderView和FooterView，ItemDecoration范例。 Demo2: ListView实现局部刷新。 Demo3: RecyclerView实现拖拽、侧滑删除。 Demo4: RecyclerView闪屏问题。 Demo5: Recy">
<meta name="keywords" content="Android">
<meta property="og:type" content="article">
<meta property="og:title" content="RecyclerView必知必会">
<meta property="og:url" content="http://xiazdong.github.io/2017/02/01/RecyclerView必知必会/index.html">
<meta property="og:site_name" content="xiazdong">
<meta property="og:description" content="本文转载于Bugly公众号。 前言下文中Demo的源代码地址：RecyclerViewDemo。  Demo1: RecyclerView添加HeaderView和FooterView，ItemDecoration范例。 Demo2: ListView实现局部刷新。 Demo3: RecyclerView实现拖拽、侧滑删除。 Demo4: RecyclerView闪屏问题。 Demo5: Recy">
<meta property="og:image" content="https://github.com/xiazdong/RecyclerViewDemo/blob/master/app/src/main/res/assets/demo6.gif?raw=true">
<meta property="og:updated_time" content="2017-05-16T13:58:22.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="RecyclerView必知必会">
<meta name="twitter:description" content="本文转载于Bugly公众号。 前言下文中Demo的源代码地址：RecyclerViewDemo。  Demo1: RecyclerView添加HeaderView和FooterView，ItemDecoration范例。 Demo2: ListView实现局部刷新。 Demo3: RecyclerView实现拖拽、侧滑删除。 Demo4: RecyclerView闪屏问题。 Demo5: Recy">
<meta name="twitter:image" content="https://github.com/xiazdong/RecyclerViewDemo/blob/master/app/src/main/res/assets/demo6.gif?raw=true">

  

  
    <link rel="icon" href="/favicon.ico">
  

  <link href="/css/styles.css?v=c114cbe6" rel="stylesheet">


  
    <link rel="stylesheet" href="/css/personal-style.css">
  

  

  

  


  
    <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
  

  
    <link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.3.0/css/font-awesome.min.css">
  
</head>

<body>


  
    <span id="toolbox-mobile" class="toolbox-mobile">盒子</span>
  

  <div class="post-header CENTER">
   
  <div class="toolbox">
    <a class="toolbox-entry" href="/">
      <span class="toolbox-entry-text">盒子</span>
      <i class="icon-angle-down"></i>
      <i class="icon-home"></i>
    </a>
    <ul class="list-toolbox">
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/archives/"
            rel="noopener noreferrer"
            target="_self"
            >
            博客
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/tag/"
            rel="noopener noreferrer"
            target="_self"
            >
            分类
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/about/"
            rel="noopener noreferrer"
            target="_self"
            >
            关于
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/atom.xml"
            rel="noopener noreferrer"
            target="_blank"
            >
            RSS
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/search/"
            rel="noopener noreferrer"
            target="_self"
            >
            搜索
          </a>
        </li>
      
    </ul>
  </div>


</div>


  <div id="toc" class="toc-article">
    <strong class="toc-title">文章目录</strong>
    <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#前言"><span class="toc-text">前言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#基本概念"><span class="toc-text">基本概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#为什么会出现RecyclerView？"><span class="toc-text">为什么会出现RecyclerView？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ListView-vs-RecyclerView"><span class="toc-text">ListView vs RecyclerView</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ListView实现局部刷新"><span class="toc-text">ListView实现局部刷新</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#标准用法"><span class="toc-text">标准用法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#四大组成"><span class="toc-text">四大组成</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Adapter"><span class="toc-text">Adapter</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Item-Decoration"><span class="toc-text">Item Decoration</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Layout-Manager"><span class="toc-text">Layout Manager</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Item-Animator"><span class="toc-text">Item Animator</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#拓展RecyclerView"><span class="toc-text">拓展RecyclerView</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#添加setOnItemClickListener接口"><span class="toc-text">添加setOnItemClickListener接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#添加HeaderView和FooterView"><span class="toc-text">添加HeaderView和FooterView</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#添加setEmptyView"><span class="toc-text">添加setEmptyView</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#拖拽、侧滑删除"><span class="toc-text">拖拽、侧滑删除</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#回收机制"><span class="toc-text">回收机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ListView回收机制"><span class="toc-text">ListView回收机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RecyclerView回收机制"><span class="toc-text">RecyclerView回收机制</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#嵌套滑动机制"><span class="toc-text">嵌套滑动机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#回顾"><span class="toc-text">回顾</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#扩展阅读"><span class="toc-text">扩展阅读</span></a></li></ol>
  </div>



<div class="content content-post CENTER">
   <article id="post-RecyclerView必知必会" class="article article-type-post" itemprop="blogPost">
  <header class="article-header">
    <h1 class="post-title">RecyclerView必知必会</h1>

    <div class="article-meta">
      <span>
        <i class="icon-calendar"></i>
        <span>2017.02.01</span>
      </span>

      
        <span class="article-author">
          <i class="icon-user"></i>
          <span>xiazdong</span>
        </span>
      

      


      

      
      <i class="fa fa-eye"></i> 
        <span id="busuanzi_container_page_pv">
           &nbsp热度 <span id="busuanzi_value_page_pv">
           <i class="fa fa-spinner fa-spin"></i></span>℃
        </span>
      

      

      
    </div>
  </header>

  <div class="article-content">
    
      <p>本文转载于<a href="http://mp.weixin.qq.com/s/CzrKotyupXbYY6EY2HP_dA" target="_blank" rel="external">Bugly</a>公众号。</p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>下文中Demo的源代码地址：<a href="https://github.com/xiazdong/RecyclerViewDemo" target="_blank" rel="external">RecyclerViewDemo</a>。</p>
<ul>
<li>Demo1: RecyclerView添加HeaderView和FooterView，ItemDecoration范例。</li>
<li>Demo2: ListView实现局部刷新。</li>
<li>Demo3: RecyclerView实现拖拽、侧滑删除。</li>
<li>Demo4: RecyclerView闪屏问题。</li>
<li>Demo5: RecyclerView实现<code>setEmptyView()</code>。</li>
<li>Demo6: RecyclerView实现万能适配器，瀑布流布局，嵌套滑动机制。</li>
</ul>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>RecyclerView是Android 5.0提出的新UI控件，位于support-v7包中，可以通过在build.gradle中添加<code>compile &#39;com.android.support:recyclerview-v7:24.2.1&#39;</code>导入。</p>
<p>RecyclerView的官方定义如下：</p>
<blockquote>
<p>A flexible view for providing a limited window into a large data set.</p>
</blockquote>
<p>从定义可以看出，flexible（可扩展性）是RecyclerView的特点。不过我们发现和ListView有点像，本文后面会介绍RecyclerView和ListView的区别。</p>
<h2 id="为什么会出现RecyclerView？"><a href="#为什么会出现RecyclerView？" class="headerlink" title="为什么会出现RecyclerView？"></a>为什么会出现RecyclerView？</h2><p>RecyclerView并不会完全替代ListView（这点从ListView没有被标记为@Deprecated可以看出），两者的使用场景不一样。但是RecyclerView的出现会让很多开源项目被废弃，例如<a href="https://github.com/MeetMe/Android-HorizontalListView" target="_blank" rel="external">横向滚动的ListView</a>, <a href="https://github.com/jess-anders/two-way-gridview" target="_blank" rel="external">横向滚动的GridView</a>, <a href="https://github.com/maurycyw/StaggeredGridView" target="_blank" rel="external">瀑布流控件</a>，因为RecyclerView能够实现所有这些功能。</p>
<p>比如有一个需求是屏幕竖着的时候的显示形式是ListView，屏幕横着的时候的显示形式是2列的GridView，此时如果用RecyclerView，则通过设置LayoutManager一行代码实现替换。</p>
<h2 id="ListView-vs-RecyclerView"><a href="#ListView-vs-RecyclerView" class="headerlink" title="ListView vs RecyclerView"></a>ListView vs RecyclerView</h2><p>ListView相比RecyclerView，有一些优点：</p>
<ul>
<li><code>addHeaderView()</code>, <code>addFooterView()</code>添加头视图和尾视图。</li>
<li>通过”android:divider”设置自定义分割线。</li>
<li><code>setOnItemClickListener()</code>和<code>setOnItemLongClickListener()</code>设置点击事件和长按事件。</li>
</ul>
<p>这些功能在RecyclerView中都没有直接的接口，要自己实现（虽然实现起来很简单），因此如果只是实现简单的显示功能，ListView无疑更简单。</p>
<p>RecyclerView相比ListView，有一些明显的优点：</p>
<ul>
<li>默认已经实现了View的复用，不需要类似<code>if(convertView == null)</code>的实现，而且回收机制更加完善。</li>
<li>默认支持局部刷新。</li>
<li>容易实现添加item、删除item的动画效果。</li>
<li>容易实现拖拽、侧滑删除等功能。</li>
</ul>
<p>RecyclerView是一个插件式的实现，对各个功能进行解耦，从而扩展性比较好。</p>
<h2 id="ListView实现局部刷新"><a href="#ListView实现局部刷新" class="headerlink" title="ListView实现局部刷新"></a>ListView实现局部刷新</h2><p>我们都知道ListView通过<code>adapter.notifyDataSetChanged()</code>实现ListView的更新，这种更新方法的缺点是全局更新，即对每个Item View都进行重绘。但事实上很多时候，我们只是更新了其中一个Item的数据，其他Item其实可以不需要重绘。</p>
<p>这里给出ListView实现局部更新的方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateItemView</span><span class="params">(ListView listview, <span class="keyword">int</span> position, Data data)</span></span>&#123;</div><div class="line">    <span class="keyword">int</span> firstPos = listview.getFirstVisiblePosition();</div><div class="line">    <span class="keyword">int</span> lastPos = listview.getLastVisiblePosition();</div><div class="line">    <span class="keyword">if</span>(position &gt;= firstPos &amp;&amp; position &lt;= lastPos)&#123;  <span class="comment">//可见才更新，不可见则在getView()时更新</span></div><div class="line">		<span class="comment">//listview.getChildAt(i)获得的是当前可见的第i个item的view</span></div><div class="line">        View view = listview.getChildAt(position - firstPos);</div><div class="line">        VH vh = (VH)view.getTag();</div><div class="line">        vh.text.setText(data.text);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看出，我们通过ListView的<code>getChildAt()</code>来获得需要更新的View，然后通过<code>getTag()</code>获得ViewHolder，从而实现更新。</p>
<h2 id="标准用法"><a href="#标准用法" class="headerlink" title="标准用法"></a>标准用法</h2><p>RecyclerView的标准实现步骤如下：</p>
<ul>
<li>创建Adapter：创建一个继承<code>RecyclerView.Adapter&lt;VH&gt;</code>的Adapter类（VH是ViewHolder的类名），记为NormalAdapter。</li>
<li>创建ViewHolder：在NormalAdapter中创建一个继承<code>RecyclerView.ViewHolder</code>的静态内部类，记为VH。ViewHolder的实现和ListView的ViewHolder实现几乎一样。</li>
<li>在NormalAdapter中实现：<ul>
<li><code>VH onCreateViewHolder(ViewGroup parent, int viewType)</code>: 映射Item Layout Id，创建VH并返回。</li>
<li><code>void onBindViewHolder(VH holder, int position)</code>: 为holder设置指定数据。</li>
<li><code>int getItemCount()</code>: 返回Item的个数。</li>
</ul>
</li>
</ul>
<p>可以看出，RecyclerView将ListView中<code>getView()</code>的功能拆分成了<code>onCreateViewHolder()</code>和<code>onBindViewHolder()</code>。</p>
<p>基本的Adapter实现如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NormalAdapter</span> <span class="keyword">extends</span> <span class="title">RecyclerView</span>.<span class="title">Adapter</span>&lt;<span class="title">NormalAdapter</span>.<span class="title">VH</span>&gt;</span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> List&lt;String&gt; mDatas;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NormalAdapter</span><span class="params">(List&lt;String&gt; data)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.mDatas = data;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onBindViewHolder</span><span class="params">(VH holder, <span class="keyword">int</span> position)</span> </span>&#123;</div><div class="line">        holder.title.setText(mDatas.get(position));</div><div class="line">        holder.itemView.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</div><div class="line">                <span class="comment">//item 点击事件</span></div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getItemCount</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> mDatas.size();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> VH <span class="title">onCreateViewHolder</span><span class="params">(ViewGroup parent, <span class="keyword">int</span> viewType)</span> </span>&#123;</div><div class="line">        View v = LayoutInflater.from(parent.getContext()).inflate(R.layout.item_1, parent, <span class="keyword">false</span>);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> VH(v);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">VH</span> <span class="keyword">extends</span> <span class="title">RecyclerView</span>.<span class="title">ViewHolder</span></span>&#123;</div><div class="line">        <span class="keyword">public</span> <span class="keyword">final</span> TextView title;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="title">VH</span><span class="params">(View v)</span> </span>&#123;</div><div class="line">            <span class="keyword">super</span>(v);</div><div class="line">            title = (TextView) v.findViewById(R.id.title);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>创建完Adapter，接着对RecyclerView进行设置，一般来说，需要为RecyclerView进行四大设置，也就是后文说的四大组成：Adapter(必选),Layout Manager(必选),Item Decoration(可选，默认为空), Item Animator(可选，默认为DefaultItemAnimator)。</p>
<p>需要注意的是在<code>onCreateViewHolder()</code>中，映射Layout必须为</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">View v = LayoutInflater.from(parent.getContext()).inflate(R.layout.item_1, parent, <span class="keyword">false</span>);</div></pre></td></tr></table></figure>
<p>而不能是：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">View v = LayoutInflater.from(parent.getContext()).inflate(R.layout.item_1, <span class="keyword">null</span>);</div></pre></td></tr></table></figure>
<p>如果要实现ListView的效果，只需要设置Adapter和Layout Manager，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">List&lt;String&gt; data = initData();</div><div class="line">RecyclerView rv = (RecyclerView) findViewById(R.id.rv);</div><div class="line">rv.setLayoutManager(<span class="keyword">new</span> LinearLayoutManager(<span class="keyword">this</span>));</div><div class="line">rv.setAdapter(<span class="keyword">new</span> NormalAdapter(data));</div></pre></td></tr></table></figure>
<p>ListView只提供了<code>notifyDataSetChanged()</code>更新整个视图，这是很不合理的。RecyclerView提供了<code>notifyItemInserted()</code>,<code>notifyItemRemoved()</code>,<code>notifyItemChanged()</code>等API更新单个或某个范围的Item视图。</p>
<h2 id="四大组成"><a href="#四大组成" class="headerlink" title="四大组成"></a>四大组成</h2><p>RecyclerView的四大组成是：</p>
<ul>
<li>Adapter：为Item提供数据。</li>
<li>Layout Manager：Item的布局。</li>
<li>Item Animator：添加、删除Item动画。</li>
<li>Item Decoration：Item之间的Divider。</li>
</ul>
<h3 id="Adapter"><a href="#Adapter" class="headerlink" title="Adapter"></a>Adapter</h3><p>Adapter的使用方式前面已经介绍了，功能就是为RecyclerView提供数据，这里主要介绍万能适配器的实现。其实万能适配器的概念在ListView就已经存在了，即<a href="https://github.com/JoanZapata/base-adapter-helper" target="_blank" rel="external">base-adapter-helper</a>。</p>
<p>这里我们只针对RecyclerView，聊聊万能适配器出现的原因。为了创建一个RecyclerView的Adapter，每次我们都需要去做重复劳动，包括重写<code>onCreateViewHolder()</code>,<code>getItemCount()</code>、创建ViewHolder，并且实现过程大同小异，因此万能适配器出现了，他能通过以下方式快捷地创建一个Adapter：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">mAdapter = <span class="keyword">new</span> QuickAdapter&lt;String&gt;(data) &#123;</div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getLayoutId</span><span class="params">(<span class="keyword">int</span> viewType)</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> R.layout.item;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">convert</span><span class="params">(VH holder, String data, <span class="keyword">int</span> position)</span> </span>&#123;</div><div class="line">		holder.setText(R.id.text, data);</div><div class="line">		<span class="comment">//holder.itemView.setOnClickListener(); 此处还可以添加点击事件</span></div><div class="line">	&#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>是不是很方便。当然复杂情况也可以轻松解决。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">mAdapter = <span class="keyword">new</span> QuickAdapter&lt;Model&gt;(data) &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getLayoutId</span><span class="params">(<span class="keyword">int</span> viewType)</span> </span>&#123;</div><div class="line">        <span class="keyword">switch</span>(viewType)&#123;</div><div class="line">            <span class="keyword">case</span> TYPE_1:</div><div class="line">                <span class="keyword">return</span> R.layout.item_1;</div><div class="line">            <span class="keyword">case</span> TYPE_2:</div><div class="line">                <span class="keyword">return</span> R.layout.item_2;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getItemViewType</span><span class="params">(<span class="keyword">int</span> position)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(position % <span class="number">2</span> == <span class="number">0</span>)&#123;</div><div class="line">            <span class="keyword">return</span> TYPE_1;</div><div class="line">        &#125; <span class="keyword">else</span>&#123;</div><div class="line">            <span class="keyword">return</span> TYPE_2;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">convert</span><span class="params">(VH holder, Model data, <span class="keyword">int</span> position)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> type = getItemViewType(position);</div><div class="line">        <span class="keyword">switch</span>(type)&#123;</div><div class="line">            <span class="keyword">case</span> TYPE_1:</div><div class="line">                holder.setText(R.id.text, data.text);</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">case</span> TYPE_2:</div><div class="line">                holder.setImage(R.id.image, data.image);</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>这里讲解下万能适配器的实现思路。</p>
<p>我们通过<code>public abstract class QuickAdapter&lt;T&gt; extends RecyclerView.Adapter&lt;QuickAdapter.VH&gt;</code>定义万能适配器QuickAdapter类，T是列表数据中每个元素的类型，QuickAdapter.VH是QuickAdapter的ViewHolder实现类，称为万能ViewHolder。</p>
<p>首先介绍QuickAdapter.VH的实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">VH</span> <span class="keyword">extends</span> <span class="title">RecyclerView</span>.<span class="title">ViewHolder</span></span>&#123;</div><div class="line">    <span class="keyword">private</span> SparseArray&lt;View&gt; mViews;</div><div class="line">    <span class="keyword">private</span> View mConvertView;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">VH</span><span class="params">(View v)</span></span>&#123;</div><div class="line">        <span class="keyword">super</span>(v);</div><div class="line">        mConvertView = v;</div><div class="line">        mViews = <span class="keyword">new</span> SparseArray&lt;&gt;();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> VH <span class="title">get</span><span class="params">(ViewGroup parent, <span class="keyword">int</span> layoutId)</span></span>&#123;</div><div class="line">        View convertView = LayoutInflater.from(parent.getContext()).inflate(layoutId, parent, <span class="keyword">false</span>);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> VH(convertView);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> &lt;T extends View&gt; <span class="function">T <span class="title">getView</span><span class="params">(<span class="keyword">int</span> id)</span></span>&#123;</div><div class="line">        View v = mViews.get(id);</div><div class="line">        <span class="keyword">if</span>(v == <span class="keyword">null</span>)&#123;</div><div class="line">            v = mConvertView.findViewById(id);</div><div class="line">            mViews.put(id, v);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> (T)v;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setText</span><span class="params">(<span class="keyword">int</span> id, String value)</span></span>&#123;</div><div class="line">        TextView view = getView(id);</div><div class="line">        view.setText(value);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其中的关键点在于通过<code>SparseArray&lt;View&gt;</code>存储item view的控件，<code>getView(int id)</code>的功能就是通过id获得对应的View（首先在mViews中查询是否存在，如果没有，那么<code>findViewById()</code>并放入mViews中，避免下次再执行<code>findViewById()</code>）。</p>
<p>QuickAdapter的实现如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">QuickAdapter</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">RecyclerView</span>.<span class="title">Adapter</span>&lt;<span class="title">QuickAdapter</span>.<span class="title">VH</span>&gt;</span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> List&lt;T&gt; mDatas;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">QuickAdapter</span><span class="params">(List&lt;T&gt; datas)</span></span>&#123;</div><div class="line">        <span class="keyword">this</span>.mDatas = datas;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">getLayoutId</span><span class="params">(<span class="keyword">int</span> viewType)</span></span>;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> VH <span class="title">onCreateViewHolder</span><span class="params">(ViewGroup parent, <span class="keyword">int</span> viewType)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> VH.get(parent,getLayoutId(viewType));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onBindViewHolder</span><span class="params">(VH holder, <span class="keyword">int</span> position)</span> </span>&#123;</div><div class="line">        convert(holder, mDatas.get(position), position);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getItemCount</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> mDatas.size();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">convert</span><span class="params">(VH holder, T data, <span class="keyword">int</span> position)</span></span>;</div><div class="line"></div><div class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">VH</span> <span class="keyword">extends</span> <span class="title">RecyclerView</span>.<span class="title">ViewHolder</span></span>&#123;...&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其中：</p>
<ul>
<li><code>getLayoutId(int viewType)</code>是根据viewType返回布局ID。</li>
<li><code>convert()</code>做具体的bind操作。</li>
</ul>
<p>就这样，万能适配器实现完成了。</p>
<h3 id="Item-Decoration"><a href="#Item-Decoration" class="headerlink" title="Item Decoration"></a>Item Decoration</h3><p>RecyclerView通过<code>addItemDecoration()</code>方法添加item之间的分割线。Android并没有提供实现好的Divider，因此任何分割线样式都需要自己实现。</p>
<p>方法是：创建一个类并继承RecyclerView.ItemDecoration，重写以下两个方法：</p>
<ul>
<li>onDraw(): 绘制分割线。</li>
<li>getItemOffsets(): 设置分割线的宽、高。</li>
</ul>
<p>Google在sample中给了一个参考的实现类：<a href="https://android.googlesource.com/platform/development/%2B/master/samples/Support7Demos/src/com/example/android/supportv7/widget/decorator/DividerItemDecoration.java" target="_blank" rel="external">DividerItemDecoration</a>，这里我们通过分析这个例子来看如何自定义Item Decoration。</p>
<p>首先看构造函数，构造函数中获得系统属性<code>android:listDivider</code>，该属性是一个Drawable对象。</p>
<p>因此如果要设置，则需要在value/styles.xml中设置：</p>
<figure class="highlight"><table><tr><td class="code"><pre><div class="line">&lt;style name="AppTheme" parent="Theme.AppCompat.Light.DarkActionBar"&gt;</div><div class="line">    &lt;item name="android:listDivider"&gt;@drawable/item_divider&lt;/item&gt;</div><div class="line">&lt;/style&gt;</div></pre></td></tr></table></figure>
<p>接着来看<code>getItemOffsets()</code>的实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getItemOffsets</span><span class="params">(Rect outRect, <span class="keyword">int</span> position, RecyclerView parent)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (mOrientation == VERTICAL_LIST) &#123;</div><div class="line">        outRect.set(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, mDivider.getIntrinsicHeight());</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        outRect.set(<span class="number">0</span>, <span class="number">0</span>, mDivider.getIntrinsicWidth(), <span class="number">0</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里只看<code>mOrientation == VERTICAL_LIST</code>的情况，outRect是当前item四周的间距，类似margin属性，现在设置了该item下间距为<code>mDivider.getIntrinsicHeight()</code>。</p>
<p>那么<code>getItemOffsets()</code>是怎么被调用的呢？</p>
<p>RecyclerView继承了ViewGroup，并重写了<code>measureChild()</code>，该方法在<code>onMeasure()</code>中被调用，用来计算每个child的大小，计算每个child大小的时候就需要加上<code>getItemOffsets()</code>设置的外间距：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">measureChild</span><span class="params">(View child, <span class="keyword">int</span> widthUsed, <span class="keyword">int</span> heightUsed)</span></span>&#123;</div><div class="line">	<span class="keyword">final</span> Rect insets = mRecyclerView.getItemDecorInsetsForChild(child);<span class="comment">//调用getItemOffsets()获得Rect对象</span></div><div class="line">	widthUsed += insets.left + insets.right;</div><div class="line">    heightUsed += insets.top + insets.bottom;</div><div class="line">    <span class="comment">//...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里我们只考虑<code>mOrientation == VERTICAL_LIST</code>的情况，DividerItemDecoration的<code>onDraw()</code>实际上调用了<code>drawVertical()</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawVertical</span><span class="params">(Canvas c, RecyclerView parent)</span> </span>&#123;</div><div class="line">    <span class="keyword">final</span> <span class="keyword">int</span> left = parent.getPaddingLeft();</div><div class="line">    <span class="keyword">final</span> <span class="keyword">int</span> right = parent.getWidth() - parent.getPaddingRight();</div><div class="line">    <span class="keyword">final</span> <span class="keyword">int</span> childCount = parent.getChildCount();</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 画每个item的分割线</div><div class="line">     */</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; childCount; i++) &#123;</div><div class="line">        <span class="keyword">final</span> View child = parent.getChildAt(i);</div><div class="line">        <span class="keyword">final</span> RecyclerView.LayoutParams params = (RecyclerView.LayoutParams) child</div><div class="line">                .getLayoutParams();</div><div class="line">        <span class="keyword">final</span> <span class="keyword">int</span> top = child.getBottom() + params.bottomMargin + Math.round(ViewCompat.getTranslationY(child));</div><div class="line">        <span class="keyword">final</span> <span class="keyword">int</span> bottom = top + mDivider.getIntrinsicHeight();</div><div class="line">        mDivider.setBounds(left, top, right, bottom);<span class="comment">/*规定好左上角和右下角*/</span></div><div class="line">        mDivider.draw(c);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>那么<code>onDraw()</code>是怎么被调用的呢？还有ItemDecoration还有一个方法<code>onDrawOver()</code>，该方法也可以被重写，那么<code>onDraw()</code>和<code>onDrawOver()</code>之间有什么关系呢？</p>
<p>我们来看下面的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">RecyclerView</span> <span class="keyword">extends</span> <span class="title">ViewGroup</span></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">(Canvas c)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.draw(c); <span class="comment">//调用View的draw()，该方法会先调用onDraw()，再调用dispatchDraw()绘制children</span></div><div class="line"></div><div class="line">        <span class="keyword">final</span> <span class="keyword">int</span> count = mItemDecorations.size();</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</div><div class="line">            mItemDecorations.get(i).onDrawOver(c, <span class="keyword">this</span>, mState);</div><div class="line">        &#125;</div><div class="line">        ...</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDraw</span><span class="params">(Canvas c)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.onDraw(c);</div><div class="line">        <span class="keyword">final</span> <span class="keyword">int</span> count = mItemDecorations.size();</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</div><div class="line">            mItemDecorations.get(i).onDraw(c, <span class="keyword">this</span>, mState);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>根据<a href="http://a.codekk.com/detail/Android/lightSky/%E5%85%AC%E5%85%B1%E6%8A%80%E6%9C%AF%E7%82%B9%E4%B9%8B%20View%20%E7%BB%98%E5%88%B6%E6%B5%81%E7%A8%8B" target="_blank" rel="external">View的绘制流程</a>，首先调用RecyclerView重写的<code>draw()</code>方法，随后<code>super.draw()</code>即调用View的<code>draw()</code>，该方法会先调用<code>onDraw()</code>（这个方法在RecyclerView重写了），再调用<code>dispatchDraw()</code>绘制children。因此：ItemDecoration的<code>onDraw()</code>在绘制Item之前调用，ItemDecoration的<code>onDrawOver()</code>在绘制Item之后调用。</p>
<p>当然，如果只需要实现Item之间相隔一定距离，那么只需要为Item的布局设置margin即可，没必要自己实现ItemDecoration这么麻烦。</p>
<h3 id="Layout-Manager"><a href="#Layout-Manager" class="headerlink" title="Layout Manager"></a>Layout Manager</h3><p>LayoutManager负责RecyclerView的布局，其中包含了Item View的获取与回收。这里我们简单分析LinearLayoutManager的实现。</p>
<p>对于LinearLayoutManager来说，比较重要的几个方法有：</p>
<ul>
<li><code>onLayoutChildren()</code>: 对RecyclerView进行布局的入口方法。</li>
<li><code>fill()</code>: 负责填充RecyclerView。</li>
<li><code>scrollVerticallyBy()</code>:根据手指的移动滑动一定距离，并调用<code>fill()</code>填充。</li>
<li><code>canScrollVertically()</code>或<code>canScrollHorizontally()</code>: 判断是否支持纵向滑动或横向滑动。</li>
</ul>
<p><code>onLayoutChildren()</code>的核心实现如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onLayoutChildren</span><span class="params">(RecyclerView.Recycler recycler, RecyclerView.State state)</span> </span>&#123;</div><div class="line">	detachAndScrapAttachedViews(recycler); <span class="comment">//将原来所有的Item View全部放到Recycler的Scrap Heap或Recycle Pool</span></div><div class="line">	fill(recycler, mLayoutState, state, <span class="keyword">false</span>); <span class="comment">//填充现在所有的Item View</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>RecyclerView的回收机制有个重要的概念，即将回收站分为Scrap Heap和Recycle Pool，其中Scrap Heap的元素可以被直接复用，而不需要调用<code>onBindViewHolder()</code>。<code>detachAndScrapAttachedViews()</code>会根据情况，将原来的Item View放入Scrap Heap或Recycle Pool，从而在复用时提升效率。</p>
<p><code>fill()</code>是对剩余空间不断地调用<code>layoutChunk()</code>，直到填充完为止。<code>layoutChunk()</code>的核心实现如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">layoutChunk</span><span class="params">()</span> </span>&#123;</div><div class="line">	View view = layoutState.next(recycler); <span class="comment">//调用了getViewForPosition()</span></div><div class="line">	addView(view);  <span class="comment">//加入View</span></div><div class="line">	measureChildWithMargins(view, <span class="number">0</span>, <span class="number">0</span>); <span class="comment">//计算View的大小</span></div><div class="line">	layoutDecoratedWithMargins(view, left, top, right, bottom); <span class="comment">//布局View</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其中<code>next()</code>调用了<code>getViewForPosition(currentPosition)</code>，该方法是从RecyclerView的回收机制实现类Recycler中获取合适的View，在后文的回收机制中会介绍该方法的具体实现。</p>
<p>如果要自定义LayoutManager，可以参考：</p>
<ul>
<li><a href="https://github.com/hehonghui/android-tech-frontier/blob/master/issue-9/%E5%88%9B%E5%BB%BA-RecyclerView-LayoutManager-Part-1.md" target="_blank" rel="external">创建一个 RecyclerView LayoutManager – Part 1</a></li>
<li><a href="https://github.com/hehonghui/android-tech-frontier/blob/master/issue-13/%E5%88%9B%E5%BB%BA-RecyclerView-LayoutManager-Part-2.md" target="_blank" rel="external">创建一个 RecyclerView LayoutManager – Part 2</a></li>
<li><a href="https://github.com/hehonghui/android-tech-frontier/blob/master/issue-13/%E5%88%9B%E5%BB%BA-RecyclerView-LayoutManager-Part-3.md" target="_blank" rel="external">创建一个 RecyclerView LayoutManager – Part 3</a></li>
</ul>
<h3 id="Item-Animator"><a href="#Item-Animator" class="headerlink" title="Item Animator"></a>Item Animator</h3><p>RecyclerView能够通过<code>mRecyclerView.setItemAnimator(ItemAnimator animator)</code>设置添加、删除、移动、改变的动画效果。RecyclerView提供了默认的ItemAnimator实现类：DefaultItemAnimator。这里我们通过分析DefaultItemAnimator的源码来介绍如何自定义Item Animator。</p>
<p>DefaultItemAnimator继承自SimpleItemAnimator，SimpleItemAnimator继承自ItemAnimator。</p>
<p>首先我们介绍ItemAnimator类的几个重要方法：</p>
<ul>
<li><em>animateAppearance()</em>: 当ViewHolder出现在屏幕上时被调用（可能是add或move）。</li>
<li><em>animateDisappearance()</em>: 当ViewHolder消失在屏幕上时被调用（可能是remove或move）。</li>
<li><em>animatePersistence()</em>: 在没调用<code>notifyItemChanged()</code>和<code>notifyDataSetChanged()</code>的情况下布局发生改变时被调用。</li>
<li><em>animateChange()</em>: 在显式调用<code>notifyItemChanged()</code>或<code>notifyDataSetChanged()</code>时被调用。</li>
<li>runPendingAnimations(): RecyclerView动画的执行方式并不是立即执行，而是每帧执行一次，比如两帧之间添加了多个Item，则会将这些将要执行的动画Pending住，保存在成员变量中，等到下一帧一起执行。该方法执行的前提是前面<code>animateXxx()</code>返回true。</li>
<li>isRunning(): 是否有动画要执行或正在执行。</li>
<li>dispatchAnimationsFinished(): 当全部动画执行完毕时被调用。</li>
</ul>
<p>上面用斜体字标识的方法比较难懂，不过没关系，因为Android提供了SimpleItemAnimator类（继承自ItemAnimator），该类提供了一系列更易懂的API，在自定义Item Animator时只需要继承SimpleItemAnimator即可：</p>
<ul>
<li>animateAdd(ViewHolder holder): 当Item添加时被调用。</li>
<li>animateMove(ViewHolder holder, int fromX, int fromY, int toX, int toY): 当Item移动时被调用。</li>
<li>animateRemove(ViewHolder holder): 当Item删除时被调用。</li>
<li>animateChange(ViewHolder oldHolder, ViewHolder newHolder, int fromLeft, int fromTop, int toLeft, int toTop): 当显式调用<code>notifyItemChanged()</code>或<code>notifyDataSetChanged()</code>时被调用。</li>
</ul>
<p>对于以上四个方法，注意两点：</p>
<ul>
<li>当Xxx动画开始执行前（在<code>runPendingAnimations()</code>中）需要调用<code>dispatchXxxStarting(holder)</code>，执行完后需要调用<code>dispatchXxxFinished(holder)</code>。</li>
<li>这些方法的内部实际上并不是书写执行动画的代码，而是将需要执行动画的Item全部存入成员变量中，并且返回值为true，然后在<code>runPendingAnimations()</code>中一并执行。</li>
</ul>
<p>DefaultItemAnimator类是RecyclerView提供的默认动画类。我们通过阅读该类源码学习如何自定义Item Animator。我们先看DefaultItemAnimator的成员变量：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">private</span> ArrayList&lt;ViewHolder&gt; mPendingAdditions = <span class="keyword">new</span> ArrayList&lt;&gt;();<span class="comment">//存放下一帧要执行的一系列add动画</span></div><div class="line">ArrayList&lt;ArrayList&lt;ViewHolder&gt;&gt; mAdditionsList = <span class="keyword">new</span> ArrayList&lt;&gt;();<span class="comment">//存放正在执行的一批add动画</span></div><div class="line">ArrayList&lt;ViewHolder&gt; mAddAnimations = <span class="keyword">new</span> ArrayList&lt;&gt;(); <span class="comment">//存放当前正在执行的add动画</span></div><div class="line"></div><div class="line"><span class="keyword">private</span> ArrayList&lt;ViewHolder&gt; mPendingRemovals = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">ArrayList&lt;ViewHolder&gt; mRemoveAnimations = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line"></div><div class="line"><span class="keyword">private</span> ArrayList&lt;MoveInfo&gt; mPendingMoves = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">ArrayList&lt;ArrayList&lt;MoveInfo&gt;&gt; mMovesList = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">ArrayList&lt;ViewHolder&gt; mMoveAnimations = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line"></div><div class="line"><span class="keyword">private</span> ArrayList&lt;ChangeInfo&gt; mPendingChanges = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">ArrayList&lt;ArrayList&lt;ChangeInfo&gt;&gt; mChangesList = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">ArrayList&lt;ViewHolder&gt; mChangeAnimations = <span class="keyword">new</span> ArrayList&lt;&gt;();</div></pre></td></tr></table></figure>
<p>DefaultItemAnimator实现了SimpleItemAnimator的<code>animateAdd()</code>方法，该方法只是将该item添加到mPendingAdditions中，等到<code>runPendingAnimations()</code>中执行。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">animateAdd</span><span class="params">(<span class="keyword">final</span> ViewHolder holder)</span> </span>&#123;</div><div class="line">    resetAnimation(holder);  <span class="comment">//重置清空所有动画</span></div><div class="line">    ViewCompat.setAlpha(holder.itemView, <span class="number">0</span>); <span class="comment">//将要做动画的View先变成透明</span></div><div class="line">    mPendingAdditions.add(holder);</div><div class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>接着看<code>runPendingAnimations()</code>的实现，该方法是执行remove,move,change,add动画，执行顺序为：remove动画最先执行，随后move和change并行执行，最后是add动画。为了简化，我们将remove,move,change动画执行过程省略，只看执行add动画的过程，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">runPendingAnimations</span><span class="params">()</span> </span>&#123;</div><div class="line">	<span class="comment">//1、判断是否有动画要执行，即各个动画的成员变量里是否有值。</span></div><div class="line">    <span class="comment">//2、执行remove动画</span></div><div class="line">    <span class="comment">//3、执行move动画</span></div><div class="line">    <span class="comment">//4、执行change动画，与move动画并行执行</span></div><div class="line">    <span class="comment">//5、执行add动画</span></div><div class="line">    <span class="keyword">if</span> (additionsPending) &#123;</div><div class="line">        <span class="keyword">final</span> ArrayList&lt;ViewHolder&gt; additions = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">        additions.addAll(mPendingAdditions);</div><div class="line">        mAdditionsList.add(additions);</div><div class="line">        mPendingAdditions.clear();</div><div class="line">        Runnable adder = <span class="keyword">new</span> Runnable() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                <span class="keyword">for</span> (ViewHolder holder : additions) &#123;</div><div class="line">                    animateAddImpl(holder);  <span class="comment">/***** 执行动画的方法 *****/</span></div><div class="line">                &#125;</div><div class="line">                additions.clear();</div><div class="line">                mAdditionsList.remove(additions);</div><div class="line">            &#125;</div><div class="line">        &#125;;</div><div class="line">        <span class="keyword">if</span> (removalsPending || movesPending || changesPending) &#123;</div><div class="line">            <span class="keyword">long</span> removeDuration = removalsPending ? getRemoveDuration() : <span class="number">0</span>;</div><div class="line">            <span class="keyword">long</span> moveDuration = movesPending ? getMoveDuration() : <span class="number">0</span>;</div><div class="line">            <span class="keyword">long</span> changeDuration = changesPending ? getChangeDuration() : <span class="number">0</span>;</div><div class="line">            <span class="keyword">long</span> totalDelay = removeDuration + Math.max(moveDuration, changeDuration);</div><div class="line">            View view = additions.get(<span class="number">0</span>).itemView;</div><div class="line">            ViewCompat.postOnAnimationDelayed(view, adder, totalDelay); <span class="comment">//等remove，move，change动画全部做完后，开始执行add动画</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>为了防止在执行add动画时外面有新的add动画添加到mPendingAdditions中，从而导致执行add动画错乱，这里将mPendingAdditions的内容移动到局部变量additions中，然后遍历additions执行动画。</p>
<p>在<code>runPendingAnimations()</code>中，<code>animateAddImpl()</code>是执行add动画的具体方法，其实就是将itemView的透明度从0变到1（在<code>animateAdd()</code>中已经将view的透明度变为0），实现如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">animateAddImpl</span><span class="params">(<span class="keyword">final</span> ViewHolder holder)</span> </span>&#123;</div><div class="line">    <span class="keyword">final</span> View view = holder.itemView;</div><div class="line">    <span class="keyword">final</span> ViewPropertyAnimatorCompat animation = ViewCompat.animate(view);</div><div class="line">    mAddAnimations.add(holder);</div><div class="line">    animation.alpha(<span class="number">1</span>).setDuration(getAddDuration()).</div><div class="line">            setListener(<span class="keyword">new</span> VpaListenerAdapter() &#123;</div><div class="line">                <span class="meta">@Override</span></div><div class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimationStart</span><span class="params">(View view)</span> </span>&#123;</div><div class="line">                    dispatchAddStarting(holder);  <span class="comment">//在开始add动画前调用</span></div><div class="line">                &#125;</div><div class="line">                <span class="meta">@Override</span></div><div class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimationCancel</span><span class="params">(View view)</span> </span>&#123;</div><div class="line">                    ViewCompat.setAlpha(view, <span class="number">1</span>);</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                <span class="meta">@Override</span></div><div class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimationEnd</span><span class="params">(View view)</span> </span>&#123;</div><div class="line">                    animation.setListener(<span class="keyword">null</span>);</div><div class="line">                    dispatchAddFinished(holder); <span class="comment">//在结束add动画后调用</span></div><div class="line">                    mAddAnimations.remove(holder);</div><div class="line">                    <span class="keyword">if</span> (!isRunning()) &#123;</div><div class="line">        				dispatchAnimationsFinished(); <span class="comment">//结束所有动画后调用</span></div><div class="line">    				&#125;</div><div class="line">                &#125;</div><div class="line">            &#125;).start();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从DefaultItemAnimator类的实现来看，发现自定义Item Animator好麻烦，需要继承SimpleItemAnimator类，然后实现一堆方法。别急，<a href="https://github.com/wasabeef/recyclerview-animators" target="_blank" rel="external">recyclerview-animators</a>解救你，原因如下：</p>
<p>首先，<a href="https://github.com/wasabeef/recyclerview-animators" target="_blank" rel="external">recyclerview-animators</a>提供了一系列的Animator，比如FadeInAnimator,ScaleInAnimator。其次，如果该库中没有你满意的动画，该库提供了BaseItemAnimator类，该类继承自SimpleItemAnimator，进一步封装了自定义Item Animator的代码，使得自定义Item Animator更方便，你只需要关注动画本身。如果要实现DefaultItemAnimator的代码，只需要以下实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultItemAnimator</span> <span class="keyword">extends</span> <span class="title">BaseItemAnimator</span> </span>&#123;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="title">DefaultItemAnimator</span><span class="params">()</span> </span>&#123;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="title">DefaultItemAnimator</span><span class="params">(Interpolator interpolator)</span> </span>&#123;</div><div class="line">    mInterpolator = interpolator;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="meta">@Override</span> <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">animateRemoveImpl</span><span class="params">(<span class="keyword">final</span> RecyclerView.ViewHolder holder)</span> </span>&#123;</div><div class="line">    ViewCompat.animate(holder.itemView)</div><div class="line">        .alpha(<span class="number">0</span>)</div><div class="line">        .setDuration(getRemoveDuration())</div><div class="line">        .setListener(<span class="keyword">new</span> DefaultRemoveVpaListener(holder))</div><div class="line">        .setStartDelay(getRemoveDelay(holder))</div><div class="line">        .start();</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="meta">@Override</span> <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">preAnimateAddImpl</span><span class="params">(RecyclerView.ViewHolder holder)</span> </span>&#123;</div><div class="line">    ViewCompat.setAlpha(holder.itemView, <span class="number">0</span>); <span class="comment">//透明度先变为0</span></div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="meta">@Override</span> <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">animateAddImpl</span><span class="params">(<span class="keyword">final</span> RecyclerView.ViewHolder holder)</span> </span>&#123;</div><div class="line">    ViewCompat.animate(holder.itemView)</div><div class="line">        .alpha(<span class="number">1</span>)</div><div class="line">        .setDuration(getAddDuration())</div><div class="line">        .setListener(<span class="keyword">new</span> DefaultAddVpaListener(holder))</div><div class="line">        .setStartDelay(getAddDelay(holder))</div><div class="line">        .start();</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>是不是比继承SimpleItemAnimator方便多了。</p>
<p>对于RecyclerView的Item Animator，有一个常见的坑就是”闪屏问题”。这个问题的描述是：当Item视图中有图片和文字，当更新文字并调用<code>notifyItemChanged()</code>时，文字改变的同时图片会闪一下。这个问题的原因是当调用<code>notifyItemChanged()</code>时，会调用DefaultItemAnimator的<code>animateChangeImpl()</code>执行change动画，该动画会使得Item的透明度从0变为1，从而造成闪屏。</p>
<p>解决办法很简单，在<code>rv.setAdapter()</code>之前调用<code>((SimpleItemAnimator)rv.getItemAnimator()).setSupportsChangeAnimations(false)</code>禁用change动画。</p>
<h2 id="拓展RecyclerView"><a href="#拓展RecyclerView" class="headerlink" title="拓展RecyclerView"></a>拓展RecyclerView</h2><h3 id="添加setOnItemClickListener接口"><a href="#添加setOnItemClickListener接口" class="headerlink" title="添加setOnItemClickListener接口"></a>添加setOnItemClickListener接口</h3><p>RecyclerView默认没有像ListView一样提供<code>setOnItemClickListener()</code>接口，而<a href="http://blog.csdn.net/liaoinstan/article/details/51200600" target="_blank" rel="external">RecyclerView无法添加onItemClickListener最佳的高效解决方案</a>这篇文章给出了通过<code>recyclerView.addOnItemTouchListener(...)</code>添加点击事件的方法，但我认为根本没有必要费这么大劲对外暴露这个接口，因为我们完全可以把点击事件的实现写在Adapter的<code>onBindViewHolder()</code>中，不暴露出来。具体方法就是通过：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onBindViewHolder</span><span class="params">(VH holder, <span class="keyword">int</span> position)</span> </span>&#123;</div><div class="line">    holder.itemView.setOnClickListener(...);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="添加HeaderView和FooterView"><a href="#添加HeaderView和FooterView" class="headerlink" title="添加HeaderView和FooterView"></a>添加HeaderView和FooterView</h3><p>RecyclerView默认没有提供类似<code>addHeaderView()</code>和<code>addFooterView()</code>的API，因此这里介绍如何优雅地实现这两个接口。</p>
<p>如果你已经实现了一个Adapter，现在想为这个Adapter添加<code>addHeaderView()</code>和<code>addFooterView()</code>接口，则需要在Adapter中添加几个Item Type，然后修改<code>getItemViewType()</code>,<code>onCreateViewHolder()</code>,<code>onBindViewHolder()</code>,<code>getItemCount()</code>等方法，并添加switch语句进行判断。那么如何在不破坏原有Adapter实现的情况下完成呢？</p>
<p>这里引入装饰器（Decorator）设计模式，该设计模式通过组合的方式，在不破话原有类代码的情况下，对原有类的功能进行扩展。</p>
<p>这恰恰满足了我们的需求。我们只需要通过以下方式为原有的Adapter（这里命名为NormalAdapter）添加<code>addHeaderView()</code>和<code>addFooterView()</code>接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">NormalAdapter adapter = <span class="keyword">new</span> NormalAdapter(data);</div><div class="line">NormalAdapterWrapper newAdapter = <span class="keyword">new</span> NormalAdapterWrapper(adapter);</div><div class="line">View headerView = LayoutInflater.from(<span class="keyword">this</span>).inflate(R.layout.item_header, mRecyclerView, <span class="keyword">false</span>);</div><div class="line">View footerView = LayoutInflater.from(<span class="keyword">this</span>).inflate(R.layout.item_footer, mRecyclerView, <span class="keyword">false</span>);</div><div class="line">newAdapter.addFooterView(footerView);</div><div class="line">newAdapter.addHeaderView(headerView);</div><div class="line">mRecyclerView.setAdapter(newAdapter);</div></pre></td></tr></table></figure>
<p>是不是看起来特别优雅。具体实现思路其实很简单，创建一个继承<code>RecyclerView.Adapter&lt;RecyclerView.ViewHolder&gt;</code>的类，并重写常见的方法，然后通过引入ITEM TYPE的方式实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NormalAdapterWrapper</span> <span class="keyword">extends</span> <span class="title">RecyclerView</span>.<span class="title">Adapter</span>&lt;<span class="title">RecyclerView</span>.<span class="title">ViewHolder</span>&gt;</span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">enum</span> ITEM_TYPE&#123;</div><div class="line">        HEADER,</div><div class="line">        FOOTER,</div><div class="line">        NORMAL</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> NormalAdapter mAdapter;</div><div class="line">    <span class="keyword">private</span> View mHeaderView;</div><div class="line">    <span class="keyword">private</span> View mFooterView;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NormalAdapterWrapper</span><span class="params">(NormalAdapter adapter)</span></span>&#123;</div><div class="line">        mAdapter = adapter;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getItemViewType</span><span class="params">(<span class="keyword">int</span> position)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(position == <span class="number">0</span>)&#123;</div><div class="line">            <span class="keyword">return</span> ITEM_TYPE.HEADER.ordinal();</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(position == mAdapter.getItemCount() + <span class="number">1</span>)&#123;</div><div class="line">            <span class="keyword">return</span> ITEM_TYPE.FOOTER.ordinal();</div><div class="line">        &#125; <span class="keyword">else</span>&#123;</div><div class="line">            <span class="keyword">return</span> ITEM_TYPE.NORMAL.ordinal();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getItemCount</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> mAdapter.getItemCount() + <span class="number">2</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onBindViewHolder</span><span class="params">(RecyclerView.ViewHolder holder, <span class="keyword">int</span> position)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(position == <span class="number">0</span>)&#123;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(position == mAdapter.getItemCount() + <span class="number">1</span>)&#123;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125; <span class="keyword">else</span>&#123;</div><div class="line">            mAdapter.onBindViewHolder(((NormalAdapter.VH)holder), position - <span class="number">1</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="keyword">public</span> RecyclerView.<span class="function">ViewHolder <span class="title">onCreateViewHolder</span><span class="params">(ViewGroup parent, <span class="keyword">int</span> viewType)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(viewType == ITEM_TYPE.HEADER.ordinal())&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> RecyclerView.ViewHolder(mHeaderView) &#123;&#125;;</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(viewType == ITEM_TYPE.FOOTER.ordinal())&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> RecyclerView.ViewHolder(mFooterView) &#123;&#125;;</div><div class="line">        &#125; <span class="keyword">else</span>&#123;</div><div class="line">            <span class="keyword">return</span> mAdapter.onCreateViewHolder(parent,viewType);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addHeaderView</span><span class="params">(View view)</span></span>&#123;</div><div class="line">        <span class="keyword">this</span>.mHeaderView = view;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addFooterView</span><span class="params">(View view)</span></span>&#123;</div><div class="line">        <span class="keyword">this</span>.mFooterView = view;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="添加setEmptyView"><a href="#添加setEmptyView" class="headerlink" title="添加setEmptyView"></a>添加setEmptyView</h3><p>ListView提供了<code>setEmptyView()</code>设置Adapter数据为空时的View视图。RecyclerView虽然没提供直接的API，但是也可以很简单地实现。</p>
<ul>
<li>创建一个继承RecyclerView的类，记为EmptyRecyclerView。</li>
<li>通过<code>getRootView().addView(emptyView)</code>将空数据时显示的View添加到当前View的层次结构中。</li>
<li>通过AdapterDataObserver监听RecyclerView的数据变化，如果adapter为空，那么隐藏RecyclerView，显示EmptyView。</li>
</ul>
<p>具体实现如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmptyRecyclerView</span> <span class="keyword">extends</span> <span class="title">RecyclerView</span></span>&#123;</div><div class="line"></div><div class="line">	<span class="keyword">private</span> View mEmptyView;</div><div class="line"></div><div class="line">	<span class="keyword">private</span> AdapterDataObserver mObserver = <span class="keyword">new</span> AdapterDataObserver() &#123;</div><div class="line">    	<span class="meta">@Override</span></div><div class="line">    	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onChanged</span><span class="params">()</span> </span>&#123;</div><div class="line">            Adapter adapter = getAdapter();</div><div class="line">            <span class="keyword">if</span>(adapter.getItemCount() == <span class="number">0</span>)&#123;</div><div class="line">                mEmptyView.setVisibility(VISIBLE);</div><div class="line">                EmptyRecyclerView.<span class="keyword">this</span>.setVisibility(GONE);</div><div class="line">            &#125; <span class="keyword">else</span>&#123;</div><div class="line">                mEmptyView.setVisibility(GONE);</div><div class="line">                EmptyRecyclerView.<span class="keyword">this</span>.setVisibility(VISIBLE);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onItemRangeChanged</span><span class="params">(<span class="keyword">int</span> positionStart, <span class="keyword">int</span> itemCount)</span> </span>&#123;onChanged();&#125;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onItemRangeMoved</span><span class="params">(<span class="keyword">int</span> fromPosition, <span class="keyword">int</span> toPosition, <span class="keyword">int</span> itemCount)</span> </span>&#123;onChanged();&#125;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onItemRangeRemoved</span><span class="params">(<span class="keyword">int</span> positionStart, <span class="keyword">int</span> itemCount)</span> </span>&#123;onChanged();&#125;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onItemRangeInserted</span><span class="params">(<span class="keyword">int</span> positionStart, <span class="keyword">int</span> itemCount)</span> </span>&#123;onChanged();&#125;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onItemRangeChanged</span><span class="params">(<span class="keyword">int</span> positionStart, <span class="keyword">int</span> itemCount, Object payload)</span> </span>&#123;onChanged();&#125;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">EmptyRecyclerView</span><span class="params">(Context context, @Nullable AttributeSet attrs)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(context, attrs);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setEmptyView</span><span class="params">(View view)</span></span>&#123;</div><div class="line">        <span class="keyword">this</span>.mEmptyView = view;</div><div class="line">        ((ViewGroup)<span class="keyword">this</span>.getRootView()).addView(mEmptyView); <span class="comment">//加入主界面布局</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAdapter</span><span class="params">(RecyclerView.Adapter adapter)</span></span>&#123;</div><div class="line">        <span class="keyword">super</span>.setAdapter(adapter);</div><div class="line">        adapter.registerAdapterDataObserver(mObserver);</div><div class="line">        mObserver.onChanged();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="拖拽、侧滑删除"><a href="#拖拽、侧滑删除" class="headerlink" title="拖拽、侧滑删除"></a>拖拽、侧滑删除</h3><p>Android提供了ItemTouchHelper类，使得RecyclerView能够轻易地实现滑动和拖拽，此处我们要实现上下拖拽和侧滑删除。首先创建一个继承自<code>ItemTouchHelper.Callback</code>的类，并重写以下方法：</p>
<ul>
<li><code>getMovementFlags()</code>: 设置支持的拖拽和滑动的方向，此处我们支持的拖拽方向为上下，滑动方向为从左到右和从右到左，内部通过<code>makeMovementFlags()</code>设置。</li>
<li><code>onMove()</code>: 拖拽时回调。</li>
<li><code>onSwiped()</code>: 滑动时回调。</li>
<li><code>onSelectedChanged()</code>: 状态变化时回调，一共有三个状态，分别是ACTION_STATE_IDLE(空闲状态)，ACTION_STATE_SWIPE(滑动状态)，ACTION_STATE_DRAG(拖拽状态)。此方法中可以做一些状态变化时的处理，比如拖拽的时候修改背景色。</li>
<li><code>clearView()</code>: 用户交互结束时回调。此方法可以做一些状态的清空，比如拖拽结束后还原背景色。</li>
<li><code>isLongPressDragEnabled()</code>: 是否支持长按拖拽，默认为true。如果不想支持长按拖拽，则重写并返回false。</li>
</ul>
<p>具体实现如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleItemTouchCallback</span> <span class="keyword">extends</span> <span class="title">ItemTouchHelper</span>.<span class="title">Callback</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> NormalAdapter mAdapter;</div><div class="line">    <span class="keyword">private</span> List&lt;ObjectModel&gt; mData;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SimpleItemTouchCallback</span><span class="params">(NormalAdapter adapter, List&lt;ObjectModel&gt; data)</span></span>&#123;</div><div class="line">        mAdapter = adapter;</div><div class="line">        mData = data;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMovementFlags</span><span class="params">(RecyclerView recyclerView, RecyclerView.ViewHolder viewHolder)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> dragFlag = ItemTouchHelper.UP | ItemTouchHelper.DOWN; <span class="comment">//s上下拖拽</span></div><div class="line">        <span class="keyword">int</span> swipeFlag = ItemTouchHelper.START | ItemTouchHelper.END; <span class="comment">//左-&gt;右和右-&gt;左滑动</span></div><div class="line">        <span class="keyword">return</span> makeMovementFlags(dragFlag,swipeFlag);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onMove</span><span class="params">(RecyclerView recyclerView, RecyclerView.ViewHolder viewHolder, RecyclerView.ViewHolder target)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> from = viewHolder.getAdapterPosition();</div><div class="line">        <span class="keyword">int</span> to = target.getAdapterPosition();</div><div class="line">        Collections.swap(mData, from, to);</div><div class="line">        mAdapter.notifyItemMoved(from, to);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSwiped</span><span class="params">(RecyclerView.ViewHolder viewHolder, <span class="keyword">int</span> direction)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> pos = viewHolder.getAdapterPosition();</div><div class="line">        mData.remove(pos);</div><div class="line">        mAdapter.notifyItemRemoved(pos);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSelectedChanged</span><span class="params">(RecyclerView.ViewHolder viewHolder, <span class="keyword">int</span> actionState)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.onSelectedChanged(viewHolder, actionState);</div><div class="line">        <span class="keyword">if</span>(actionState != ItemTouchHelper.ACTION_STATE_IDLE)&#123;</div><div class="line">            NormalAdapter.VH holder = (NormalAdapter.VH)viewHolder;</div><div class="line">            holder.itemView.setBackgroundColor(<span class="number">0xffbcbcbc</span>); <span class="comment">//设置拖拽和侧滑时的背景色</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clearView</span><span class="params">(RecyclerView recyclerView, RecyclerView.ViewHolder viewHolder)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.clearView(recyclerView, viewHolder);</div><div class="line">        NormalAdapter.VH holder = (NormalAdapter.VH)viewHolder;</div><div class="line">        holder.itemView.setBackgroundColor(<span class="number">0xffeeeeee</span>); <span class="comment">//背景色还原</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后通过以下代码为RecyclerView设置该滑动、拖拽功能：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">ItemTouchHelper helper = <span class="keyword">new</span> ItemTouchHelper(<span class="keyword">new</span> SimpleItemTouchCallback(adapter, data));</div><div class="line">helper.attachToRecyclerView(recyclerview);</div></pre></td></tr></table></figure>
<p>前面拖拽的触发方式只有长按，如果想支持触摸Item中的某个View实现拖拽，则核心方法为<code>helper.startDrag(holder)</code>。首先定义接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">OnStartDragListener</span></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">startDrag</span><span class="params">(RecyclerView.ViewHolder holder)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后让Activity实现该接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> MainActivity extends Activity implements OnStartDragListener&#123;</div><div class="line">    ...</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startDrag</span><span class="params">(RecyclerView.ViewHolder holder)</span> </span>&#123;</div><div class="line">        mHelper.startDrag(holder);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果要对ViewHolder的text对象支持触摸拖拽，则在Adapter中的<code>onBindViewHolder()</code>中添加：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">holder.text.setOnTouchListener(<span class="keyword">new</span> View.OnTouchListener() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTouch</span><span class="params">(View v, MotionEvent event)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(event.getAction() == MotionEvent.ACTION_DOWN)&#123;</div><div class="line">            mListener.startDrag(holder);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>其中mListener是在创建Adapter时将实现OnStartDragListener接口的Activity对象作为参数传进来。</p>
<h2 id="回收机制"><a href="#回收机制" class="headerlink" title="回收机制"></a>回收机制</h2><h3 id="ListView回收机制"><a href="#ListView回收机制" class="headerlink" title="ListView回收机制"></a>ListView回收机制</h3><p>ListView为了保证Item View的复用，实现了一套回收机制，该回收机制的实现类是RecycleBin，他实现了两级缓存：</p>
<ul>
<li><code>View[] mActiveViews</code>: 缓存屏幕上的View，在该缓存里的View不需要调用<code>getView()</code>。</li>
<li><code>ArrayList&lt;View&gt;[] mScrapViews;</code>: 每个Item Type对应一个列表作为回收站，缓存由于滚动而消失的View，此处的View如果被复用，会以参数的形式传给<code>getView()</code>。</li>
</ul>
<p>接下来我们通过源码分析ListView是如何与RecycleBin交互的。其实ListView和RecyclerView的layout过程大同小异，ListView的布局函数是<code>layoutChildren()</code>，实现如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">layoutChildren</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="comment">//1. 如果数据被改变了，则将所有Item View回收至scrapView（而RecyclerView会根据情况放入Scrap Heap或RecyclePool）；否则回收至mActiveViews</span></div><div class="line">    <span class="keyword">if</span> (dataChanged) &#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; childCount; i++) &#123;</div><div class="line">            recycleBin.addScrapView(getChildAt(i), firstPosition+i);</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        recycleBin.fillActiveViews(childCount, firstPosition);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//2. 填充</span></div><div class="line">    <span class="keyword">switch</span>()&#123;</div><div class="line">        <span class="keyword">case</span> LAYOUT_XXX:</div><div class="line">            fillXxx();</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> LAYOUT_XXX:</div><div class="line">            fillXxx();</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//3. 回收多余的activeView</span></div><div class="line">    mRecycler.scrapActiveViews();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其中<code>fillXxx()</code>实现了对Item View进行填充，该方法内部调用了<code>makeAndAddView()</code>，实现如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function">View <span class="title">makeAndAddView</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="keyword">if</span> (!mDataChanged) &#123;</div><div class="line">        child = mRecycler.getActiveView(position);</div><div class="line">        <span class="keyword">if</span> (child != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">return</span> child;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    child = obtainView(position, mIsScrap);</div><div class="line">    <span class="keyword">return</span> child;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其中，<code>getActiveView()</code>是从mActiveViews中获取合适的View，如果获取到了，则直接返回，而不调用<code>obtainView()</code>，这也印证了如果从mActiveViews获取到了可复用的View，则不需要调用<code>getView()</code>。</p>
<p><code>obtainView()</code>是从mScrapViews中获取合适的View，然后以参数形式传给了<code>getView()</code>，实现如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function">View <span class="title">obtainView</span><span class="params">(<span class="keyword">int</span> position)</span></span>&#123;</div><div class="line">    <span class="keyword">final</span> View scrapView = mRecycler.getScrapView(position);  <span class="comment">//从RecycleBin中获取复用的View</span></div><div class="line">    <span class="keyword">final</span> View child = mAdapter.getView(position, scrapView, <span class="keyword">this</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>接下去我们介绍<code>getScrapView(position)</code>的实现，该方法通过position得到Item Type，然后根据Item Type从mScrapViews获取可复用的View，如果获取不到，则返回null，具体实现如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">RecycleBin</span></span>&#123;</div><div class="line">    <span class="keyword">private</span> View[] mActiveViews;    <span class="comment">//存储屏幕上的View</span></div><div class="line">    <span class="keyword">private</span> ArrayList&lt;View&gt;[] mScrapViews;  <span class="comment">//每个item type对应一个ArrayList</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> mViewTypeCount;            <span class="comment">//item type的个数</span></div><div class="line">    <span class="keyword">private</span> ArrayList&lt;View&gt; mCurrentScrap;  <span class="comment">//mScrapViews[0]</span></div><div class="line"></div><div class="line">    <span class="function">View <span class="title">getScrapView</span><span class="params">(<span class="keyword">int</span> position)</span> </span>&#123;</div><div class="line">        <span class="keyword">final</span> <span class="keyword">int</span> whichScrap = mAdapter.getItemViewType(position);</div><div class="line">        <span class="keyword">if</span> (whichScrap &lt; <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (mViewTypeCount == <span class="number">1</span>) &#123;</div><div class="line">            <span class="keyword">return</span> retrieveFromScrap(mCurrentScrap, position);</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (whichScrap &lt; mScrapViews.length) &#123;</div><div class="line">            <span class="keyword">return</span> retrieveFromScrap(mScrapViews[whichScrap], position);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">private</span> View <span class="title">retrieveFromScrap</span><span class="params">(ArrayList&lt;View&gt; scrapViews, <span class="keyword">int</span> position)</span></span>&#123;</div><div class="line">        <span class="keyword">int</span> size = scrapViews.size();</div><div class="line">        <span class="keyword">if</span>(size &gt; <span class="number">0</span>)&#123;</div><div class="line">            <span class="keyword">return</span> scrapView.remove(scrapViews.size() - <span class="number">1</span>);  <span class="comment">//从回收列表中取出最后一个元素复用</span></div><div class="line">        &#125; <span class="keyword">else</span>&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="RecyclerView回收机制"><a href="#RecyclerView回收机制" class="headerlink" title="RecyclerView回收机制"></a>RecyclerView回收机制</h3><p>RecyclerView和ListView的回收机制非常相似，但是ListView是以View作为单位进行回收，RecyclerView是以ViewHolder作为单位进行回收。Recycler是RecyclerView回收机制的实现类，他实现了四级缓存：</p>
<ul>
<li>mAttachedScrap: 缓存在屏幕上的ViewHolder。</li>
<li>mCachedViews: 缓存屏幕外的ViewHolder，默认为2个。ListView对于屏幕外的缓存都会调用<code>getView()</code>。</li>
<li>mViewCacheExtensions: 需要用户定制，默认不实现。</li>
<li>mRecyclerPool: 缓存池，多个RecyclerView共用。</li>
</ul>
<p>在上文Layout Manager中已经介绍了RecyclerView的layout过程，但是一笔带过了<code>getViewForPosition()</code>，因此此处介绍该方法的实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function">View <span class="title">getViewForPosition</span><span class="params">(<span class="keyword">int</span> position, <span class="keyword">boolean</span> dryRun)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>(holder == <span class="keyword">null</span>)&#123;</div><div class="line">        <span class="comment">//从mAttachedScrap,mCachedViews获取ViewHolder</span></div><div class="line">        holder = getScrapViewForPosition(position,INVALID,dryRun); <span class="comment">//此处获得的View不需要bind</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">final</span> <span class="keyword">int</span> type = mAdapter.getItemViewType(offsetPosition);</div><div class="line">    <span class="keyword">if</span> (mAdapter.hasStableIds()) &#123; <span class="comment">//默认为false</span></div><div class="line">        holder = getScrapViewForId(mAdapter.getItemId(offsetPosition), type, dryRun);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span>(holder == <span class="keyword">null</span> &amp;&amp; mViewCacheExtension != <span class="keyword">null</span>)&#123;</div><div class="line">        <span class="keyword">final</span> View view = mViewCacheExtension.getViewForPositionAndType(<span class="keyword">this</span>, position, type); <span class="comment">//从</span></div><div class="line">        <span class="keyword">if</span>(view != <span class="keyword">null</span>)&#123;</div><div class="line">            holder = getChildViewHolder(view);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span>(holder == <span class="keyword">null</span>)&#123;</div><div class="line">        holder = getRecycledViewPool().getRecycledView(type);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span>(holder == <span class="keyword">null</span>)&#123;  <span class="comment">//没有缓存，则创建</span></div><div class="line">        holder = mAdapter.createViewHolder(RecyclerView.<span class="keyword">this</span>, type); <span class="comment">//调用onCreateViewHolder()</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span>(!holder.isBound() || holder.needsUpdate() || holder.isInvalid())&#123;</div><div class="line">    	mAdapter.bindViewHolder(holder, offsetPosition);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> holder.itemView;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从上述实现可以看出，依次从mAttachedScrap, mCachedViews, mViewCacheExtension, mRecyclerPool寻找可复用的ViewHolder，如果是从mAttachedScrap或mCachedViews中获取的ViewHolder，则不会调用<code>onBindViewHolder()</code>，mAttachedScrap和mCachedViews也就是我们所说的Scrap Heap；而如果从mViewCacheExtension或mRecyclerPool中获取的ViewHolder，则会调用<code>onBindViewHolder()</code>。</p>
<p>RecyclerView局部刷新的实现原理也是基于RecyclerView的回收机制，即能直接复用的ViewHolder就不调用<code>onBindViewHolder()</code>。</p>
<h2 id="嵌套滑动机制"><a href="#嵌套滑动机制" class="headerlink" title="嵌套滑动机制"></a>嵌套滑动机制</h2><p>Android 5.0推出了嵌套滑动机制，在之前，一旦子View处理了触摸事件，父View就没有机会再处理这次的触摸事件，而嵌套滑动机制解决了这个问题，能够实现如下效果：</p>
<p><img src="https://github.com/xiazdong/RecyclerViewDemo/blob/master/app/src/main/res/assets/demo6.gif?raw=true" height="400px"></p>
<p>为了支持嵌套滑动，子View必须实现NestedScrollingChild接口，父View必须实现NestedScrollingParent接口，而RecyclerView实现了NestedScrollingChild接口，而CoordinatorLayout实现了NestedScrollingParent接口，上图是实现CoordinatorLayout嵌套RecyclerView的效果。</p>
<p>为了实现上图的效果，需要用到的组件有：</p>
<ul>
<li>CoordinatorLayout: 布局根元素。</li>
<li>AppBarLayout: 包裹的内容作为应用的Bar。</li>
<li>CollapsingToolbarLayout: 实现可折叠的ToolBar。</li>
<li>ToolBar: 代替ActionBar。</li>
</ul>
<p>实现中需要注意的点有：</p>
<ul>
<li>我们为ToolBar的<code>app:layout_collapseMode</code>设置为pin，表示折叠之后固定在顶端，而为ImageView的<code>app:layout_collapseMode</code>设置为parallax，表示视差模式，即渐变的效果。</li>
<li>为了让RecyclerView支持嵌套滑动，还需要为它设置<code>app:layout_behavior=&quot;@string/appbar_scrolling_view_behavior&quot;</code>。</li>
<li>为CollapsingToolbarLayout设置<code>app:layout_scrollFlags=&quot;scroll|exitUntilCollapsed&quot;</code>，其中scroll表示滚动出屏幕，exitUntilCollapsed表示退出后折叠。</li>
</ul>
<p>具体实现参见Demo6。</p>
<h2 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h2><p>回顾整篇文章，发现我们已经实现了RecyclerView的很多扩展功能，包括：打造万能适配器、添加Item事件、添加头视图和尾视图、设置空布局、侧滑拖拽。<a href="http://www.recyclerview.org/" target="_blank" rel="external">BaseRecyclerViewAdapterHelper</a>是一个比较火的RecyclerView扩展库，仔细一看发现，这里面80%的功能在我们这篇文章中都实现了。</p>
<h2 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h2><ul>
<li><a href="http://v.youku.com/v_show/id_XMTU4MTQ1ODg2NA==.html?f=27314446" target="_blank" rel="external">Google I/O 2016: RecyclerView Ins and Outs</a></li>
<li><a href="https://github.com/CymChad/CymChad.github.io" target="_blank" rel="external">RecyclerView优秀文章集</a></li>
</ul>

    
  </div>
</article>


   
  <div class="text-center donation">
    <div class="inner-donation">
      <span class="btn-donation">支持一下</span>
      <div class="donation-body">
        <div class="tip text-center">扫一扫，支持xiazdong</div>
        <ul class="theme.donation.items.length">
        
          <li class="item">
            <img src="/images/qr-wechat.png" alt="">
          </li>
        
          <li class="item">
            <img src="/images/qr-alipay.png" alt="">
          </li>
        
        </ul>
      </div>
    </div>
  </div>


   
  <div class="box-prev-next clearfix">
    <a class="show pull-left" href="/2016/09/29/自定义Dialog/">
        <i class="icon icon-angle-left"></i>
    </a>
    <a class="show pull-right" href="/2017/03/20/使用APK Analyzer分析你的APK/">
        <i class="icon icon-angle-right"></i>
    </a>
  </div>




</div>


  <a id="backTop" class="back-top">
    <i class="icon-angle-up"></i>
  </a>




  <div class="modal" id="modal">
  <span id="cover" class="cover hide"></span>
  <div id="modal-dialog" class="modal-dialog hide-dialog">
    <div class="modal-header">
      <span id="close" class="btn-close">关闭</span>
    </div>
    <hr>
    <div class="modal-body">
      <ul class="list-toolbox">
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/archives/"
              rel="noopener noreferrer"
              target="_self"
              >
              博客
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/tag/"
              rel="noopener noreferrer"
              target="_self"
              >
              分类
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/about/"
              rel="noopener noreferrer"
              target="_self"
              >
              关于
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/atom.xml"
              rel="noopener noreferrer"
              target="_blank"
              >
              RSS
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/search/"
              rel="noopener noreferrer"
              target="_self"
              >
              搜索
            </a>
          </li>
        
      </ul>

    </div>
  </div>
</div>



  
      <div class="fexo-comments comments-post">
    
<section class="comments" id="comments">
    <div id="gitment_thread"></div>
    <link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css">
    <script src="https://imsun.github.io/gitment/dist/gitment.browser.js"></script>
    <script>
        var gitment = new Gitment({
            owner: 'xiazdong',
            repo: 'xiazdong.github.io',
            oauth: {
                client_id: 'bc86691774f8cb0e00e6',
                client_secret: 'd8156dbfc230d37f892473f71d2426b6fb7a72e2',
            },
        })
        gitment.render('comments')
    </script>
</section>

  </div>

  

  <script type="text/javascript">
  function loadScript(url, callback) {
    var script = document.createElement('script')
    script.type = 'text/javascript';

    if (script.readyState) { //IE
      script.onreadystatechange = function() {
        if (script.readyState == 'loaded' ||
          script.readyState == 'complete') {
          script.onreadystatechange = null;
          callback();
        }
      };
    } else { //Others
      script.onload = function() {
        callback();
      };
    }

    script.src = url;
    document.getElementsByTagName('head')[0].appendChild(script);
  }

  window.onload = function() {
    loadScript('/js/bundle.js?235683', function() {
      // load success
    });
  }
</script>

</body>
</html>
